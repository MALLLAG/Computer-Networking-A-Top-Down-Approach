# 4.2 라우터의 내부 구성 (What’s Inside a Router?)

이제 데이터 평면(data plane)과 제어 평면(control plane)의 차이점,  
그리고 네트워크 계층의 기능과 서비스를 살펴보았으므로,  
이제 라우터 내부에서 실제로 **패킷 전달(forwarding)** 이 어떻게 이루어지는지에 집중해봅시다.  
즉, 라우터가 수신 링크로 들어온 패킷을 어떤 출력 링크로 전송할지 결정하는 과정입니다.

<img width="655" height="350" alt="Image" src="https://github.com/user-attachments/assets/e60ab821-ae7e-43ba-a743-dc92bcd9c197" />

그림 4.4는 일반적인 라우터의 아키텍처를 단순화한 개요를 보여줍니다.  
라우터는 다음의 네 가지 주요 구성 요소로 나눌 수 있습니다.

## 라우터의 주요 구성 요소

### 1. 입력 포트 (Input Ports)

입력 포트는 여러 가지 중요한 기능을 수행합니다.

- **물리 계층 기능**:  
  입력 포트는 들어오는 물리적 링크를 종단(terminate)합니다.  
  그림 4.4에서 입력 포트의 왼쪽 상자가 이를 나타냅니다.

- **링크 계층 기능**:  
  다른 쪽 링크 계층과 상호 작용하기 위해 필요한 기능을 수행합니다.  
  이는 그림에서 입력 포트의 중간 상자로 표현됩니다.

- **전달 테이블 조회 (Forwarding Table Lookup)**:  
  입력 포트의 가장 오른쪽 부분에서 수행됩니다.  
  여기서 라우터는 전달 테이블을 참조하여  
  들어온 패킷을 어떤 출력 포트로 전송할지를 결정합니다.

또한 제어용 패킷(예: 라우팅 프로토콜 정보 등)은  
입력 포트에서 라우팅 프로세서로 전달됩니다.

> “포트(port)”라는 용어는 여기서 **물리적 포트(입출력 인터페이스)** 를 의미합니다.  
> 이는 앞서 전송 계층에서 다루었던 소프트웨어 포트(소켓 번호 등)와 구별됩니다.

실제 상용 라우터에서는 포트 수가 다양합니다.  
기업용 라우터는 소수의 포트를 갖지만,  
ISP(인터넷 서비스 제공자)의 엣지 라우터는 수백 개의 10Gbps 포트를 가질 수 있습니다.  
예를 들어, **Juniper MX2020** 라우터는 최대 **800개의 100Gbps 포트**를 지원하며,  
총 처리 용량은 **800Tbps**에 달합니다.

### 2. 스위칭 패브릭 (Switching Fabric)

스위칭 패브릭은 라우터의 입력 포트를 출력 포트와 연결하는 역할을 합니다.  
즉, 라우터 내부의 “미니 네트워크”라고 볼 수 있습니다.  
이 부분을 통해 입력 포트에서 수신된 패킷이  
적절한 출력 포트로 전달됩니다.

### 3. 출력 포트 (Output Ports)

출력 포트는 스위칭 패브릭으로부터 전달받은 패킷을 저장하고,  
이를 물리적 링크를 통해 송신합니다.  
이 과정에서 링크 계층과 물리 계층의 기능이 모두 수행됩니다.  
링크가 양방향인 경우, 동일한 라인 카드(line card)에서  
해당 링크의 입력 포트와 출력 포트가 쌍으로 존재합니다.

### 4. 라우팅 프로세서 (Routing Processor)

라우팅 프로세서는 **제어 평면(control plane)** 의 기능을 수행합니다.

전통적인 라우터에서는 다음과 같은 역할을 합니다:
- 라우팅 프로토콜 실행 (예: OSPF, BGP)
- 라우팅 테이블 및 링크 상태 정보 유지
- 전달 테이블 계산 및 관리

SDN 기반 라우터의 경우,  
라우팅 프로세서는 **중앙 컨트롤러**와 통신하여  
컨트롤러로부터 전달 테이블 정보를 받아와  
입력 포트에 설치합니다.

또한 라우팅 프로세서는 네트워크 관리 기능도 수행합니다.  
(이는 5.7절에서 더 자세히 다룸)

## 하드웨어 기반 구현

입력 포트, 출력 포트, 스위칭 패브릭은 대부분 하드웨어로 구현됩니다.  
이는 매우 빠른 처리 속도를 요구하기 때문입니다.

예를 들어,  
100Gbps 입력 링크와 64바이트 IP 데이터그램이 있다고 가정하면,  
입력 포트는 **5.12ns** 안에 다음 패킷을 처리해야 합니다.  
따라서 여러 포트를 가진 라우터의 경우,  
하드웨어 병렬 처리가 필수적입니다.

데이터 평면은 나노초 단위로 동작하는 반면,  
제어 평면은 밀리초~초 단위로 동작합니다.  
이 때문에 제어 평면은 일반적으로 소프트웨어로 구현되며,  
전통적인 CPU에서 실행됩니다.

## 포워딩의 실제 구현

포워딩 하드웨어는 두 가지 방식으로 구현될 수 있습니다:
- 라우터 제조사의 독자적인 칩 설계
- 상용 칩셋(Intel, Broadcom 등) 사용

이러한 하드웨어는 나노초 단위의 빠른 포워딩을 가능하게 합니다.

## 포워딩의 비유 — “라운드어바웃(회전 교차로)”

라우터 내부 동작은 자동차가 **회전 교차로(roundabout)** 를 통과하는 과정과 비슷합니다.

1. **Destination-based forwarding (목적지 기반 전달)**
    - 차량이 진입 지점에서 최종 목적지를 제시합니다.
    - 관리자가 목적지를 조회하여, 해당 목적지로 가는 출구를 안내합니다.  
      → 즉, 패킷의 목적지 주소를 기반으로 전달 포트를 결정하는 방식입니다.

2. **Generalized forwarding (일반화된 전달)**
    - 관리자가 차량의 목적지뿐만 아니라 다른 정보(번호판, 차량 종류, 상태 등)를 참고해  
      어떤 출구로 나가야 하는지를 결정합니다.
    - 예를 들어, 특정 지역 차량은 고속도로 출구로,  
      다른 지역 차량은 일반 도로 출구로 보낼 수 있습니다.
    - 차량의 상태에 따라 진입 자체를 제한할 수도 있습니다.  
      → 즉, 패킷의 다양한 헤더 필드(출발지, 프로토콜, QoS 등)를  
      고려하여 포워딩 결정을 내리는 방식입니다.

## 교통 흐름 비유에서의 병목 구간

이 비유를 통해 라우터의 병목 구간을 생각해볼 수 있습니다.

- 진입로(입력 포트)는 빠른데, 안내원이 느리면 병목이 발생합니다.
- 빠른 안내원이 있더라도,  
  차량(패킷)이 교차로를 느리게 통과하면 지연이 생길 수 있습니다.
- 모든 차량이 같은 출구를 사용하려고 하면,  
  출구(출력 포트)에서 정체가 생길 수 있습니다.

이러한 문제는 실제 라우터 설계에서도 동일하게 발생합니다.  
따라서 설계자는 우선순위 제어, 혼잡 관리, 접근 제어 등의 기능을 함께 고려해야 합니다.

## 4.2.1 입력 포트 처리와 목적지 기반 포워딩

<img width="559" height="213" alt="Image" src="https://github.com/user-attachments/assets/33c9c229-195c-4973-b367-4e409ae6a63c" />

(**Input Port Processing and Destination-Based Forwarding**)

입력 포트의 세부 동작은 그림 4.5에 나와 있습니다.  
입력 포트는 다음과 같은 단계로 구성됩니다.

1. **라인 종단(Line termination)** — 물리 계층 신호를 수신하고 디지털화
2. **데이터 링크 처리(Data link processing)** — 프레임의 프로토콜 처리 및 캡슐화/비캡슐화
3. **조회 및 포워딩(Lookup and forwarding)** — 패킷의 목적지 주소를 기반으로 전달 포트를 결정

이 마지막 단계가 라우터의 핵심입니다.  
입력 포트는 **포워딩 테이블(Forwarding Table)** 을 조회하여  
도착한 패킷이 어떤 출력 포트로 전송되어야 하는지 결정합니다.

### 포워딩 테이블의 역할

포워딩 테이블은 다음 두 가지 방식으로 구성됩니다:
- **라우팅 프로세서(Routing Processor)** 에 의해 계산 및 갱신  
  (라우팅 프로토콜을 통해 다른 라우터와 정보 교환)
- **SDN 컨트롤러** 로부터 수신

라우팅 프로세서에서 계산된 테이블은 각 **라인 카드(Line Card)** 로 복사됩니다.  
이렇게 하면 각 입력 포트가 독립적으로 포워딩 결정을 내릴 수 있으며,  
중앙 프로세서의 병목 현상을 피할 수 있습니다.

### 단순한 경우: 목적지 기반 포워딩

가장 단순한 형태의 포워딩은 **목적지 IP 주소**를 기준으로 출력 포트를 선택하는 것입니다.  
그러나 IPv4의 32비트 주소 공간에는 40억 개가 넘는 주소가 존재하므로,  
모든 주소를 테이블에 직접 저장하는 방식은 비현실적입니다.

### 예시

라우터가 4개의 링크(0~3번)를 가지고 있다고 가정합시다.  
패킷의 목적지 주소 범위에 따라 다음과 같이 포워딩할 수 있습니다:

| 목적지 주소 범위 (Destination Address Range) | 링크 인터페이스 |
|-----------------------------------------------|----------------|
| 11001000 00010111 00010000 00000000 ~ 11001000 00010111 00010111 11111111 | 0 |
| 11001000 00010111 00011000 00000000 ~ 11001000 00010111 00011000 11111111 | 1 |
| 11001000 00010111 00011001 00000000 ~ 11001000 00010111 00011111 11111111 | 2 |
| 기타 주소(Otherwise) | 3 |

이 경우 40억 개의 항목 대신 4개의 범위만으로도 충분합니다.

### 프리픽스 매칭(Prefix Matching)

라우터는 **프리픽스(prefix)** — 즉, 주소의 앞부분 — 을 기준으로 테이블 항목을 매칭합니다.  
패킷의 주소가 테이블에 있는 프리픽스와 일치하면, 해당 링크 인터페이스로 전송됩니다.

| Prefix | Link Interface |
|---------|----------------|
| 11001000 00010111 00010 | 0 |
| 11001000 00010111 00011000 | 1 |
| 11001000 00010111 00011 | 2 |
| Otherwise | 3 |

예를 들어,  
패킷 주소가 `11001000 00010111 00010110 10100001` 이라면,  
이 주소의 앞 21비트가 첫 번째 엔트리와 일치하므로 **링크 0** 으로 전달됩니다.

### 가장 긴 프리픽스 매칭 (Longest Prefix Matching Rule)

하나의 주소가 여러 프리픽스와 일치할 수도 있습니다.  
이 경우 라우터는 **가장 긴 프리픽스** (가장 구체적인 주소 범위)를 선택합니다.  
즉, 테이블에서 **longest match rule** 을 적용합니다.

### 빠른 조회(High-Speed Lookup)

포워딩 테이블 조회는 단순히 선형 탐색으로는 불가능합니다.  
기가비트 속도의 링크에서는 나노초 단위로 검색이 수행되어야 하기 때문입니다.

이를 위해 하드웨어 수준에서 다음 기술이 사용됩니다:
- **TCAM (Ternary Content Addressable Memory)**:  
  IP 주소를 입력하면 즉시 일치 항목의 값을 반환 (상수 시간)
- **고속 메모리(SRAM, DRAM)**:  
  임베디드 캐시 구조를 사용해 접근 속도 향상

### 입력 포트 처리의 마지막 단계

패킷이 전송될 출력 포트를 찾으면,  
패킷은 **스위칭 패브릭(Switching Fabric)** 으로 전달됩니다.

일부 설계에서는 패킷이 일시적으로 대기 큐(Queue)에 저장됩니다.  
이는 다른 포트에서 전송 중인 패킷이 있을 경우 충돌을 방지하기 위함입니다.

### “Match + Action” 개념

입력 포트 처리는 단순히 “주소를 조회(match)”하고 “전달(action)”하는 과정입니다.  
이는 오늘날 모든 네트워크 장비(라우터, 스위치, 방화벽 등)의 기본 개념인  
**Match + Action 모델** 로 확장됩니다.

예시:
- **스위치**: MAC 주소를 기반으로 포트 선택
- **방화벽**: 특정 출발지/목적지 조합을 필터링 (차단 action)
- **NAT**: 포트 번호 변환 후 전달

이 모델은 현대 네트워크의 핵심이며,  
4.4절에서 다룰 **Generalized Forwarding(일반화된 포워딩)** 의 기반이 됩니다.

## 4.2.2 스위칭 (Switching)

<img width="646" height="483" alt="Image" src="https://github.com/user-attachments/assets/0d0a8e4a-abb3-4ba7-8bee-07282e22410d" />

스위칭 패브릭은 라우터의 **심장부**입니다.  
여기서 실제로 패킷이 입력 포트에서 출력 포트로 전달됩니다.  
스위칭 방식은 여러 가지가 있으며, 그림 4.6에 세 가지가 나타나 있습니다.

### 메모리 기반 스위칭 (Switching via Memory)

가장 초기의 라우터들은 CPU가 모든 스위칭을 제어했습니다.  
입력 포트로 들어온 패킷은 **라우팅 프로세서 메모리**로 복사되고,  
헤더의 목적지 주소를 확인한 후  
해당 출력 포트의 버퍼로 다시 복사되었습니다.

- CPU가 직접 제어하는 구조 → **B/2의 대역폭 제한**
- 두 개의 패킷을 동시에 전송할 수 없음 (공유 메모리 충돌)

현대의 일부 라우터는 여전히 이 방식을 개선한 형태를 사용합니다.  

### 버스 기반 스위칭 (Switching via a Bus)

이 방식에서는 입력 포트가 패킷을 버스를 통해 직접 출력 포트로 전송합니다.  
패킷에는 스위치 내부에서만 사용되는 **레이블(label)** 이 붙습니다.  
모든 출력 포트는 패킷을 수신하지만,  
해당 레이블과 일치하는 포트만 패킷을 수락합니다.

- 한 번에 하나의 패킷만 버스를 통과할 수 있음 → **속도 제한 존재**
- 단순 구조, 중소 규모 네트워크에 적합  

### 교차 연결망 기반 스위칭 (Switching via an Interconnection Network)

단일 버스의 대역폭 한계를 극복하기 위해  
**Crossbar Switch (교차 스위치)** 를 사용합니다.

- N개의 입력 포트와 N개의 출력 포트를 2N개의 버스로 연결
- 각 교차점(crosspoint)은 스위치 컨트롤러가 열거나 닫을 수 있음
- 여러 입력-출력 연결을 **병렬로 처리 가능** (non-blocking 구조)

### 고급 스위칭 구조

더 발전된 라우터는 **다단계(interconnection stages)** 또는  
**병렬 스위칭 패브릭(multi-fabric parallelism)** 을 사용합니다.

- 예: Cisco CRS — 3단계 비차단 스위칭 구조
- 입력 포트는 패킷을 여러 조각(K chunks)으로 나누어  
  여러 스위칭 패브릭에 동시에 전송
- 출력 포트에서 다시 원래 패킷으로 재조립

이 방식은 고속·대용량 라우터의 확장성과 안정성을 높이는 핵심 기술입니다.

### 큐잉의 수학적 모델

모든 입력·출력 포트의 전송 속도가 동일하다고 가정합시다.
- 각 링크의 속도: `R_line (packets/sec)`
- 스위칭 패브릭의 속도: `R_switch (packets/sec)`
- 포트 개수: `N`

만약 `R_switch = N × R_line`이라면,  
입력 포트에 거의 큐잉이 발생하지 않습니다.  
하지만 스위칭 속도가 충분히 빠르지 않다면 큐잉이 생깁니다.

<img width="580" height="194" alt="Image" src="https://github.com/user-attachments/assets/4a454bf7-0f66-4230-bfe0-b41133434aef" />

## 입력 큐잉 (Input Queueing)

<img width="516" height="528" alt="Image" src="https://github.com/user-attachments/assets/c594c5c0-208f-476e-af5d-ed52b46c30b2" />

스위칭 패브릭이 충분히 빠르지 않으면,  
입력 포트에서 패킷들이 대기열에 쌓입니다.  
이때 심각한 현상 중 하나가 **HOL 블로킹 (Head-of-Line Blocking)** 입니다.

### HOL Blocking (라인 헤드 차단)

- 입력 큐의 맨 앞에 있는 패킷이 특정 출력 포트를 기다리고 있는데,  
  그 포트가 이미 다른 패킷으로 바쁘다면,  
  그 뒤의 모든 패킷도 대기해야 함.
- 즉, 출력 포트가 비어 있어도 **앞의 패킷 때문에 뒤의 패킷이 지연**됨.
- 연구 결과(H. Karol, 1987):  
  HOL 블로킹으로 인해 입력 큐의 평균 활용률은 약 **58%** 로 제한됨.

> 쉽게 말해, 교차로에서 맨 앞 차가 고장 나면  
> 그 뒤의 차들도 모두 멈추는 것과 같은 현상입니다.

## 출력 큐잉 (Output Queueing)

이번에는 **출력 포트에서의 큐잉**을 살펴봅시다.

`R_switch`가 `N × R_line`보다 빠르더라도,  
모든 입력 포트에서 동일한 출력 포트로 패킷이 도착한다면  
출력 포트에서는 큐가 쌓이게 됩니다.

- 출력 포트는 한 번에 하나의 패킷만 전송 가능
- `N`개의 입력 포트에서 동시에 도착하면,  
  한 패킷을 전송하는 동안 **N개의 새로운 패킷이 도착**
- 따라서 큐는 빠르게 증가하고,  
  메모리가 부족하면 **패킷 손실**이 발생합니다.

<img width="521" height="428" alt="Image" src="https://github.com/user-attachments/assets/daa38bb6-ffe8-4a21-a740-48b7b20ea080" />

## 큐 관리 및 패킷 드롭 정책

출력 포트의 메모리가 부족하면 라우터는 결정을 내려야 합니다.

1. **Drop-tail** — 새로 도착한 패킷을 즉시 버림
2. **Active Queue Management (AQM)** —  
   버퍼가 가득 차기 전에 미리 일부 패킷을 버리거나 표시하여  
   송신자에게 혼잡 신호를 보냄

### AQM 기법의 예시

- **RED (Random Early Detection)**  
  버퍼가 일정 수준 이상 차면 일부 패킷을 확률적으로 드롭

- **PIE (Proportional Integral controller Enhanced)**  
  혼잡 정도를 기반으로 버퍼 크기를 동적으로 조절

- **CoDel (Controlled Delay)**  
  지연(latency)을 기준으로 큐 길이를 자동 관리

이러한 기법들은 TCP 송신자에게 **혼잡 신호**를 보내어  
네트워크의 안정성을 유지합니다.

## 4.2.5 버퍼 크기는 얼마나 커야 하는가? (How Much Buffering Is Enough?)

버퍼가 너무 작으면 패킷 손실이 잦아지고,  
너무 크면 지연이 길어집니다.  
그렇다면 “적정 버퍼 크기”는 얼마일까요?

### 버퍼의 양면성

- 버퍼가 크면: 손실률 감소하지만 지연 증가
- 버퍼가 작으면: 손실 증가하지만 지연 감소

> 버퍼는 “소금”과 같다 —  
> 너무 적으면 싱겁고, 너무 많으면 먹을 수 없다.

특히 실시간 통신(게임, 화상회의 등)은  
수십 밀리초의 지연에도 큰 영향을 받습니다.

## 4.2.6 버퍼블로트 (Bufferbloat)

버퍼가 너무 커서 생기는 **지속적인 지연(persistent delay)** 현상을  
**Bufferbloat**이라고 합니다.

<img width="651" height="316" alt="Image" src="https://github.com/user-attachments/assets/3e7cf1ce-0caf-4c0e-b00f-dfe8e12b9b72" />

이때 TCP의 ACK이 돌아올 때마다 새로운 패킷이 추가되어  
큐의 길이가 줄지 않고 지속됩니다.  
결과적으로 지연은 계속 누적되고,  
사용자는 “렉이 걸린다”고 느끼게 됩니다.

### Bufferbloat의 의미

- 단순히 “속도가 느리다”가 아니라  
  **지연(latency)** 이 과도하게 길어지는 현상
- 네트워크가 “항상 꽉 찬” 상태로 동작
- TCP의 혼잡 제어와 AQM 정책이 함께 작동해야 해결 가능

> 최신 케이블 네트워크 표준 (DOCSIS 3.1)에서는  
> RFC 8033, 8034 기반의 AQM 메커니즘을 추가하여  
> Bufferbloat을 완화하고 있습니다.

## 4.2.5 패킷 스케줄링 (Packet Scheduling)

이번에는 **출력 링크를 통해 전송될 패킷의 순서를 어떻게 결정할 것인가**에 대해 살펴봅니다.  
이 문제는 “줄 서서 기다리는 고객을 어떤 순서로 서비스할 것인가”와 유사합니다.  
라우터에서도 이와 같은 “대기열 관리(Queueing Discipline)”가 적용됩니다.

대표적인 스케줄링 방식은 다음과 같습니다:
1. **FCFS (First-Come-First-Served)** — 즉, **FIFO (First-In-First-Out)**
2. **Priority Queueing (우선순위 큐)**
3. **Round Robin (라운드 로빈)**
4. **Weighted Fair Queueing (WFQ, 가중 공정 큐잉)**

### FIFO (First-In-First-Out)

FIFO는 **도착한 순서대로 처리**하는 가장 단순한 방식입니다.  

- 패킷이 도착하면, 출력 링크가 사용 중일 경우 **큐에 저장**됩니다.
- 버퍼가 가득 차면, 패킷 드롭 정책에 따라 도착한 패킷이 버려지거나  
  기존 패킷이 제거되어 공간을 만듭니다.
- 전송이 완료되면 큐에서 제거됩니다.

#### 예시

패킷 1~4가 순서대로 도착했고, 각 패킷의 전송에는 3단위 시간이 걸린다고 가정합시다.  
→ 패킷들은 도착한 순서대로 (1, 2, 3, 4) 전송되고,  
패킷 4 이후 큐가 비어 링크는 **유휴(idle)** 상태가 됩니다.

> FIFO는 단순하지만, 긴 지연과 공정성 문제를 일으킬 수 있습니다.

### Priority Queueing (우선순위 큐잉)

우선순위 큐잉에서는 패킷이 도착할 때  
**우선순위 클래스(priority class)** 에 따라 분류됩니다.  
즉, 라우터는 각 클래스별로 별도의 큐를 운영합니다.

- **네트워크 관리 트래픽** → 사용자 트래픽보다 우선 전송
- **실시간 음성(VoIP)** → 이메일보다 높은 우선순위

#### 동작 방식

- 항상 **가장 높은 우선순위 큐**에 있는 패킷이 먼저 전송됩니다.
- 같은 우선순위 내에서는 FIFO 순서로 처리됩니다.

#### 예시

- 패킷 1, 3, 4 → 고우선순위
- 패킷 2, 5 → 저우선순위

1. 패킷 1이 먼저 전송됨 (링크가 비어 있음).
2. 그 사이 패킷 2, 3이 도착 → 각각 저/고 우선순위 큐에 저장.
3. 패킷 1 전송 후 → **패킷 3(고우선순위)** 가 선택되어 전송.
4. 패킷 2는 나중으로 밀림.
5. 패킷 4가 도착했을 때 패킷 2가 전송 중이라면,  
   **non-preemptive (비선점형)** 방식에서는 패킷 2가 끝날 때까지 대기.

 즉, 높은 우선순위 패킷이라도 이미 전송 중인 패킷을 중단시킬 수 없습니다.

### Round Robin (라운드 로빈 큐잉)

라운드 로빈 큐잉은 **클래스 간에 순차적으로 서비스를 번갈아 가며 제공**합니다.  
우선순위 큐잉처럼 한 클래스만 계속 서비스하지 않고,  
클래스 1 → 클래스 2 → 클래스 1 → 클래스 2 → … 순으로 돌아갑니다.

이 방식은 **work-conserving discipline** 입니다.  
즉, 전송할 패킷이 있는 한 링크는 절대 유휴 상태로 두지 않습니다.

#### 예시

- 클래스 1: 패킷 1, 2, 4
- 클래스 2: 패킷 3, 5

1. 패킷 1 (클래스 1) 전송
2. 패킷 3 (클래스 2) 전송
3. 다시 패킷 2 (클래스 1) 전송
4. 패킷 4 (클래스 1) 남은 경우 즉시 전송

> 이 방식은 모든 클래스가 **공정하게 대역폭을 공유**할 수 있도록 설계되었습니다.

### WFQ (Weighted Fair Queueing, 가중 공정 큐잉)

WFQ는 라운드 로빈을 확장한 형태로,  
각 클래스에 **가중치(weight)** 를 부여하여  
더 많은 비율의 서비스를 받을 수 있도록 조정합니다.

#### 개념

각 클래스 *i*에 가중치 *w₁, w₂, … wₙ* 을 할당하고,  
링크의 전체 전송률이 *R*일 때,  
클래스 *i*는 최소한 다음 비율의 대역폭을 보장받습니다.

즉, 가중치가 높을수록 더 많은 전송량을 확보할 수 있습니다.

#### 특징

- 모든 클래스가 패킷을 가지고 있는 동안,  
  각 클래스는 자신의 가중치에 비례한 비율로 서비스 받음.
- 패킷이 없는 클래스는 **즉시 다음 클래스**로 서비스가 넘어감.
- 실시간 트래픽(예: 음성)에는 높은 가중치,  
  비실시간 트래픽(예: 이메일)에는 낮은 가중치를 줄 수 있음.

### 요약

| 방식 | 특징 | 장점 | 단점 |
|------|------|------|------|
| FIFO | 도착 순서대로 전송 | 단순함 | 지연, 공정성 문제 |
| Priority Queueing | 우선순위별 분리 | 실시간 트래픽에 유리 | 낮은 우선순위는 지연 |
| Round Robin | 클래스별 순환 서비스 | 공정성 확보 | 클래스 내 지연 발생 가능 |
| WFQ | 가중치 기반 공정 서비스 | 서비스 품질(QoS) 보장 | 구현 복잡 |

> WFQ는 오늘날 대부분의 **QoS 기반 네트워크(예: MPLS, SDN, VoIP)** 에서 사용되는 핵심 알고리즘입니다.
