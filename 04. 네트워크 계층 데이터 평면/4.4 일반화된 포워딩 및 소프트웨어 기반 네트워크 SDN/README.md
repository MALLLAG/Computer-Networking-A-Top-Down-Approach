# 4.4 일반화된 포워딩 및 소프트웨어 기반 네트워크 SDN

## 일반화된 포워딩 (Generalized Forwarding)

기존의 **목적지 기반 포워딩(destination-based forwarding)** 은 다음 두 단계로 이루어진다:
1. **Match:** 패킷의 목적지 IP 주소를 조회.
2. **Action:** 해당 목적지로 패킷을 전달.

하지만 현대 네트워크에서는 이보다 훨씬 일반화된 개념이 필요하다.  
**Match + Action** 패러다임은 다양한 계층의 헤더 필드를 기준으로 패킷을 매칭하고,  
그 결과에 따라 여러 형태의 동작을 수행한다.

### Match (매칭)
- 단순히 IP 주소뿐 아니라,  
  TCP/UDP 포트, MAC 주소, VLAN ID, 프로토콜 타입 등 **여러 계층의 필드**로 매칭 가능.

### Action (동작)
- 패킷을 하나 또는 여러 출력 포트로 전달 (라우팅, 스위칭)
- NAT처럼 헤더 값을 재작성 (IP 변환 등)
- 방화벽처럼 특정 트래픽 차단 또는 드롭
- DPI(Deep Packet Inspection)처럼 패킷을 특정 서버로 전달하여 추가 분석 수행
- 부하 분산(load balancing) 수행

이처럼 **일반화된 포워딩**은 단순 라우터나 스위치 기능을 넘어서는 **"패킷 스위치(packet switch)"** 모델로 확장된다.

## SDN과 Match-Action 구조

일반화된 포워딩을 실제로 구현하는 대표적인 방식이 **SDN (Software-Defined Networking)** 이다.  
SDN은 **제어(Control)** 와 **데이터(Data)** 평면을 분리하여,  
제어 로직을 중앙의 **컨트롤러(controller)** 가 수행하고  
실제 패킷 처리는 **스위치(switch)** 가 담당한다.

### 핵심 개념: Match-Plus-Action Table
- 각 SDN 스위치는 “**Match + Action**” 구조의 테이블을 유지.
- 이 테이블은 **원격 컨트롤러**에서 계산되어 스위치로 설치 및 업데이트됨.
- OpenFlow 프로토콜이 이 구조의 대표적인 표준.

## OpenFlow 기반의 플로우 테이블 (Flow Table)

OpenFlow에서 각 스위치는 **Flow Table** 이라 불리는 match-plus-action 테이블을 가짐.  
각 항목(entry)은 다음 세 가지 구성 요소를 포함한다:

1. **Set of Header Field Values (매칭 필드 집합)**
    - 어떤 패킷 헤더 값과 매칭할지를 정의.
    - 예: IP 주소, 포트 번호, MAC 주소, VLAN ID 등.
    - 매칭은 **TCAM (Ternary Content Addressable Memory)** 을 사용하여 매우 빠르게 수행됨.
    - 매칭되지 않는 패킷은 드롭되거나 컨트롤러로 전송되어 추가 처리됨.

2. **Set of Counters (카운터 집합)**
    - 각 엔트리별로 통계 정보 유지.
    - 예: 매칭된 패킷 수, 최근 매칭 시각 등.

3. **Set of Actions (액션 집합)**
    - 매칭된 패킷에 대해 수행할 동작을 정의.
    - 예: 특정 포트로 전송, 드롭, 복사하여 다중 포트로 전송, 헤더 재작성 등.

## 4.4.1 Match

**Match** 단계는 스위치가 패킷의 특정 헤더 필드를 기준으로 엔트리를 찾아내는 과정이다.  
OpenFlow 1.0에서는 총 **11개의 헤더 필드 + 입력 포트 ID** 가 매칭 대상이 된다.

### 매칭 가능한 주요 필드
- **Layer 2:**
    - Source MAC address
    - Destination MAC address
    - Ethernet Type
    - VLAN ID
- **Layer 3:**
    - Source IP address
    - Destination IP address
    - IP Protocol (예: TCP, UDP, ICMP 등)
    - Type of Service (TOS)
- **Layer 4:**
    - Source Port
    - Destination Port
- **Ingress Port:**
    - 패킷이 들어온 스위치 포트 번호

### 예시: 와일드카드 매칭
- IP 주소 `128.119.*.*` : 주소의 상위 16비트(128.119)까지만 비교.  
  → 하위 비트는 무시하고 범위 기반 매칭 가능.

### 우선순위 (Priority)
- 하나의 패킷이 여러 엔트리에 매칭될 경우,  
  **가장 높은 우선순위(priority)** 를 가진 엔트리의 액션이 적용된다.

## 매칭 제약과 추상화의 균형

모든 필드가 매칭 가능한 것은 아니다.  
예를 들어, OpenFlow는 다음 필드에 대해서는 매칭을 지원하지 않는다:
- TTL(Time-To-Live)
- Datagram Length

이유는 **기능성과 단순성의 균형** 때문이다.  
매칭 가능한 필드를 너무 늘리면 시스템 복잡도가 급격히 증가한다.

따라서 OpenFlow 설계자는 “충분히 강력하지만 과도하게 복잡하지 않은”  
**최소한의 추상화(minimal abstraction)** 를 유지하는 것을 목표로 했다.

## OpenFlow의 설계 철학과 확장

OpenFlow의 설계 철학:
- 최소한의 핵심 기능만 정의하여 단순성을 유지.
- 각 스위치는 **하나의 플로우 테이블**을 유지하지만,  
  실제 구현에서는 여러 테이블을 병렬 사용하기도 함.
- 이후 버전(OpenFlow 1.3, 1.5 등)에서는  
  필드 수를 12개에서 41개로 확장하여 더 유연한 매칭 가능.

## 7. SDN의 의미

OpenFlow를 중심으로 한 SDN은 기존 네트워크 장비의 역할을 혁신했다.

| 구분 | 전통적 네트워크 | SDN 기반 네트워크 |
|------|------------------|--------------------|
| 제어(Control) | 각 라우터/스위치 내에 존재 | 중앙 컨트롤러에 통합 |
| 데이터 처리(Data) | 각 장비에서 독립 수행 | 컨트롤러의 지시에 따라 수행 |
| 구성 관리 | 수동 설정 (CLI 등) | 프로그래밍 방식 (API 기반) |
| 확장성 | 낮음 | 높음 |
| 유연성 | 제한적 | 동적 정책 반영 가능 |

결국 SDN은 네트워크를 **“프로그래밍 가능한 시스템”** 으로 전환시켰으며,  
라우팅, 방화벽, 부하분산, QoS 등 다양한 기능을 하나의 통합된 구조로 제어할 수 있게 만들었다.


## 4.4.2 Action

각 Flow Table Entry에는 하나 이상의 **Action(동작)** 이 정의되어 있으며,  
매칭된 패킷에 대해 어떤 처리를 수행할지를 결정한다.  
하나의 엔트리에 여러 액션이 지정될 경우, **리스트 순서대로 순차 실행된다.**

### 주요 액션 유형

1. **Forwarding (전달)**
    - 패킷을 특정 **출력 포트(output port)** 로 전달.
    - 특정 포트를 제외한 **모든 포트로 브로드캐스트** 가능.
    - **멀티캐스트**를 위해 선택된 포트 집합으로 복사 전송 가능.
    - 패킷을 **컨트롤러로 캡슐화(encapsulation)** 하여 전달할 수도 있음.
    - 컨트롤러는 새로운 플로우 규칙을 설치한 뒤, 수정된 패킷을 다시 스위치로 반환 가능.

2. **Dropping (폐기)**
    - 아무 동작도 정의되지 않은 엔트리는 해당 패킷을 드롭(drop) 처리.

3. **Modify-field (필드 수정)**
    - 패킷의 헤더 필드(총 10개, L2~L4 계층의 필드들)를 변경할 수 있음.
    - 예: MAC 주소 변경, IP 주소 변경, TCP/UDP 포트 변경 등.
    - 단, IP Protocol 필드는 수정 불가.

## 4.4.3 OpenFlow Examples of Match-plus-action in Action

이제 Match와 Action의 개념을 결합하여 실제 네트워크 동작 예시를 살펴본다.  
아래의 네트워크는 6개의 호스트(`h1`~`h6`)와 3개의 스위치(`s1`, `s2`, `s3`)로 구성되어 있으며,  
각 스위치는 4개의 포트를 가지고 있다.  
각 예시는 **OpenFlow 기반 플로우 테이블**을 통해 구현된다.

### 예시 1: 단순 포워딩 (Simple Forwarding)

**목표:**  
`h5` 또는 `h6` → `h3` 또는 `h4` 로 전송되는 패킷은  
`S3 → S1 → S2` 경로를 따르도록 설정한다.  
즉, `S3`와 `S2` 사이의 링크를 사용하지 않는다.

#### s1의 플로우 테이블

| Match | Action |
|--------|---------|
| Ingress Port = 1 ; IP Src = 10.3.*.* ; IP Dst = 10.2.*.* | Forward(4) |
| ... | ... |

#### s3의 플로우 테이블

| Match | Action |
|--------|---------|
| IP Src = 10.3.*.* ; IP Dst = 10.2.*.* | Forward(3) |
| ... | ... |

#### s2의 플로우 테이블

| Match | Action |
|--------|---------|
| Ingress Port = 2 ; IP Dst = 10.2.0.3 | Forward(3) |
| Ingress Port = 2 ; IP Dst = 10.2.0.4 | Forward(4) |
| ... | ... |

결과적으로 `h5/h6 → s3 → s1 → s2 → h3/h4` 의 경로가 완성된다.

### 예시 2: 부하 분산 (Load Balancing)

**목표:**
- `h3` → `10.1.*.*` 로 가는 트래픽은 `s2 → s1` 경로로 전달.
- `h4` → `10.1.*.*` 로 가는 트래픽은 `s2 → s3 → s1` 경로로 전달.  
  → 즉, 트래픽을 두 경로로 분산시킴.

#### s2의 플로우 테이블 (Example 2)

| Match | Action |
|--------|---------|
| Ingress Port = 3 ; IP Dst = 10.1.*.* | Forward(2) |
| Ingress Port = 4 ; IP Dst = 10.1.*.* | Forward(1) |
| ... | ... |

이 외에도 s1과 s3에는 대응되는 역방향 포워딩 규칙이 필요하다.  
이런 부하 분산 기능은 **전통적인 IP 기반 라우팅으로는 구현 불가**하며,  
SDN의 Match+Action 구조 덕분에 가능하다.

### 예시 3: 방화벽 (Firewalling)

**목표:**  
`s2`는 **오직 s3에 연결된 호스트(h5, h6)** 로부터의 트래픽만 수신해야 한다.  
즉, `10.3.*.*` 출발지 주소의 트래픽만 허용.

#### s2의 플로우 테이블 (Example 3)

| Match | Action |
|--------|---------|
| IP Src = 10.3.*.* ; IP Dst = 10.2.0.3 | Forward(3) |
| IP Src = 10.3.*.* ; IP Dst = 10.2.0.4 | Forward(4) |
| ... | ... |

이 규칙만 있을 경우, `10.3.*.*` 이 아닌 트래픽은 모두 차단된다.  
즉, `s2`는 방화벽처럼 동작하며, 허용된 트래픽만 내부 호스트로 전달한다.

### 일반화된 포워딩의 확장성

위 세 가지 예시에서 보듯이, **Match+Action 구조는**  
전통적인 IP 포워딩보다 훨씬 다양한 네트워크 동작을 구현할 수 있다.

활용 예:
- **가상 네트워크(Virtual Networks)**  
  동일한 물리적 인프라에서 서로 다른 논리 네트워크 생성 가능.
- **방화벽, 로드밸런서, NAT, DPI** 등  
  다양한 네트워크 서비스 기능을 동일한 스위치 구조 내에서 구현 가능.

### 프로그래머빌리티 (Programmability)와 P4 언어

OpenFlow의 플로우 테이블은 사실상 제한된 수준의 **프로그래밍 언어**로 볼 수 있다.  
즉, "패킷 헤더 값에 따라 어떤 동작을 수행할지" 를 정의하는 일종의 프로그램이다.

하지만 OpenFlow는 단순히 매칭 및 필드 수정 수준에 머물기 때문에,  
더 복잡한 처리를 위해서는 고급 언어적 기능이 필요하다.

이를 해결하기 위해 등장한 것이 **P4 (Programming Protocol-independent Packet Processors)** 이다.

- P4는 데이터그램 처리용 **프로토콜 독립적 네트워크 프로그래밍 언어.**
- 고수준 언어 구문(변수, 조건문, 연산 등)을 제공하여  
  스위치 동작을 완전한 형태로 프로그래밍 가능.
- 현재 다양한 SDN 스위치 및 네트워크 장비에서 활발히 사용되고 있다.

> P4는 “패킷 처리를 코드로 정의하는 언어”로,  
> 네트워크 장비의 동작을 완전히 소프트웨어적으로 제어할 수 있게 만든다.





