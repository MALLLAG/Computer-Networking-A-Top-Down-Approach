## 5.2 라우팅 알고리즘 (Routing Algorithms)

이 절에서는 송신자에서 수신자로 데이터를 전달하기 위한 **좋은 경로(good path)**, 즉 **라우팅 경로**를 결정하는 **라우팅 알고리즘(routing algorithms)**에 대해 다룹니다.  
일반적으로 “좋은” 경로란 **비용(cost)** 이 가장 낮은 경로를 의미합니다.  
그러나 실제 네트워크 환경에서는 정책적인 요소나 관리상의 제약(예: “라우터 X는 조직 Y에 속하므로, 조직 Z의 네트워크에서 온 패킷을 전달하지 않는다”) 등이 함께 고려됩니다.

라우팅 제어 평면이 **개별 라우터 제어(per-router control)** 방식을 사용하든  
**논리적 중앙 제어(logically centralized control)** 방식을 사용하든,  
결국 송신 호스트에서 수신 호스트로 이동하는 동안 패킷이 거치는 **라우터들의 순서가 명확히 정의되어야** 합니다.  
따라서 이러한 경로를 계산하는 라우팅 알고리즘은 네트워킹의 핵심 개념 중 하나입니다.

### 그래프를 이용한 라우팅 문제의 모델링

라우팅 문제는 일반적으로 **그래프(graph)** 를 사용해 모델링합니다.  
그래프 \( G = (N, E) \)는 노드 집합 \( N \)과, 각 노드 쌍을 연결하는 간선 집합 \( E \)로 구성됩니다.

- 네트워크 라우팅에서 **노드(node)** 는 라우터를 의미하며,  
  **간선(edge)** 은 두 라우터를 연결하는 실제 링크(물리적 연결)를 의미합니다.
- 각 간선은 **비용(cost)** 값을 가지며, 이는 링크의 길이, 속도, 혹은 경제적 비용 등을 반영할 수 있습니다.  
  예를 들어, 해저 케이블과 같은 장거리 링크는 단거리 링크보다 비용이 높을 수 있습니다.
- 간선의 비용은 \( c(x, y) \)로 표시하며, 만약 두 노드 사이에 간선이 존재하지 않으면 \( c(x, y) = ∞ \)로 둡니다.

<img width="473" height="286" alt="Image" src="https://github.com/user-attachments/assets/1e01a466-660f-484d-8a30-472859ac14b5" />

라우팅 알고리즘의 주요 목표는 이러한 그래프 상에서 **두 노드 간 최소 비용 경로(least-cost path)** 를 찾는 것입니다.

### 최소 비용 경로 (Least-Cost Path)

두 노드 \( x \)와 \( y \) 사이에는 여러 가능한 경로가 존재하며,  
각 경로의 총 비용은 경로를 따라 있는 모든 링크의 비용의 합으로 계산됩니다.

경로 \( p = (x_1, x_2, ..., x_p) \)의 비용은 다음과 같이 표현됩니다.

\[
c(x_1, x_2) + c(x_2, x_3) + \cdots + c(x_{p-1}, x_p)
\]

예를 들어 그림 5.3에서,  
노드 \( u \)에서 \( z \)로 가는 최소 비용 경로는 \( u - x - y - w \)이며, 총 비용은 3입니다.  
모든 간선의 비용이 동일하다면 최소 비용 경로는 **최단 경로(shortest path)** 와 동일합니다.

### 라우팅 알고리즘의 분류

라우팅 알고리즘은 여러 기준으로 분류할 수 있습니다.

#### 중앙집중형 vs 분산형

- **중앙집중형 라우팅 알고리즘 (Centralized Routing Algorithm)**  
  네트워크의 모든 노드 연결 정보와 링크 비용 정보를 알고 있는 단일 위치(또는 컨트롤러)에서 전체 계산을 수행합니다.  
  예: 논리적 중앙 제어 방식(Figure 5.2).  
  이런 알고리즘은 전체 네트워크의 전역 정보를 사용하므로 **링크 상태(Link-State, LS) 알고리즘**이라고 부릅니다.

- **분산형 라우팅 알고리즘 (Decentralized Routing Algorithm)**  
  각 라우터가 자신과 직접 연결된 링크의 정보만 알고 있으며,  
  인접한 라우터들과 반복적으로 정보를 교환하면서 최소 비용 경로를 점진적으로 계산합니다.  
  이런 알고리즘의 대표적인 예는 **거리 벡터(Distance-Vector, DV) 알고리즘**입니다.  
  각 노드는 모든 목적지까지의 추정 비용을 담은 벡터를 유지합니다.

#### 정적 vs 동적

- **정적 라우팅 알고리즘 (Static Routing Algorithm)**  
  경로가 시간에 따라 거의 변하지 않으며, 주로 사람이 수동으로 설정합니다.  
  (예: 관리자가 라우팅 테이블을 직접 수정)

- **동적 라우팅 알고리즘 (Dynamic Routing Algorithm)**  
  네트워크의 트래픽 부하나 토폴로지 변화에 따라 자동으로 경로를 조정합니다.  
  주기적으로 실행되거나, 변화가 발생할 때 즉시 반응할 수도 있습니다.  
  단, 변화에 민감한 만큼 **라우팅 루프**나 **경로 진동(route oscillation)**과 같은 문제가 발생할 수 있습니다.

#### 부하 감지 여부 (Load Sensitivity)

- **부하 민감형 라우팅 알고리즘 (Load-Sensitive Algorithm)**  
  링크의 혼잡도(congestion)에 따라 링크 비용이 동적으로 변경됩니다.  
  예를 들어, 혼잡한 링크의 비용이 높게 설정되어 우회 경로를 선택하도록 유도합니다.  
  초창기 ARPAnet 알고리즘은 이러한 방식을 사용했습니다.

- **부하 비민감형 라우팅 알고리즘 (Load-Insensitive Algorithm)**  
  링크 비용이 혼잡도와 관계없이 일정합니다.  
  오늘날 대부분의 인터넷 라우팅 프로토콜(RIP, OSPF, BGP 등)은 이 방식을 사용합니다.








## 5.2.1 링크 상태(Link-State, LS) 라우팅 알고리즘

**링크 상태 알고리즘(Link-State Algorithm)** 에서는 네트워크의 **토폴로지(topology)** 와 **링크 비용(link cost)** 이 모두 알려져 있다고 가정합니다.  
즉, 각 노드가 네트워크 전체의 정보를 입력으로 사용할 수 있습니다.

실제로는 각 노드가 **링크 상태 패킷(link-state packet)** 을 모든 다른 노드로 **브로드캐스트(broadcast)** 하여 이 정보를 공유합니다.  
이 패킷에는 해당 노드와 그에 직접 연결된 링크의 비용 정보가 포함됩니다.  
이러한 방식은 **링크 상태 브로드캐스트(link-state broadcast)** 알고리즘이라 부르며, 예를 들어 **OSPF(Open Shortest Path First)** 프로토콜이 이 방식을 사용합니다.

결과적으로 네트워크 내 모든 노드는 **동일하고 완전한 네트워크 뷰(view)** 를 가지게 되며,  
각 노드는 이를 바탕으로 LS 알고리즘을 실행해 **동일한 최소 비용 경로(least-cost path)** 집합을 계산할 수 있습니다.

### 다익스트라(Dijkstra) 알고리즘

LS 라우팅 알고리즘의 대표적인 구현은 **다익스트라 알고리즘(Dijkstra’s algorithm)** 입니다.  
이 알고리즘은 한 노드(출발 노드)로부터 네트워크 내 모든 다른 노드까지의 최소 비용 경로를 계산합니다.

다익스트라 알고리즘은 반복적(iterative)으로 동작하며,  
각 반복(iteration)마다 새로운 노드 하나의 최소 비용 경로가 확정됩니다.

#### 주요 기호 정의

- **D(v)**: 출발 노드에서 목적지 노드 v까지의 현재까지 알려진 최소 비용
- **p(v)**: 출발 노드에서 v로 가는 현재 최소 비용 경로 상의 바로 이전 노드
- **N′**: 최소 비용 경로가 확정된 노드들의 집합

### 다익스트라 알고리즘의 절차

**초기화 단계 (Initialization)**
1. N′ = {u}  (출발 노드 u만 포함)
2. 모든 노드 v에 대해,
    - 만약 v가 u의 이웃이면 D(v) = c(u, v)
    - 아니면 D(v) = ∞

**반복 단계 (Loop)**
3. N′에 속하지 않은 노드 중 D(w)가 가장 작은 노드 w를 선택
4. w를 N′에 추가
5. w의 이웃 노드 v(아직 N′에 속하지 않은 노드)에 대해
    - D(v) = min(D(v), D(w) + c(w, v)) 로 업데이트
6. N′ = N이 될 때까지 반복

### 예시

그림 5.3의 네트워크에서 출발 노드를 u로 설정합니다.  
초기 단계에서 u의 이웃 노드들의 최소 비용은 다음과 같습니다.

| 단계 | N′ | D(v), p(v) | D(w), p(w) | D(x), p(x) | D(y), p(y) | D(z), p(z) |
|------|----|-------------|-------------|-------------|-------------|-------------|
| 0 | u | 2, u | 5, u | 1, u | ∞ | ∞ |
| 1 | ux | 2, u | 4, x | 2, x | ∞ | ∞ |
| 2 | uxy | 2, u | 3, y | 2, x | 4, y | ∞ |
| 3 | uxyw | 3, y | 3, y | 2, x | 4, y | ∞ |
| 4 | uxywz | 3, y | 3, y | 2, x | 4, y | 4, y |

<img width="515" height="224" alt="Image" src="https://github.com/user-attachments/assets/3b1fed53-4774-4c1b-b7d2-e2f649c24f71" />

**그림 5.4**는 u에서 각 목적지로의 최소 비용 경로와,  
각 목적지로 향할 때 다음 홉(next hop)을 표시한 **포워딩 테이블**을 보여줍니다.

| 목적지 | 링크 |
|--------|------|
| v | (u, v) |
| w | (u, x) |
| x | (u, x) |
| y | (u, x) |
| z | (u, x) |

### 알고리즘의 복잡도

노드 수를 n이라고 하면,  
각 반복마다 최소 비용 노드를 찾기 위해 최대 n개의 노드를 검사해야 하므로  
**시간 복잡도는 O(n²)** 입니다.  
힙(heap) 자료구조를 사용하면 검색 속도를 로그(log n) 수준으로 줄일 수 있습니다.

### 병목 현상과 진동(Oscillation) 문제

링크 비용이 트래픽 부하에 따라 달라지는 **혼잡 기반(congestion-sensitive)** 환경에서는  
LS 알고리즘이 경로를 반복적으로 변경하며 **진동 현상(route oscillation)** 이 발생할 수 있습니다.

<img width="532" height="570" alt="Image" src="https://github.com/user-attachments/assets/71ceb5d7-320f-4eaa-84b8-9b711f484d0f" />

**그림 5.5**는 이 문제를 예시로 보여줍니다.  
각 노드가 더 나은 경로를 찾을 때마다 트래픽이 이동하여 링크 비용이 변하고,  
결과적으로 경로가 시계 방향과 반시계 방향으로 계속 바뀌는 문제가 생깁니다.

이 문제를 방지하기 위한 해결책으로는 다음이 있습니다.

1. 링크 비용이 트래픽 부하에 의존하지 않도록 고정시킨다.
2. 모든 라우터가 LS 알고리즘을 동시에 실행하지 않도록,  
   실행 시간을 무작위(randomize)로 조정한다.  
   (예: 라우터가 링크 광고(link advertisement)를 보낼 때 시간을 무작위로 설정)









## 5.2.2 거리 벡터(Distance-Vector, DV) 라우팅 알고리즘

링크 상태(LS) 알고리즘이 네트워크의 전역 정보를 사용하는 반면,  
**거리 벡터(Distance-Vector, DV)** 알고리즘은 **반복적(iterative)** 이고, **비동기(asynchronous)** 이며, **분산(distributed)** 된 방식으로 동작합니다.

이 알고리즘에서는 각 노드가 자신의 **직접 연결된 이웃 노드(directly attached neighbors)** 로부터 정보를 받아 계산을 수행한 후,  
그 결과를 다시 이웃에게 전송합니다.  
이 과정은 새로운 정보가 더 이상 교환되지 않을 때까지 반복됩니다.  
(흥미롭게도, 이 알고리즘은 종료 신호가 따로 없는 **self-terminating** 특성을 가집니다.)

### Bellman-Ford 방정식

DV 알고리즘의 핵심은 **Bellman-Ford 식**입니다.  
노드 x에서 y로 가는 최소 비용 경로의 비용을 `dₓ(y)`라 할 때,  
다음 관계식이 성립합니다.

\[
dₓ(y) = \min_v \{ c(x,v) + dᵥ(y) \}
\]

여기서 `min`은 x의 모든 이웃 v에 대해 계산합니다.  
즉, x에서 y로 가기 위해서는 어떤 이웃 v를 거칠 수 있고,  
그 경로의 총 비용은 “x→v 링크 비용 + v→y 최소 비용”입니다.  
모든 이웃에 대해 이 합을 계산하고, 그 중 최소값을 선택합니다.

이 식은 다익스트라 알고리즘의 결과와 일치하며,  
DV 알고리즘이 동일한 최소 비용을 계산함을 보여줍니다.

### Bellman-Ford 식의 의미

이 식은 단순한 수학적 관계가 아니라 **실제 라우팅 테이블을 구성하는 핵심 원리**입니다.  
노드 x가 목적지 y로 가는 최소 비용 경로를 찾으려면,  
먼저 어떤 이웃 v*를 거쳐야 하는지를 결정해야 합니다.  
따라서, **v\*(y)** = 식 (5.1)에서 최소값을 주는 이웃이 됩니다.

즉, x의 라우팅 테이블에는
- 목적지 y,
- 다음 홉(next-hop) v\*(y),
- 최소 비용 dₓ(y)  
  이 저장됩니다.

### 거리 벡터의 구성

각 노드 x는 다음 정보를 유지합니다.

- 각 이웃 v에 대한 링크 비용: **c(x, v)**
- 자신이 계산한 거리 벡터: **Dₓ = [Dₓ(y): y ∈ N]**
- 각 이웃의 거리 벡터: **Dᵥ = [Dᵥ(y): y ∈ N]**

노드는 주기적으로 자신의 거리 벡터를 모든 이웃에게 전송합니다.  
이웃으로부터 새 거리 벡터를 수신하면,  
Bellman-Ford 식을 사용하여 자신의 거리 벡터를 갱신합니다.

\[
Dₓ(y) = \min_v \{ c(x, v) + Dᵥ(y) \}
\]

이 과정이 반복되면, 모든 노드의 거리 추정값이 실제 최소 비용 값 `dₓ(y)`로 수렴합니다.


### 알고리즘 동작 예시

<img width="521" height="666" alt="Image" src="https://github.com/user-attachments/assets/e676890b-86fa-4ebe-831e-2b3eeee40b55" />

그림 5.6은 세 노드(x, y, z)로 구성된 네트워크에서  
DV 알고리즘이 동작하는 과정을 보여줍니다.

- 각 노드는 초기 라우팅 테이블을 가지고 시작합니다.  
  예: 노드 x의 초기 거리 벡터 Dₓ = [0, 2, 7]
- 모든 노드는 자신의 거리 벡터를 이웃에게 전송합니다.
- 각 노드는 이웃으로부터 받은 거리 벡터를 이용해  
  Bellman-Ford 식을 통해 자신의 Dₓ(y)를 갱신합니다.
- 이 과정이 반복되어, 결국 모든 노드가 동일한 최소 비용 경로를 계산하게 됩니다.

### 링크 비용 변화와 알고리즘의 반응

링크 비용이 변하면, DV 알고리즘은 이를 빠르게 감지하고 테이블을 갱신합니다.

예를 들어, y와 x 사이의 링크 비용이 **4 → 1로 감소**하면 다음이 일어납니다.

1. y가 변경된 링크 비용을 감지하고,  
   자신의 거리 벡터를 갱신한 뒤 이웃에게 알림.
2. z가 y의 업데이트를 수신하고,  
   새 경로 비용을 계산하여 자신의 거리 벡터를 갱신.
3. 업데이트는 전파되며, 두 번의 반복 후 안정 상태에 도달.

반면, 링크 비용이 **4 → 60으로 증가**하면 더 복잡한 상황이 발생합니다.  
y는 z를 통해 x로 가는 경로가 여전히 5로 보이기 때문에,  
y와 z 사이에 **라우팅 루프(routing loop)** 가 발생합니다.  
이 문제는 “**Count-to-Infinity 문제**”라고 부릅니다.

### Count-to-Infinity 문제 해결: Poisoned Reverse

**Poisoned Reverse(독극 반전)** 기법은 루프를 완화하는 방법입니다.  
만약 z가 x로 가는 경로를 y를 통해서만 알고 있다면,  
z는 y에게 “나는 x까지의 거리가 ∞이다”고 알립니다.  
즉, 자신이 y를 통해 x로 간다고 하면서도, y에게는 “나는 x로 갈 수 없다”고 거짓말을 하는 것입니다.  
이렇게 하면 y는 z를 통해 x로 우회하려 하지 않게 됩니다.

하지만 이 기법은 **두 노드 간의 루프**만 방지하며,  
세 노드 이상이 얽힌 루프는 해결하지 못합니다.

### LS와 DV 알고리즘 비교

| 구분 | LS 알고리즘 | DV 알고리즘 |
|------|--------------|--------------|
| **정보 범위** | 전체 네트워크의 링크 상태 (전역 정보) | 직접 연결된 이웃의 정보 (지역 정보) |
| **메시지 복잡도** | O(|N||E|) 메시지 필요 | 각 이웃 간 주기적 메시지 교환 |
| **수렴 속도** | 빠르지만 계산량 많음 | 느릴 수 있으며 루프 발생 가능 |
| **견고성(Robustness)** | 일부 노드 장애에도 비교적 안전 | 잘못된 정보가 빠르게 퍼질 수 있음 |
| **실제 예시** | OSPF (Open Shortest Path First) | RIP, BGP, ISO IDRP 등 |
