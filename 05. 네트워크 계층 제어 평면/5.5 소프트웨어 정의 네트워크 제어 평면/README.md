## 5.5 SDN 제어 평면 (The SDN Control Plane)

이 절에서는 **SDN 제어 평면(Control Plane)** 에 대해 살펴보겠습니다.  
제어 평면은 네트워크 전반에 걸쳐 패킷 전달을 제어하는 논리 계층으로,  
SDN(SDN-enabled) 장비들의 구성(configuration)과 관리(management)를 담당합니다.  
또한 이 평면은 네트워크 서비스 전반을 통합적으로 관리하는 역할을 수행합니다.

이번 내용은 4.4절에서 다뤘던 **일반화된 SDN 포워딩(generalized SDN forwarding)** 개념을 기반으로 합니다.  
따라서 본 절을 읽기 전에 4.4절과 본 장의 5.1절을 다시 복습하는 것이 좋습니다.

### SDN의 기본 개념

SDN 문헌에서 일반적으로 사용되는 용어를 따르자면,  
네트워크의 포워딩 장치를 **패킷 스위치(Packet Switch)** 라고 부릅니다.  
(이때 “패킷”이라는 단어는 생략되기도 합니다.)

포워딩 결정은 다음과 같은 여러 헤더 필드 값들을 기준으로 이루어질 수 있습니다.

- 네트워크 계층의 **출발지/목적지 주소**
- 링크 계층의 **출발지/목적지 주소**
- 트랜스포트 계층, 네트워크 계층, 링크 계층의 다양한 필드 값들

## SDN 아키텍처의 네 가지 핵심 특징 (Four Key Characteristics)

[Kreutz 2015]에 따르면, SDN 아키텍처는 다음 네 가지 주요 특성으로 정리할 수 있습니다.

### 흐름 기반 포워딩 (Flow-based Forwarding)

SDN이 제어하는 스위치는 패킷 헤더의 다양한 필드 값(트랜스포트 계층, 네트워크 계층, 링크 계층 포함)을  
기반으로 포워딩 결정을 내립니다.

예를 들어, **OpenFlow 1.0** 표준에서는 **11개의 서로 다른 헤더 필드 값**을 기준으로  
포워딩 규칙을 정의할 수 있습니다.  
이는 기존의 라우터 기반 포워딩(즉, IP 헤더의 목적지 주소만을 기준으로 한 포워딩)과  
명확히 구별됩니다.

즉, SDN에서는 **플로우 단위(Flow-based)** 로 트래픽을 제어할 수 있습니다.  
이러한 플로우 테이블(Flow Table)의 생성, 관리, 설치는  
SDN 제어 평면의 핵심 역할입니다.

### 데이터 평면과 제어 평면의 분리

<img width="560" height="489" alt="Image" src="https://github.com/user-attachments/assets/6fe796f2-6be3-4291-9d11-313e12603616" />

이 개념은 SDN의 핵심입니다.  
그림 5.2와 5.14를 보면 두 평면의 역할이 명확히 구분됩니다.

- **데이터 평면(Data Plane)**
    - 네트워크의 스위치들이 포함됩니다.
    - 스위치는 “조건(match) + 동작(action)” 규칙을 실행하여 패킷을 전달합니다.
    - 비교적 단순하지만 매우 빠른 장치들로 구성됩니다.

- **제어 평면(Control Plane)**
    - 서버와 소프트웨어로 구성되어 있습니다.
    - 각 스위치의 플로우 테이블을 계산하고 관리합니다.

즉, SDN은 “실행(데이터 평면)”과 “의사결정(제어 평면)”을 분리하여  
유연성과 중앙 집중적 제어를 모두 확보합니다.

### 제어 평면 기능의 외부화

SDN의 “S”는 **Software**를 의미하듯이,  
제어 평면은 소프트웨어로 구현됩니다.  
전통적인 라우터와 달리, 이 소프트웨어는 네트워크 장비 내부가 아니라  
**외부의 서버**에서 실행됩니다.

그림 5.14에서 보듯, 제어 평면은 두 가지 주요 구성 요소로 이루어집니다.

1. **SDN 컨트롤러 (Controller, 또는 네트워크 운영체제 Network Operating System)**
2. **네트워크 제어 애플리케이션 (Network-Control Applications)**

컨트롤러는 네트워크의 전체 상태(링크, 스위치, 호스트 등)를 정확히 유지하고,  
이 정보를 제어 평면의 애플리케이션들에게 제공합니다.  
또한, 이러한 애플리케이션이 하위 네트워크 장비를 모니터링, 프로그래밍, 제어할 수 있도록  
**API(응용 프로그래밍 인터페이스)** 를 제공합니다.

컨트롤러는 논리적으로 중앙 집중화되어 있으나,  
실제로는 여러 서버에 분산되어 구현되어  
**확장성(Scalability)** 과 **고가용성(High Availability)** 을 보장합니다.

### 프로그래밍 가능한 네트워크

SDN 네트워크는 제어 평면의 **네트워크 제어 애플리케이션**을 통해 프로그래밍이 가능합니다.  
이 애플리케이션들은 SDN 제어 평면의 “두뇌” 역할을 하며,  
컨트롤러가 제공하는 API를 이용해 데이터 평면의 동작을 직접 제어합니다.

예를 들어,
- **라우팅 애플리케이션**은  
  SDN 컨트롤러의 링크 상태 정보를 기반으로  
  **Dijkstra 알고리즘**을 실행해 최적 경로를 계산할 수 있습니다.
- **접근 제어 애플리케이션**은  
  특정 패킷을 차단하거나 허용하는 정책을 스위치에 적용할 수 있습니다.
- **로드 밸런서 애플리케이션**은  
  여러 서버 간에 트래픽을 분산시켜 효율적인 자원 활용을 도모할 수 있습니다.

이처럼 SDN은 네트워크 전체를 **소프트웨어적으로 프로그래밍**할 수 있게 함으로써,  
기존의 하드웨어 중심 네트워크보다 훨씬 높은 유연성과 자동화를 제공합니다.

### SDN 아키텍처의 구성 요소

**SDN 아키텍처**는 다음 세 계층으로 구성됩니다.

1. **데이터 평면(Data Plane)**
    - 실제 패킷 포워딩을 수행하는 SDN 스위치들로 구성됩니다.

2. **제어 평면(Control Plane)**
    - SDN 컨트롤러(네트워크 운영체제)로 구성되며,  
      하위 장비들과의 통신은 **Southbound API**(예: OpenFlow)를 통해 이루어집니다.

3. **응용 계층(Application Plane)**
    - 라우팅, 접근 제어, 로드 밸런싱 등 다양한 네트워크 제어 애플리케이션이 존재하며,  
      상위 계층과의 통신은 **Northbound API**를 통해 이루어집니다.

## SDN의 혁신적 의미

SDN은 기존 네트워크 모델의 **기능적 결합(monolithic integration)** 을 해체(unbundling)했습니다.  
즉, 스위치 하드웨어, 제어 소프트웨어, 네트워크 애플리케이션이  
하나의 벤더에 의해 통합 제공되던 기존 방식과 달리,  
이제는 각각 **독립적인 구성 요소**로 나뉘어 다양한 조직과 기업에서 개발·운용될 수 있습니다.

이 변화는 과거 컴퓨터 산업에서의 진화,  
즉 **메인프레임(Mainframe)** → **퍼스널 컴퓨터(PC)** 로의 전환과 유사합니다.  
하드웨어, 운영체제, 응용 프로그램이 분리되면서  
혁신적인 생태계가 형성되었듯,  
SDN 역시 개방형(Open) 네트워크 생태계를 가능하게 했습니다.

### 앞으로의 과제

이제 자연스럽게 다음과 같은 질문들이 생깁니다.

- 플로우 테이블(Flow Table)은 어디에서, 어떻게 계산되는가?
- SDN 스위치의 상태 변화(예: 링크 단절, 새 링크 연결)에 따라  
  플로우 테이블은 어떻게 갱신되는가?
- 여러 스위치의 플로우 테이블이 어떻게 조정되어  
  네트워크 전체의 일관성과 기능(예: 방화벽, 라우팅 경로, 부하 분산)을 유지하는가?

이 모든 기능을 조정하고 통합하는 것이 바로 **SDN 제어 평면의 역할**입니다.







## 5.5.1 SDN 제어 평면: SDN 컨트롤러와 네트워크 제어 애플리케이션

이 절에서는 **SDN 제어 평면(SDN Control Plane)** 의 핵심 구성 요소와 역할을 다룹니다.  
제어 평면은 네트워크 전반의 제어 로직을 담당하며,  
SDN 아키텍처의 중심적인 두 구성 요소로 나눌 수 있습니다.

1. **SDN 컨트롤러(SDN Controller)**
2. **SDN 네트워크 제어 애플리케이션(Network-control Applications)**

### SDN 컨트롤러의 개요

많은 SDN 컨트롤러들이 초기의 NOX 컨트롤러(Gude 2008) 이후로 발전해 왔습니다.  
컨트롤러의 기능은 일반적으로 **세 가지 계층(layer)** 으로 구성됩니다.  
그림 5.15는 이러한 일반적인 SDN 컨트롤러의 구조를 보여줍니다.

<img width="559" height="586" alt="Image" src="https://github.com/user-attachments/assets/031519db-5e4b-461c-99da-a0836abae39a" />

### 통신 계층 (Communication Layer)

**컨트롤러와 네트워크 장비 간 통신을 담당하는 계층**입니다.  
SDN 컨트롤러가 원격 SDN 스위치나 호스트를 제어하려면,  
양쪽 간에 정보를 교환할 수 있는 프로토콜이 필요합니다.

또한, 장비는 자신의 상태를 컨트롤러에 알릴 수 있어야 합니다.  
예를 들어,

- 링크가 연결되거나 끊어졌다는 이벤트
- 새로운 장비가 네트워크에 참여했다는 신호
- 특정 장비가 여전히 동작 중임을 알리는 하트비트(heartbeat)

이러한 이벤트들은 컨트롤러가 네트워크 상태를 최신 상태로 유지하도록 도와줍니다.  
이 프로토콜이 바로 컨트롤러 아키텍처의 **가장 하위 계층**을 구성하며,  
컨트롤러와 장비 간 통신은 **Southbound 인터페이스**를 통해 이루어집니다.

5.5.2절에서 다룰 **OpenFlow 프로토콜**이 이 통신 기능을 제공합니다.  
OpenFlow는 대부분의 SDN 컨트롤러에서 기본적으로 구현되어 있습니다.

### 네트워크 상태 관리 계층 (Network-wide State Management Layer)

이 계층은 **네트워크 전반의 상태(state)** 를 수집하고 관리합니다.  
제어 평면의 주요 의사결정(예: 플로우 테이블 구성, 로드 밸런싱, 방화벽 정책 적용 등)을  
수행하기 위해서는 항상 최신의 네트워크 정보를 보유해야 합니다.

컨트롤러는 다음과 같은 정보를 유지·관리합니다.

- **호스트 상태 (Host Info)**
- **링크 상태 (Link-state Info)**
- **스위치 상태 (Switch Info)**
- **플로우 테이블 (Flow Tables)**
- **네트워크 통계 (Statistics)**

스위치의 플로우 테이블에는 패킷 카운터, 포트 상태 등  
애플리케이션에서 활용 가능한 다양한 값들이 포함되어 있습니다.  
컨트롤러는 이를 통합하여 **네트워크 전반의 상태 데이터베이스**를 유지합니다.

### 네트워크 제어 애플리케이션 계층 (Network-control Application Layer)

컨트롤러는 상위 계층의 네트워크 제어 애플리케이션들과  
**Northbound 인터페이스(API)** 를 통해 상호작용합니다.

이 API는 애플리케이션이 네트워크 상태를 읽고 쓰거나,  
플로우 테이블을 조회 및 수정할 수 있도록 허용합니다.  
또한, 애플리케이션은 이벤트 알림(event notification)을 등록하여,  
네트워크 내 상태 변화(예: 링크 단절, 스위치 장애 등)에 대응할 수 있습니다.

많은 SDN 컨트롤러들은 REST [Fielding 2000] 기반의  
**요청-응답형 인터페이스(RESTful API)** 를 사용하여  
애플리케이션과 통신합니다.

### 논리적 중앙화 (Logical Centralization)

SDN 컨트롤러는 “**논리적으로 중앙화(Logically Centralized)**” 되어 있습니다.  
즉, 외부에서 보면 하나의 중앙 서버처럼 보이지만,  
실제로는 여러 서버가 분산되어 협업합니다.

이러한 분산 구조는 다음과 같은 이유로 필수적입니다.

- **장애 허용(Fault Tolerance)**
- **고가용성(High Availability)**
- **성능 향상 및 부하 분산**

이때 분산 컨트롤러들은 이벤트의 순서, 일관성, 합의(consensus) 등을  
유지해야 하므로, 분산 시스템 이론의 개념(예: Lamport 1989, Paxos 등)이 적용됩니다.

오늘날의 대표적인 SDN 컨트롤러 예시는 다음과 같습니다.

- **OpenDaylight [OpenDaylight 2020]**
- **ONOS [ONOS 2020]**

이러한 현대 컨트롤러들은 논리적 중앙화를 유지하면서도  
물리적으로는 분산된 구조를 통해 대규모 네트워크를 효율적으로 관리합니다.

### SDN 컨트롤러의 구성 요소

SDN 컨트롤러는 다음 세 계층으로 구성됩니다.

| 계층 | 주요 역할 |
|------|------------|
| **통신 계층 (Southbound API)** | OpenFlow, SNMP 등을 통해 하위 스위치와 통신 |
| **상태 관리 계층** | 네트워크 전체의 상태 정보(플로우, 링크, 호스트, 통계 등) 관리 |
| **애플리케이션 인터페이스 계층 (Northbound API)** | 라우팅, 접근 제어, 로드 밸런싱 등 애플리케이션과 연동 |

## 5.5.2 OpenFlow 프로토콜

**OpenFlow**는 SDN 컨트롤러와 SDN 장비 간 통신을 위한 핵심 프로토콜입니다.  
[OpenFlow 2009, ONF 2020]에서 정의되었으며,  
컨트롤러와 스위치 간 통신은 **TCP 포트 6653**을 통해 이루어집니다.

### 주요 메시지 유형

#### 컨트롤러 → 스위치 방향

- **Configuration**  
  컨트롤러가 스위치의 설정 파라미터를 조회하거나 수정할 수 있게 합니다.

- **Modify-State**  
  컨트롤러가 플로우 테이블 항목을 추가, 삭제, 수정할 때 사용합니다.  
  또한 스위치 포트의 속성을 설정할 수도 있습니다.

- **Read-State**  
  스위치의 플로우 테이블과 포트의 통계 값을 수집할 때 사용합니다.

- **Send-Packet**  
  컨트롤러가 특정 패킷을 지정된 포트로 직접 전송하도록 지시합니다.  
  메시지 본문(payload)에 실제 전송할 패킷이 포함됩니다.

#### 스위치 → 컨트롤러 방향

- **Flow-Removed**  
  플로우 테이블 항목이 삭제되었음을 컨트롤러에 알립니다.  
  (예: 타임아웃으로 인한 삭제, 혹은 Modify-State 명령의 결과)

- **Port-Status**  
  스위치 포트의 상태 변화(업/다운 등)를 컨트롤러에 알립니다.

- **Packet-In**  
  스위치에서 수신된 패킷이 어떤 플로우 항목과도 일치하지 않을 때,  
  해당 패킷을 컨트롤러로 전달합니다.  
  컨트롤러는 이 패킷을 분석하여 새로운 규칙을 설치하거나  
  추가적인 동작을 수행할 수 있습니다.

### 참고

OpenFlow는 여기서 설명한 것 외에도  
[OpenFlow 2009, ONF 2020]에 다양한 추가 메시지들이 정의되어 있습니다.  
이 프로토콜은 SDN 컨트롤러와 장비 간의 **상태 동기화(state synchronization)** 와  
**명령 전송(command delivery)** 의 핵심 역할을 수행합니다.

## 사례 연구: Google의 소프트웨어 정의 글로벌 네트워크

Google은 **데이터센터(DC)와 서버 클러스터 간의 전용 WAN(광역 네트워크)** 을 운영하고 있으며,  
이 네트워크는 **SDN 제어 평면**을 기반으로 구축되어 있습니다.  
이 시스템은 **B4 네트워크**라고 불리며, **OpenFlow**를 기반으로 동작합니다.

### Google B4의 주요 특징

1. **높은 링크 활용률 (약 70%)**
    - 전통적인 WAN보다 2~3배 높은 효율로 트래픽을 분산 처리합니다.
2. **대규모 데이터 복제 중심 설계**
    - 데이터센터 간 대용량 복제 트래픽을 우선 처리하도록 설계되어 있습니다.
3. **중앙 집중식 제어**
    - 비교적 적은 수의 데이터센터 간 트래픽만 중앙에서 제어 가능하게 합니다.

### 기술 구조

B4 네트워크는 **Google이 자체 제작한 스위치**를 사용하며,  
각 스위치는 확장된 OpenFlow 버전의 **OpenFlow Agent (OFA)** 를 탑재합니다.

- OFA는 데이터센터 내 트래픽을 담당하는 **OpenFlow Controller (OFC)** 와 통신합니다.
- OFC는 “**Out-of-band 네트워크**”를 통해  
  데이터 트래픽 네트워크와 분리된 제어 네트워크에서 동작합니다.
- OFC는 **ONIX SDN Controller** (Koponen 2010)를 기반으로 구현되어 있습니다.

또한 다음과 같은 프로토콜 및 기술이 사용됩니다.

- **BGP** – 데이터센터 간 라우팅
- **IS-IS** – 데이터센터 내부 라우팅
- **Paxos [Chandra 2007]** – 분산 제어의 일관성과 장애 복구 보장

### 결과 및 의의

Google의 B4 네트워크는  
SDN을 활용하여 전 세계 트래픽을 효율적으로 제어할 수 있는  
글로벌 규모의 성공적인 사례로 평가받습니다.

B4의 트래픽 엔지니어링 애플리케이션은  
SDN 컨트롤러 계층 위에서 동작하며,  
대규모 네트워크 전체에 걸친 **대역폭 프로비저닝 및 트래픽 관리** 기능을 수행합니다.

이 시스템은 Google 네트워크 운영의 효율성과 안정성을  
한 단계 도약시킨 중요한 기술적 진전으로 평가됩니다.




















## 5.5.3 데이터 평면과 제어 평면의 상호 작용: 예시 (Data and Control Plane Interaction: An Example)

SDN 제어 평면과 데이터 평면이 어떻게 상호작용하는지를 구체적으로 이해하기 위해,  
그림 5.16의 예시를 살펴보겠습니다.  
이 예시에서는 **다익스트라(Dijkstra)의 최단 경로 알고리즘**을 사용하여  
가장 짧은 경로를 계산합니다.

하지만 이 예시는 기존의 **라우터 중심 제어(per-router control)** 시나리오와는  
두 가지 중요한 차이점이 있습니다.

1. 다익스트라 알고리즘은 **패킷 스위치 내부가 아닌 외부 애플리케이션**으로 실행됩니다.
2. 각 스위치는 **링크 상태 정보를 서로 교환하지 않고**,  
   SDN 컨트롤러에만 보고합니다.

### 예시 시나리오

가정해 봅시다.  
스위치 **s1과 s2 사이의 링크가 끊어졌습니다**.  
SDN 네트워크는 최단 경로 라우팅을 수행하며,  
이에 따라 s1, s3, s4의 포워딩 규칙이 영향을 받습니다.  
하지만 s2의 다른 링크는 그대로 유지됩니다.

또한, **OpenFlow 프로토콜**이 통신 계층에 사용된다고 가정하겠습니다.

### 단계별 동작

<img width="491" height="526" alt="Image" src="https://github.com/user-attachments/assets/6af699bc-5f88-4f76-aac1-0a8ca99c40c4" />

1. **s1에서 링크 장애 발생 감지**  
   → s1은 OpenFlow의 `port-status` 메시지를 통해  
   SDN 컨트롤러에 링크 장애 상태를 보고합니다.

2. **컨트롤러가 이벤트 수신 및 상태 갱신**  
   → 컨트롤러는 이 메시지를 수신하여  
   링크 상태 관리 모듈(Link-state Manager)을 갱신합니다.

3. **다익스트라 기반 라우팅 애플리케이션에 알림 전송**  
   → 링크 상태 변경 알림은 라우팅 애플리케이션으로 전달됩니다.  
   애플리케이션은 최신 네트워크 상태 정보를 사용합니다.

4. **최단 경로 재계산**  
   → 라우팅 애플리케이션은 새롭게 변경된 링크 상태 정보를 참조하여  
   다익스트라 알고리즘으로 최단 경로를 다시 계산합니다.

5. **플로우 테이블 갱신 요청**  
   → 계산 결과는 플로우 테이블 관리자에게 전달되어  
   갱신이 필요한 스위치와 경로가 결정됩니다.

6. **OpenFlow를 통한 플로우 테이블 업데이트**  
   → 컨트롤러는 다음과 같은 새로운 규칙을 스위치에 설치합니다.
    - s1: s2로 향하는 패킷을 이제 s4를 경유하여 전달
    - s2: s1에서 오는 패킷을 s4를 통해 수신
    - s4: s1에서 s2로 가는 패킷을 전달

## 5.5.4 SDN: 과거와 미래 (SDN: Past and Future)

SDN은 비교적 최근의 기술로 주목받고 있지만,  
그 개념적 뿌리는 훨씬 이전으로 거슬러 올라갑니다.

- **2004년 Feamster, Lakshman, RFC 3746**  
  → 네트워크의 데이터 평면과 제어 평면을 분리해야 한다고 주장
- **1998년 van der Merwe**  
  → ATM 네트워크에서 여러 컨트롤러를 사용하는 제어 구조 제안
- **2007년 Ethane 프로젝트 (Casado 2007)**  
  → 단순한 이더넷 스위치 네트워크를 중앙 집중식 컨트롤러로 제어하는 시스템 제안  
  → 이 프로젝트가 **OpenFlow의 직접적 전신**이 되었습니다.

Ethane은 300개 이상의 스위치가 연결된 실험 네트워크에서  
패킷 승인(admission), 라우팅, 미일치 패킷(forwarding unmatched packets) 처리 등을  
중앙 컨트롤러가 수행했습니다.  
이후 이 프로젝트는 발전하여 OpenFlow로 이어졌습니다.

### 미래의 연구 방향

현재 SDN 연구는 두 가지 큰 방향으로 발전하고 있습니다.

1. **네트워크 기능 가상화(NFV, Network Functions Virtualization)**
    - 고가의 미들박스(방화벽, 캐시 서버 등)를  
      범용 하드웨어(서버, 스토리지, 스위치)로 대체하는 기술입니다.
    - 이는 SDN의 소프트웨어 기반 제어 개념을 확장한 형태입니다.

2. **인터-AS 확장 (Inter-AS SDN)**
    - 기존 SDN이 AS 내부(Intra-AS)에서 동작했다면,  
      이를 여러 AS 간 협력 수준으로 확장하려는 연구입니다.

## 원칙과 실제 (Principles in Practice)

### SDN 컨트롤러 사례 연구: OpenDaylight와 ONOS

초기의 SDN은 단 하나의 컨트롤러(NOΧ)와 프로토콜(OpenFlow)만 존재했습니다.  
하지만 이후 수많은 SDN 컨트롤러가 등장했습니다.

오늘날 대표적인 두 개의 오픈소스 SDN 컨트롤러는 다음과 같습니다.

- **OpenDaylight (ODL)** – [OpenDaylight 2020, Eckel 2017]
- **ONOS** – [ONOS 2020]

이들은 모두 **Linux Foundation**과 협력하여 개발되었으며,  
산업계에서 광범위하게 사용되고 있습니다.

## The OpenDaylight Controller

<img width="622" height="470" alt="Image" src="https://github.com/user-attachments/assets/f97eb82d-f908-4acc-9efb-75ff90580c93" />

그림 5.17은 **OpenDaylight(ODL) 컨트롤러**의 단순화된 구조를 보여줍니다.

ODL의 중심은 **Service Abstraction Layer (SAL)** 로,  
컨트롤러의 신경중추 역할을 합니다.

### 주요 구성 요소

| 계층 | 구성 요소 | 역할 |
|------|------------|------|
| **Northbound API** | REST / RESTCONF / NETCONF | 상위 애플리케이션(트래픽 엔지니어링, 방화벽, 로드 밸런싱 등)과 통신 |
| **기본 네트워크 기능 (Basic Network Functions)** | Topology Processing, Switch Manager, Statistics Manager, Host Tracker 등 | 네트워크 토폴로지 및 상태 관리 |
| **고급 서비스 (Enhanced Services)** | AAA, Device Discovery 등 | 인증, 장비 탐색, 정책 제어 |
| **SAL (Service Abstraction Layer)** | Config/Operational Data Store, Messaging | 모듈 간 데이터 관리 및 이벤트 전달 |
| **Southbound Plugins** | OpenFlow, NETCONF, SNMP, OVSDB | 하위 장비 및 프로토콜 제어 |

### 동작 방식

- 초기 ODL은 **AD-SAL (API-Driven SAL)** 방식만 지원했습니다.  
  → HTTP 기반 REST API를 통해 애플리케이션이 컨트롤러와 통신

- 이후 **MD-SAL (Model-Driven SAL)** 이 추가되어,  
  YANG 모델을 기반으로 장비의 구성 및 상태를 관리합니다.  
  → RFC 6020 표준에 따라 정의된 모델 언어 사용

## The ONOS Controller

<img width="583" height="517" alt="Image" src="https://github.com/user-attachments/assets/9ac3eec6-01dd-4916-8b7a-8123529f07a0" />

그림 5.18은 **ONOS 컨트롤러**의 구조를 단순화하여 보여줍니다.  
ONOS도 기본적으로 세 계층 구조를 가집니다.

### 주요 구성 요소

1. **Northbound Abstractions and Protocols**
    - ONOS의 독특한 기능은 **Intent Framework** 입니다.
    - 예를 들어, “Host A와 Host B 간 연결을 허용하라” 또는  
      “Host A와 B 간 통신을 차단하라”와 같은 고수준 서비스를 요청할 수 있습니다.
    - 이때 내부 동작 방식(경로 계산, 플로우 설정 등)은 애플리케이션이 몰라도 됩니다.
    - 네트워크 상태 변화는 동기식(쿼리) 또는 비동기식(리스너 콜백) 방식으로 전달됩니다.

2. **Distributed Core (분산 코어)**
    - 네트워크의 링크, 호스트, 장비 상태를  
      ONOS의 분산 데이터 저장소에 유지합니다.
    - 여러 서버에 동일한 ONOS 인스턴스를 실행함으로써  
      **서비스 복제와 고가용성**을 확보합니다.

3. **Southbound Abstractions and Protocols**
    - 하위 계층의 스위치, 링크, 프로토콜(OpenFlow, NETCONF, OVSDB 등)의  
      이질성을 추상화합니다.
    - 이를 통해 ONOS 코어는 장비 및 프로토콜에 구애받지 않고 동작할 수 있습니다.



