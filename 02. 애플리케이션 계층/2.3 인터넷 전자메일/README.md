# 2.3 인터넷에서의 전자메일

전자메일 서비스는 인터넷이 탄생한 이후 지금까지 존재해 왔습니다. <br>
이는 인터넷 초기 시절 가장 인기 있었던 응용 서비스 중 하나였으며, 최근에는 더욱 정교하고 강력한 기능을 갖추게 되었습니다. 인터넷에서 가장 중요하고 편리한 응용 중 하나라고 할 수 있습니다.

일반 우편 시스템과 마찬가지로, 이메일은 비동기(asynchronous) 통신 매체입니다. 즉, 통신하는 양측이 서로 동시에 온라인에 있을 필요 없이 각자 편할 때 답장을 주고받을 수 있습니다. <br>
종이 편지와 비교할 때, 이메일은 전달이 빠르고 사용하기 쉽고, 비용도 저렴합니다. 현대의 이메일은 첨부파일, 하이퍼링크, HTML 형식화 텍스트, 내장 이미지 등 강력한 기능을 많이 제공합니다.

￼

<img width="751" height="645" alt="Image" src="https://github.com/user-attachments/assets/d7283bf6-9eb4-4b84-af3c-910c76c79bd0" />

이 그림에서 세 가지 주요 구성요소를 볼 수 있습니다: 사용자 에이전트(user agent), 메일 서버(mail server), 그리고 간단한 메일 전송 프로토콜(Simple Mail Transfer Protocol, SMTP)입니다. <br>
아래의 상황을 통해 각 요소의 기능을 설명합니다: 발신자 Alice가 수신자 Bob에게 메일을 보내려 한다고 가정합니다. 사용자 에이전트는 사용자가 메일을 읽고, 답장하고, 전달하고, 저장하고, 작성할 수 있게 해줍니다. <br>
예를 들어 Microsoft Outlook과 Apple Mail이 대표적인 이메일 사용자 에이전트입니다. Alice가 메일을 작성한 후, 그녀의 사용자 에이전트는 메일을 그녀의 메일 서버로 보냅니다. <br>
이 메일은 메일 서버의 발송 메시지 대기열에 저장됩니다. Bob이 메일을 읽으려 할 때, 그의 사용자 에이전트는 Bob의 메일 서버에서 메일을 가져옵니다(로컬로 다운로드).

메일 서버는 이메일 인프라의 핵심입니다. 모든 수신자(예: Bob)는 메일 서버에 자신의 메일박스(mailbox)를 가지고 있으며, 이는 그에게 보내진 메일을 관리하고 유지합니다. <br>
일반적인 이메일은 다음 경로를 거칩니다: 발신자의 사용자 에이전트에서 출발해 발신자의 메일박스로, 그리고 수신자의 메일 서버에 도착해 수신자의 메일박스에 저장됩니다. <br>
Bob이 메일을 읽으려면, 메일 서버의 Bob 메일박스가 Bob의 신원을 인증해야 합니다(계정과 비밀번호 입력 등). Alice의 메일 서버도 Bob의 메일 서버가 메일 수신에 실패하는 상황을 처리할 수 있어야 합니다. <br>
만약 Alice의 메일 서버가 Bob의 메일 서버로 메일을 성공적으로 전달하지 못하면, 해당 메일을 메시지 대기열(message queue)에 임시 저장한 후, 나중에 다시 전송을 시도합니다. 재전송은 보통 30분마다 시도하며, 며칠 동안 성공하지 못하면 메일을 삭제하고 Alice에게 알립니다.

SMTP는 이메일에서 가장 중요한 응용 계층 프로토콜입니다. <br>
SMTP는 TCP의 신뢰성 있는 데이터 전송 기능을 이용해 메일이 발신자의 메일 서버에서 수신자의 메일 서버로 안전하게 전달되도록 합니다. <br>
많은 응용 계층 프로토콜과 마찬가지로, SMTP도 클라이언트(발신자의 메일 서버에서 동작)와 서버(수신자의 메일 서버에서 동작)로 나뉩니다. <br>
모든 메일 서버는 SMTP를 실행하며, 다른 서버로 메일을 보낼 때는 SMTP 클라이언트로, 다른 서버에서 메일을 받을 때는 SMTP 서버로 동작합니다.

## 2.3.1 SMTP

SMTP는 RFC 5321에 정의되어 있으며, 인터넷 전자메일의 핵심입니다. 앞서 언급했듯이, SMTP는 이메일을 발신자의 메일 서버에서 수신자의 메일 서버로 전달하는 역할을 합니다. <br>
SMTP는 HTTP보다 더 오래된 프로토콜로(원래의 RFC 문서는 1982년에 발표되었으며, SMTP 자체는 그 이전부터 존재), 많은 훌륭한 특징을 가지고 있지만, 오래된 기술인 만큼 인터넷 초창기 특성을 많이 가지고 있습니다. <br>
예를 들어, 모든 이메일 패킷의 본문(헤더뿐만 아니라)은 7-bit ASCII 인코딩만 사용할 수 있습니다. 1980년대 초에는 이런 제한이 합리적이었지만, 오늘날 멀티미디어 시대에는 7-bit ASCII 제한이 불편한 점이 많습니다. <br>
모든 멀티미디어 파일은 SMTP로 전송하기 전에 ASCII 메시지로 인코딩되어야 하며, 수신 후 다시 원래 인코딩으로 디코딩해야 합니다. 반면 HTTP는 멀티미디어 데이터를 ASCII로 인코딩할 필요 없이 전송할 수 있습니다.

SMTP의 기본 동작을 예시로 설명합니다: Alice가 Bob에게 간단한 ASCII 메시지를 보내려 한다고 가정합니다.

1. Alice가 사용자 에이전트를 열고, Bob의 메일 주소(예: bob@someschool.edu)를 입력한 뒤, 메일을 작성하고 사용자 에이전트로 전송합니다.
2. Alice의 사용자 에이전트는 메일을 그녀의 메일 서버로 보냅니다. 이 메일은 서버의 메시지 대기열에 저장됩니다.
3. Alice의 메일 서버에서 실행 중인 SMTP 클라이언트가 메시지 대기열에 메일이 있음을 감지하면, Bob의 메일 서버의 SMTP 서버와 TCP 연결을 생성합니다.
4. SMTP 핸드셰이크가 완료되면, SMTP 클라이언트는 Alice의 메일을 TCP 연결을 통해 전송합니다.
5. Bob의 메일 서버에서 SMTP 서버가 메일을 수신하면, Bob의 메일박스에 저장합니다.
6. Bob은 시간이 날 때 사용자 에이전트를 열고 메일을 읽습니다.

<img width="721" height="275" alt="Image" src="https://github.com/user-attachments/assets/e768fc54-2248-4023-b73a-869b134209ca" />


Alice가 Bob에게 메일을 보내는 과정

주목할 점은 SMTP가 다른 프로토콜처럼 중간 메일 서버를 사용하지 않는다는 것입니다. <br>
예를 들어, 서버 하나가 홍콩에 있고, 다른 하나가 미국 세인트루이스에 있어도, SMTP는 두 서버 사이에 직접 TCP 연결을 생성합니다. 만약 Bob의 메일 서버가 오프라인이면, Alice의 메일 서버는 재전송 기회를 기다려야 합니다. 이 메일은 중간 서버에 저장되지 않습니다. <br>
SMTP 메시지가 서버 간에 어떻게 전달되는지 살펴봅니다. SMTP는 사람 간의 직접적인 대화 방식과 유사하게 동작합니다. <br>
먼저, SMTP 클라이언트(발신자 메일 서버에서 동작)는 SMTP 서버(수신자 메일 서버에서 동작)의 포트 25로 TCP 연결을 생성해야 합니다. <br>
서버가 오프라인이면, 클라이언트는 나중에 다시 시도해야 합니다. 연결이 성공하면, 서버와 클라이언트는 응용 계층 핸드셰이크를 진행합니다. <br>
이 단계에서 SMTP 클라이언트는 발신자와 수신자의 이메일 주소를 제시합니다. 핸드셰이크가 완료되면, 클라이언트는 오류 없이 메일을 서버로 전송할 수 있습니다. <br>
추가로 전송할 메일이 있으면, 같은 TCP 연결에서 반복적으로 전송하며, 모든 메일 전송이 끝나면 TCP 연결을 종료합니다.

SMTP 메시지 교환 예시(클라이언트: C, 서버: S). 클라이언트 호스트명은 crepes.fr, 서버 호스트명은 hamburger.edu입니다. 아래의 각 ASCII 텍스트 줄은 실제 TCP 소켓에 전송된 원문입니다.

```
S:  220 hamburger.edu
C:  HELO crepes.fr
S:  250 Hello crepes.fr, pleased to meet you
C:  MAIL FROM: <alice@crepes.fr>
S:  250 alice@crepes.fr ... Sender ok
C:  RCPT TO: <bob@hamburger.edu>
S:  250 bob@hamburger.edu ... Recipient ok
C:  DATA
S:  354 Enter mail, end with ”.” on a line by itself
C:  Do you like ketchup?
C:  How about pickles?
C:  .
S:  250 Message accepted for delivery
C:  QUIT
S:  221 hamburger.edu closing connection
```

이 예시에서 클라이언트는 crepes.fr 메일 서버에서 hamburger.edu 메일 서버로 메시지("Do you like ketchup? How about pickles?")를 전송합니다. <br>
대화 과정에서 클라이언트는 5개의 명령어를 보냅니다: HELO(HELLO의 약어), MAIL FROM, RCPT TO, DATA, QUIT. 각 명령어의 의미는 직관적입니다. <br>
클라이언트는 마침표만 있는 메시지를 보내는데, 이는 메시지 본문이 끝났음을 나타냅니다(ASCII 용어에서 각 메시지는 CRLF로 끝나며, CR은 캐리지 리턴, LF는 줄 바꿈을 의미). <br>
서버는 각 명령어에 대해 응답 코드와(때로는) 설명 메시지를 반환합니다. SMTP는 지속적인 연결을 사용합니다. 여러 메일을 전송할 경우, 모든 메시지는 동일한 TCP 연결에서 전송됩니다. <br>
각 메일은 MAIL FROM: crepes.fr로 시작하고, 마침표만 있는 줄로 끝납니다. 모든 메일 전송 후에만 QUIT 명령어를 전송합니다.

## 2.3.2 HTTP와의 비교

SMTP와 HTTP의 유사점과 차이점을 비교해 봅니다. <br>
두 프로토콜 모두 한 호스트에서 다른 호스트로 파일을 전송하는 데 사용됩니다. <br>
HTTP는 웹 서버와 클라이언트(일반적으로 브라우저) 사이에서 파일(오브젝트)을 전송하고, SMTP는 두 메일 서버 사이에서 파일(이메일 메시지)을 전송합니다. <br>
파일 전송 시 두 프로토콜 모두 지속적인 TCP 연결을 사용하므로, 공통점이 많습니다. 하지만 중요한 차이점도 있습니다:

- HTTP는 pull 프로토콜입니다. 누군가 정보를 웹 서버에 올려두고, 사용자가 보고 싶을 때 서버에서 파일을 다운로드합니다. 즉, TCP 연결은 수신자가 생성합니다. 반면 SMTP는 push 프로토콜로, 발신자 메일 서버가 파일을 수신자 메일 서버로 보냅니다. 즉, TCP 연결은 발신자가 생성합니다.
- 앞서 언급했듯이, SMTP는 모든 메시지(본문 포함)를 7-bit ASCII로 인코딩해야 합니다. 7-bit ASCII가 아닌 문자가 포함된 메시지(예: 악센트가 있는 프랑스어 문자, 이미지 파일 등)는 7-bit ASCII로 재인코딩해야 합니다. HTTP는 이런 제한이 없습니다.
- 여러 파일 유형(텍스트, 이미지 등)을 동시에 포함하는 메시지를 처리하는 방법도 다릅니다. HTTP는 각 오브젝트를 별도의 HTTP 응답 메시지에 담아 전송하지만, SMTP는 모든 내용을 하나의 메시지에 모두 포함하여 전송합니다.

## 2.3.3 메일 메시지 포맷

Alice가 Bob에게 종이 편지를 쓸 때, 봉투에 Bob의 주소, 자신의 회신 주소, 발송 날짜 등 필요한 정보를 적어야 합니다. <br>
이메일도 마찬가지로, 헤더에 필요한 정보가 본문보다 먼저 포함되어야 합니다. 이러한 정보는 일련의 헤더 라인에 담기며, RFC 5322에 규정되어 있습니다. <br>
헤더 라인과 본문은 한 줄의 줄 바꿈(CRLF)으로 구분됩니다. RFC 5322는 헤더 라인의 형식과 의미를 정의합니다. <br>
HTTP에서는 각 헤더 라인이 읽기 쉬운 텍스트로 구성되며, 키워드, 콜론, 값으로 이루어집니다. 일부 키워드는 값이 필요하고, 일부는 필요하지 않습니다. <br>
SMTP에서는 모든 헤더에 From:과 To: 라인이 반드시 포함되어야 하며, Subject: 라인은 선택 사항이고, 그 외에도 여러 선택 필드가 있습니다. <br>
중요한 점은, 이 헤더 라인들은 앞서 2.3.1에서 언급한 SMTP 명령어와 다르다는 것입니다(비록 "from"과 "to" 같은 동일한 키워드가 있지만). <br>
명령어는 SMTP 핸드셰이크 프로토콜의 일부이고, 여기서 언급하는 헤더 라인은 메시지 본문의 일부입니다.

일반적인 메시지 헤더 예시는 다음과 같습니다:

```
From: alice@crepes.fr
To: bob@hamburger.edu
Subject: Searching for the meaning of life.
```

헤더가 끝나면 한 줄의 줄 바꿈이 오고, 그 뒤에 ASCII 인코딩된 메시지 본문이 옵니다.

## 2.3.4 메일 액세스 프로토콜

SMTP가 메시지를 Alice의 메일 서버에서 Bob의 메일 서버로 성공적으로 전송하면, 메일은 Bob의 메일박스에 저장됩니다. <br>
위의 논의에서는 기본적으로 Bob이 자신의 메일 서버에 로그인해, 해당 서버에서 메일을 읽는 프로그램을 실행한다고 가정했습니다. <br>
1990년대 초까지는 이런 방식이 표준이었습니다. 하지만 오늘날에는 메일 수신 서비스가 기본적으로 클라이언트-서버 구조로 바뀌었습니다. <br>
사용자는 자신의 PC, 노트북, 스마트폰 등에서 클라이언트 프로그램을 실행해 메일을 읽습니다. 클라이언트가 사용자의 컴퓨터에서 동작하면, 더 다양한 메일 내용을 즐길 수 있습니다. 예를 들어 멀티미디어 메시지, 첨부파일 등을 받을 수 있습니다.

Bob(수신자)이 자신의 컴퓨터에서 메일 클라이언트를 실행한다면, 메일 서버도 그의 컴퓨터에 두는 것이 합리적으로 보일 수 있습니다. <br>
하지만 이렇게 하면 Alice의 메일 서버가 Bob의 개인 컴퓨터와 직접 연결해야 하며, Bob의 컴퓨터는 항상 켜져 있어야 하고, 인터넷에 계속 연결되어 있어야 합니다. <br>
언제 메일이 올지 모르기 때문입니다. 이는 많은 인터넷 사용자에게 불가능합니다. 그래서 메일 서버를 항상 켜져 있는, 지속적으로 온라인인 서버에 두고, 사용자는 자신의 컴퓨터에서 클라이언트만 실행해 해당 서버에 접속해 메일을 읽는 것이 더 현실적입니다. <br>
이 서버는 여러 사용자가 공유하며, ISP(회사, 학교 등)가 관리합니다.

이메일이 발송되어 도착하는 경로를 생각해 봅니다. <br>
이 경로의 어느 지점에서든 메일은 Bob의 메일 서버에 저장됩니다. Alice의 사용자 에이전트가 직접 SMTP로 메일을 보낼 수도 있지만, 일반적으로는 발신자 사용자 에이전트가 직접 메일 서버에 보내지 않습니다. <br>
대신 Alice의 사용자 에이전트는 SMTP로 자신의 메일 서버에 메일을 보내고, 그 메일 서버가 SMTP(클라이언트 역할)로 Bob의 서버에 메일을 전달합니다. <br>
이렇게 두 단계로 나누는 이유는, 메일 서버가 없으면 Alice의 개인 컴퓨터는 Bob의 메일 서버가 오프라인인 상황을 처리할 충분한 자원이 없기 때문입니다. <br>
Alice의 메일 서버에 먼저 메일을 저장하면, 서버는 계속 켜져 있으므로 재전송(30분마다 등)을 계속 시도할 수 있습니다. (만약 Alice의 메일 서버가 연결되지 않으면, Alice는 시스템 관리자에게 문의할 수 있습니다) SMTP RFC에는 여러 SMTP 서버 간에 메시지를 중계하는 방법이 규정되어 있습니다.

<img width="745" height="189" alt="Image" src="https://github.com/user-attachments/assets/76c99a33-b69e-4bd0-8356-2144103e07f2" />

하지만 아직 경로가 끝난 것은 아닙니다! <br>
Bob 같은 수신자가 사용자 에이전트를 통해 메일 서버에서 자신의 컴퓨터로 메일을 가져오려면 어떻게 해야 할까요? Bob의 사용자 에이전트는 SMTP를 사용할 수 없습니다. <br>
메일 가져오기는 pull 동작이지만, SMTP는 push 프로토콜이기 때문입니다. 이 마지막 구간은 특별한 메일 액세스 프로토콜이 필요합니다. <br>
현재 널리 사용되는 메일 액세스 프로토콜에는 POP3(Post Office Protocol — Version 3), IMAP(Internet Mail Access Protocol), 그리고 HTTP가 있습니다.

SMTP는 발신자와 수신자 메일 서버 간에 메일을 전달하는 데 사용되며, 발신자 사용자 에이전트에서 자신의 메일 서버로 메일을 전송할 때도 사용됩니다. 메일 액세스 프로토콜(POP3 등)은 수신자 메일 서버에서 수신자 사용자 에이전트로 메일을 전달하는 데 사용됩니다.

### POP3

POP3는 매우 간단한 메일 액세스 프로토콜로, [RFC 1939]에 정의되어 있습니다. 프로토콜이 매우 단순하기 때문에 기능도 제한적입니다. POP3의 실행 절차는 다음과 같습니다:

1. 사용자 에이전트(클라이언트)가 메일 서버(서버) 포트 110에 TCP 연결을 엽니다. 연결이 완료되면, 인증(authorization), 트랜잭션(transaction), 업데이트(update)의 세 단계를 실행할 수 있습니다.
2. 인증 단계에서는 사용자 에이전트가 올바른 사용자명과 비밀번호를 보내 사용자 신원을 인증합니다.
3. 트랜잭션 단계에서는 사용자 에이전트가 메일을 가져오고, 삭제할 메일을 지정하고, 삭제 표식을 해제하고, 메일 통계를 가져올 수 있습니다.
4. 업데이트 단계는 클라이언트가 quit 명령어를 보내 POP3 세션이 종료될 때 트리거됩니다. 이 단계에서 메일 서버는 삭제 표식이 된 메일을 실제로 삭제합니다.

POP3 트랜잭션에서 사용자 에이전트는 명령어를 보내고, 서버는 각각에 응답합니다. 응답은 두 가지입니다: +OK(서버가 데이터를 클라이언트에 보낸 후 성공을 알림), -ERR(명령어 실행 중 문제가 발생함). <br>
인증 단계의 주요 명령어는 user<username>과 pass<password>입니다. 사용 방법을 설명하기 위해, POP3를 지원하는 서버(예: mailServer)에 Telnet으로 포트 110에 접속해 다음 명령어를 입력해 볼 수 있습니다:

```
$ telnet mailServer 110
+OK POP3 server ready
user bob
+OK
pass hungry
+OK user successfully logged on
```

### IMAP

POP3를 사용할 경우, Bob이 메일을 자신의 컴퓨터에 다운로드한 후, 로컬 폴더를 만들어 메일을 분류할 수 있습니다. <br>
메일을 삭제하거나, 폴더로 이동하거나, 검색할 수 있습니다. 그러나 로컬 저장 방식은 여러 기기를 사용하는 사용자에게 불편합니다. <br>
이런 사용자는 메일이 원격 서버에 저장되어 여러 기기에서 접근할 수 있기를 원합니다. POP3는 원격 폴더 생성이나 메일 이동을 지원하지 않으므로, 이런 기능을 제공하기 위해 IMAP이 개발되었습니다(RFC 3501에 정의).

IMAP 서버는 각 메일을 폴더에 저장합니다. 메일이 서버에 도착하면 수신자의 INBOX 폴더에 먼저 저장되고, 이후 사용자가 직접 만든 폴더로 이동하거나 읽거나 삭제할 수 있습니다. <br>
IMAP은 폴더 생성, 메일 이동, 원격 폴더 내 조건 검색 등 다양한 기능을 제공합니다. POP3와 달리 IMAP은 세션 간 상태 정보를 유지해야 합니다(폴더 이름, 메일 위치 등). <br>
IMAP의 또 다른 중요한 기능은 사용자 에이전트가 메일의 일부만 다운로드할 수 있다는 점입니다. <br>
예를 들어, 헤더만 다운로드하거나 멀티파트 MIME 메일의 일부만 받을 수 있습니다. <br>
이는 사용자 에이전트와 메일 서버 간의 연결 대역폭이 낮을 때 유용합니다. 대역폭이 낮으면, 모든 메일을 다운로드하지 않고, 크기가 큰 메일(영상 등)은 다운로드하지 않을 수 있습니다.

### 웹 기반 이메일

현재는 점점 더 많은 사용자가 웹 브라우저를 통해 이메일을 주고받습니다. <br>
Hotmail은 1990년대에 웹 기반 메일 액세스 방식을 도입했고, 현재는 Google, Yahoo!, 기업, 학교 등에서도 웹 기반 메일을 제공합니다. <br>
이 방식에서는 이메일 사용자 에이전트가 웹 브라우저가 되고, 사용자는 HTTP를 통해 원격 메일박스와 통신합니다. 수신자가 메일을 읽으려면, HTTP(POP3나 IMAP 대신)를 통해 메일 서버에서 웹 브라우저로 메일을 전달받습니다. <br>
발신자가 메일을 보내려면, HTTP(SMTP 대신)를 통해 웹 브라우저에서 메일 서버로 메일을 보냅니다. 하지만 메일 서버 간의 메일 전송에는 여전히 SMTP가 사용됩니다.

