# 2.2 웹과 HTTP

1990년대 초까지 인터넷의 주요 사용자는 연구자, 학계 종사자, 대학생뿐이었습니다. <br>
그들의 필요는 원격으로 호스트에 접속하거나, 로컬과 원격 간에 파일을 전송하고, 뉴스와 이메일을 주고받는 것 정도였습니다. <br>
이러한 서비스들은 오늘날에도 유용하지만, 그 당시에는 학계 외에는 인터넷을 아는 사람이 거의 없었습니다.

1990년대 초, 월드와이드웹(Berners-Lee 1994)이 등장하면서 상황이 극적으로 바뀌었습니다. <br>
웹은 일반 대중의 관심을 끈 최초의 인터넷 응용 서비스로, 사람들의 업무 및 일상에서의 상호작용 방식을 완전히 변화시켰습니다. <br>
인터넷을 수많은 데이터 네트워크 중 하나에서 가장 중요하고 독보적인 네트워크로 끌어올렸습니다.

인터넷의 가장 매력적인 특징은 필요할 때마다 서비스를 제공해준다는 점입니다(on demand). <br>
기존 TV나 라디오처럼 사용자가 프로그램을 시청/청취할 시간을 제한하는 것이 아니라, 인터넷은 사용자가 원하는 시간에 원하는 콘텐츠를 얻을 수 있게 해줍니다. <br>
이처럼 '온디맨드' 특성 외에도, 누구나 매우 저렴한 비용으로 인터넷에 콘텐츠를 게시할 수 있습니다. <br>
하이퍼링크와 검색 엔진 덕분에 우리는 정보의 바다에서 자료를 찾을 수 있고, 이미지와 동영상은 우리의 감각을 자극하며, 폼, JavaScript, Java 애플릿 등 다양한 도구로 웹사이트와 상호작용할 수 있습니다. <br>
웹페이지와 그에 사용되는 프로토콜은 YouTube, 웹 기반 이메일(Gmail), 다양한 모바일 서비스(Instagram, Google Map) 등의 플랫폼 역할을 하게 되었습니다.

## 2.2.1 HTTP 개요

하이퍼텍스트 전송 프로토콜(HyperText Transfer Protocol, HTTP)은 웹이 사용하는 응용 계층 프로토콜로, 웹의 핵심입니다. <br>
HTTP는 두 개의 프로그램, 즉 클라이언트와 서버에 구현되어야 하며, 이 두 프로그램은 서로 다른 단말기에서 HTTP 메시지를 교환합니다. <br>
HTTP는 이러한 메시지의 구조와 교환 방식을 정의합니다. HTTP의 동작 원리를 설명하기 전에, 몇 가지 용어를 먼저 살펴봅니다.

웹페이지(Web page, 문서)는 여러 객체(Object)로 구성됩니다. <br>
객체(Object)는 HTML 파일, JPEG 이미지, Java 애플릿, 동영상 등과 같은 단순 파일이며, 각 객체는 URL로 주소 지정됩니다. <br>
대부분의 웹페이지는 기본 HTML 파일(base HTML file)과 여러 참조 객체로 이루어져 있습니다. 예를 들어, HTML 파일과 사진 5장으로 구성된 웹페이지라면 6개의 객체가 있는 셈입니다. <br>
기본 HTML 파일은 URL로 다른 객체를 참조합니다. URL은 호스트 이름(host name)과 파일 경로(path name)로 이루어집니다.

예시: http://www.someSchool.edu/someDepartment/picture.gif   
여기서 www.someSchool.edu는 호스트 이름, /someDepartment/picture.gif는 파일 경로입니다.

웹 브라우저(Web browser)는 HTTP 클라이언트 역할을 하며, 앞으로 브라우저와 클라이언트라는 단어를 번갈아 사용합니다. <br>
웹 서버(Web server)는 HTTP 서버 역할을 하며, 객체를 저장합니다. 유명한 웹 서버로는 Apache, Microsoft Internet Information Server 등이 있습니다. <br>
HTTP는 클라이언트가 서버에 웹페이지를 요청하는 방법과, 서버가 클라이언트에 웹페이지를 반환하는 방법을 정의합니다. <br>
사용자가(하이퍼링크 클릭 등으로) 웹페이지를 요청하면, 브라우저는 서버에 HTTP 요청 메시지를 보내 모든 객체를 요청합니다. 서버는 요청을 받고, 요청된 웹페이지 객체를 포함한 응답 메시지를 브라우저에 보냅니다.

<img width="652" height="460" alt="Image" src="https://github.com/user-attachments/assets/72029177-fb01-451b-99ad-76591cc22594" />

HTTP는 전송 계층 프로토콜로 TCP를 사용합니다. HTTP 클라이언트는 서버와의 연결을 먼저 설정해야 HTTP 메시지를 교환할 수 있습니다. <br>
전송 쌍방은 소켓 인터페이스를 통해 TCP 기능에 접근하며, HTTP 메시지는 소켓을 통해 전송 계층을 거쳐 네트워크를 지나 수신 측 소켓에 도달한 후, 수신 프로그램에 전달됩니다. <br>
송신 측이 메시지를 보내면, 그 이후의 전달은 TCP가 책임지므로, HTTP 메시지는 반드시 수신 측 프로그램에 도달합니다. 이런 계층 구조 덕분에, HTTP는 데이터 손실이나 패킷 재조합 문제를 신경 쓸 필요가 없습니다. 이는 TCP 및 하위 프로토콜의 역할입니다.

중요한 점: 웹 서버는 클라이언트에게 웹페이지를 반환할 때, 클라이언트의 상태 정보를 기억하지 않습니다. 같은 클라이언트가 짧은 시간에 동일한 웹페이지를 여러 번 요청하더라도, 서버는 이전에 무엇을 했는지 기억하지 못하고 매번 요청을 처리합니다. 이런 특성 때문에 HTTP는 '무상태(stateless) 프로토콜'이라 불립니다. 또 HTTP는 주종 구조(master-slave architecture)의 응용입니다. 웹 서버는 지속적으로 서비스를 제공하며, 고정 IP를 가지고 수많은 브라우저의 요청을 처리합니다.

## 2.2.2 비지속적 및 지속적 연결

많은 네트워크 서비스에서 클라이언트와 서버의 통신은 오랜 시간 지속되며, 여러 번의 요청과 응답이 오갑니다. <br>
TCP 위에서 통신할 때, 개발자는 메시지를 각각 별도의 TCP 연결로 전송할지, 하나의 TCP 연결로 전송할지 선택해야 합니다. <br>
전자는 '비지속적 연결(non-persistent connections)', 후자는 '지속적 연결(persistent connections)'입니다. <br>
HTTP에서는 두 방식 모두 사용 가능하며, 기본적으로는 지속적 연결을 사용하지만, 클라이언트 또는 서버에서 비지속적 연결로 설정할 수도 있습니다.

### HTTP의 비지속적 연결

비지속적 연결 모드에서 웹페이지가 클라이언트에 전송되는 과정을 살펴보겠습니다. 예를 들어, 기본 HTML 파일과 10개의 이미지로 구성된 웹페이지가 있다고 합시다. 이 11개 객체가 모두 같은 호스트에 저장되어 있고, 기본 HTML 파일의 URL은 다음과 같습니다.

http://www.someSchool.edu/someDepartment/home.index

전송 과정은 다음과 같습니다:

1. HTTP 클라이언트는 www.someSchool.edu 호스트에 TCP 연결(포트 80, HTTP 기본 포트)을 요청합니다. 클라이언트와 서버는 각각 네트워크 소켓을 가집니다.
2. 클라이언트는 소켓을 통해 서버에 HTTP 요청 메시지를 전송합니다. 이 요청에는 /someDepartment/home.index 경로가 포함됩니다.
3. 서버는 소켓을 통해 HTTP 메시지를 받아, /someDepartment/home.index 객체를(메모리 또는 디스크에서) 꺼내서 HTTP 응답 메시지로 포장한 뒤, 소켓을 통해 클라이언트에 전송합니다.
4. 서버는 TCP 연결을 닫으라고 지시합니다(TCP는 클라이언트가 메시지를 완전히 받았는지 확인한 뒤 연결을 닫음).
5. 클라이언트는 응답 메시지를 받고, TCP 연결이 닫힙니다. 메시지에서 HTML 파일을 추출하고, 이 파일에서 10개의 이미지 객체의 참조(URL)를 찾습니다.
6. 각 이미지 객체마다 1~4번 과정을 반복합니다.
7. 브라우저는 웹페이지를 사용자에게 표시합니다. 표시 방식은 브라우저마다 다르지만, HTTP와는 무관합니다.

이 예시에서 각 객체 전송마다 TCP 연결이 닫히므로, 11개의 파일을 전송하려면 11개의 TCP 연결이 필요합니다. <br>
현대 브라우저는 병렬 연결 수를 사용자가 설정할 수 있는데, 기본적으로 5~10개의 TCP 연결을 병렬로 허용합니다. 사용자가 원하면 병렬 연결 수를 1로 설정할 수도 있습니다. 병렬 연결을 사용하면 응답 시간이 단축됩니다. <br>
웹페이지 요청에서 전체 전송에 걸리는 시간을 대략적으로 계산해보면, 클라이언트가 기본 HTML 파일을 요청할 때부터 모든 객체를 받을 때까지 약 2번의 왕복 시간(RTT, round-trip time)이 필요합니다. <br>
한 번은 TCP 연결 설정(3-way handshake), 한 번은 요청 및 응답, 그리고 파일 전송 시간이 추가됩니다.

<img width="748" height="606" alt="Image" src="https://github.com/user-attachments/assets/c1bb717b-8945-49b0-a462-0e92cd64660a" />

### HTTP의 지속적 연결

비지속적 연결의 단점은, 객체마다 새 TCP 연결을 만들어야 하므로 서버에 큰 부담이 되고, 매번 두 번의 RTT가 발생한다는 점입니다. <br>
HTTP 1.1은 지속적 연결을 도입했습니다. 서버는 첫 객체 요청에 응답한 뒤, 클라이언트와의 연결을 바로 끊지 않고, 이후 같은 클라이언트의 모든 요청을 하나의 TCP 연결로 처리합니다. <br>
이렇게 하면 하나의 연결로 전체 웹페이지(및 다른 객체)를 전송할 수 있습니다. 추가로, 같은 클라이언트가 같은 서버의 다른 웹페이지를 요청할 때도 같은 연결을 재사용할 수 있습니다. <br>
요청은 순차적 또는 파이프라이닝(pipelining) 방식으로 처리할 수 있습니다. <br>
서버는 일정 시간 동안 아무런 활동이 없으면 연결을 닫습니다(timeout 설정 가능). 최근 HTTP/2(RFC 7540)는 HTTP 1.1을 개선하여, 하나의 연결에서 여러 요청과 응답을 교차 처리하고, 메시지 우선순위 기능을 추가했습니다.

## 2.2.3 HTTP 메시지 형식

HTTP 메시지는 요청 메시지와 응답 메시지 두 가지가 있습니다.

### HTTP 요청 메시지

예시:
```
GET /somedir/page.html HTTP/1.1
Host: www.someschool.edu
Connection: close
User-agent: Mozilla/5.0
Accept-language: fr
```

<img width="742" height="439" alt="Image" src="https://github.com/user-attachments/assets/20eae651-b609-40ef-b71e-1aada2df69b1" />

이 메시지는 ASCII 텍스트로 작성되어 있어, 컴퓨터에 익숙한 사람이라면 쉽게 읽을 수 있습니다. <br>
메시지는 여러 줄로 구성되며, 각 줄 끝에는 줄바꿈이 있습니다. 첫 줄은 '요청 행(request line)', 나머지는 '헤더 행(header lines)'입니다. <br>
요청 행은 세 개의 필드(메소드, URL, HTTP 버전)로 이루어집니다. 메소드 필드는 GET, POST, HEAD, PUT, DELETE 등이 있으며, 가장 많이 쓰이는 것은 GET입니다.

헤더 행 예시:
- Host: 요청 객체가 저장된 호스트
- Connection: close: 응답 후 연결 종료
- User-agent: 브라우저 종류(예: Firefox)
- Accept-language: fr: 프랑스어 버전 요청(가능할 경우)

헤더 아래에는 '엔티티 바디(entity body)'가 올 수 있습니다. GET 방식에서는 비어 있지만, POST 방식에서는 사용자가 입력한 폼 데이터 등이 들어갑니다.

메소드 설명:
- GET: 객체 요청
- POST: 폼 데이터 전송
- HEAD: 객체 정보만 요청(디버깅용)
- PUT: 객체 업로드
- DELETE: 객체 삭제

### HTTP 응답 메시지

예시:
```
HTTP/1.1 200 OK
Connection: close
Date: Tue, 18 Aug 2015 15:44:04 GMT
Server: Apache/2.2.3 (CentOS)
Last-Modified: Tue, 18 Aug 2015 15:11:03 GMT
Content-Length: 6821
Content-Type: text/html

(data data data ...)
```

<img width="749" height="432" alt="Image" src="https://github.com/user-attachments/assets/ed8f6167-1fd0-4e2d-bfe5-a67c0e186790" />

응답 메시지는 세 부분(상태 행, 헤더 행, 엔티티 바디)으로 나뉩니다. 상태 행에는 버전, 상태 코드, 상태 메시지가 포함됩니다. <br>

예시 상태 코드:
- 200 OK: 성공
- 301 Moved Permanently: 객체가 영구적으로 이동됨(새 URL은 Location 헤더에)
- 400 Bad Request: 요청 메시지 오류
- 404 Not Found: 파일 없음
- 505 HTTP Version Not Supported: 지원하지 않는 HTTP 버전

헤더 행 예시:
- Connection: close: 응답 후 연결 종료
- Date: 응답 메시지 생성 시간
- Server: 서버 종류
- Last-Modified: 객체 마지막 수정 시간(캐시에서 중요)
- Content-Length: 객체 크기
- Content-Type: 객체 타입(예: text/html)

## 2.2.4 사용자-서버 상호작용: 쿠키

HTTP 서버는 무상태이지만, 사용자를 식별하거나 맞춤형 콘텐츠를 제공하려면 사용자 상태를 기억해야 합니다. HTTP는 이를 위해 쿠키(cookies)를 사용합니다(RFC 6265). 쿠키는 웹사이트가 각 사용자를 식별할 수 있게 해줍니다.

<img width="750" height="712" alt="Image" src="https://github.com/user-attachments/assets/c0350881-6c92-4b27-a7e8-b755780872ca" />

쿠키는 네 가지 요소로 구성됩니다:
1. HTTP 응답 메시지의 쿠키 헤더
2. HTTP 요청 메시지의 쿠키 헤더
3. 사용자 단말(브라우저)이 관리하는 쿠키 파일
4. 서버 측 데이터베이스

쿠키 동작 예시:
- 사용자가 처음 Amazon에 접속하면, 서버가 식별 번호를 만들고 데이터베이스에 저장합니다.
- 서버는 Set-cookie 헤더와 함께 응답을 보냅니다(예: Set-cookie: 1678).
- 브라우저는 이 값을 쿠키 파일에 저장합니다.
- 이후 Amazon을 탐색할 때마다 브라우저는 쿠키 값을 요청에 포함시킵니다(Cookie: 1678).
- 서버는 쿠키를 통해 사용자의 활동을 추적할 수 있습니다. 사용자가 계정을 만들면, 개인 정보를 쿠키 식별자와 연결할 수 있습니다.

쿠키는 사용자 편의를 높이지만, 프라이버시 침해 논란이 있습니다. 쿠키와 계정 정보를 결합하면, 사이트는 사용자의 행동을 파악하고, 제3자에게 정보를 팔 수도 있습니다.

## 2.2.5 웹 캐싱

<img width="681" height="464" alt="Image" src="https://github.com/user-attachments/assets/d521b51e-6754-4f06-92d9-110da69d23a8" />

웹 캐시(Web cache, 프록시 서버)는 원래의 웹 서버 대신 사용자의 HTTP 요청을 처리할 수 있는 네트워크 장치입니다. 캐시는 자체 저장 공간에 최근 요청된 웹 객체의 복사본을 저장합니다.

웹 캐시 동작 예시:
1. 브라우저가 웹 캐시에 HTTP 요청을 보냄
2. 캐시가 객체를 가지고 있으면 바로 응답
3. 없으면 원래 서버에 요청 후, 받은 객체를 저장하고 브라우저에 전달

<img width="674" height="784" alt="Image" src="https://github.com/user-attachments/assets/618fef09-ffc4-4ef0-969e-0633db91c67e" />

웹 캐시는 클라이언트와 서버 역할을 모두 합니다.

웹 캐시의 주요 목적:
- 클라이언트 요청 시간 단축(특히 캐시와 클라이언트 간 네트워크가 빠를 때)
- 기관(학교, 회사)의 인터넷 트래픽 감소(네트워크 비용 절감)

<img width="692" height="826" alt="Image" src="https://github.com/user-attachments/assets/f621ce1e-c315-4892-b601-ee79e5a8dbc0" />

예시: 기관 네트워크가 15Mbps 라인으로 인터넷에 연결되어 있고, 평균 객체 크기가 1Mbits, 초당 15개의 요청이 발생한다고 가정할 때, 전체 트래픽과 지연 시간은 병목 구간(접속 라인)에서 크게 늘어날 수 있습니다. 해결책은 라인 업그레이드(비용 높음) 또는 웹 캐시 설치(비용 저렴, 효과적)입니다.

캐시 적중률(hit rate)이 0.4라면, 40%의 요청은 캐시에서 즉시 처리(10ms 이내), 나머지 60%는 원래 서버로 전달됩니다. <br>
전체 지연 시간은 0.4×0.01초 + 0.6×2.01초 로 계산됩니다.

CDN(Content Distribution Network)의 등장으로 웹 캐시의 중요성은 더욱 커졌습니다. CDN은 여러 지역에 분산된 캐시를 설치해 트래픽을 분산시킵니다.

### 조건부 GET

캐시된 파일이 서버에서 변경될 수 있으므로, HTTP는 캐시가 파일이 최신인지 확인할 수 있는 조건부 요청(conditional GET) 기능을 제공합니다. 조건부 GET은 GET 메소드와 If-Modified-Since 헤더를 사용합니다.

예시:
1. 프록시 서버가 객체를 요청(GET /fruit/kiwi.gif)
2. 서버가 객체와 마지막 수정 날짜를 응답(Last-Modified)
3. 이후 다른 브라우저가 같은 객체를 요청하면, 캐시는 If-Modified-Since 헤더와 함께 조건부 요청을 보냄
4. 서버가 객체가 변경되지 않았으면 304 Not Modified로 응답(엔티티 바디 없음), 캐시는 기존 복사본을 브라우저에 전달

HTTP 메시지 형식, 캐시, 쿠키, 백엔드 데이터베이스 등은 모두 웹의 기본 인프라이며, HTTP 프로토콜에 포함된 다양한 방식으로 동작합니다.