## 6.2 오류 검출 및 정정 기술

이전 섹션에서 **비트 수준 오류 검출 및 정정(bit-level error detection and correction)** 에 대해 언급했습니다.
이는 물리적으로 연결된 한 노드에서 다른 인접 노드로 전송된 링크 계층 프레임의 비트 손상을 검출하고 정정하는 것으로, 링크 계층이 자주 제공하는 두 가지 서비스입니다.

3장에서 오류 검출 및 정정 서비스가 전송 계층에서도 제공된다는 것을 보았습니다.
이 섹션에서는 전송된 데이터의 오류를 검출하고, 일부 경우에는 정정하는 데 사용되는 가장 간단한 기술들을 살펴봅니다:
- **패리티 검사(parity checks)**: 오류 검출 및 정정의 기본 개념 설명
- **체크섬 방식(checksumming methods)**: 전송 계층에서 주로 사용
- **순환 중복 검사(cyclic redundancy checks)**: 링크 계층 어댑터에서 주로 사용

<img width="562" height="372" alt="Image" src="https://github.com/user-attachments/assets/b8536e07-2fea-405d-b3ae-578da37af9c3" />

### 오류 검출의 기본 원리

그림 6.3은 우리 학습의 설정을 보여줍니다.

**송신 노드**에서 비트 오류로부터 보호할 데이터 *D*는 **오류 검출 및 정정 비트(EDC)** 로 보강됩니다.
보호할 데이터에는 일반적으로 다음이 포함됩니다:
- 네트워크 계층에서 링크를 통해 전송하기 위해 전달된 데이터그램
- 링크 계층 주소 정보, 순서 번호
- 링크 프레임 헤더의 기타 필드

*D*와 *EDC* 모두 링크 수준 프레임으로 수신 노드에 전송됩니다.

**수신 노드**에서는 비트 시퀀스 *D'*와 *EDC'*를 수신합니다.
전송 중 비트 플립으로 인해 *D'*와 *EDC'*가 원래의 *D* 및 *EDC*와 다를 수 있습니다.

수신자의 과제는 *D'*와 *EDC'*만 수신한 상태에서 *D'*가 원래의 *D*와 같은지 결정하는 것입니다.

### 검출되지 않는 오류의 존재

오류 검출 및 정정 기술은 수신자가 **때때로, 하지만 항상은 아니게** 비트 오류가 발생했음을 검출할 수 있게 합니다.
오류 검출 비트를 사용하더라도 여전히 **검출되지 않는 비트 오류(undetected bit errors)** 가 있을 수 있습니다.

결과적으로 수신자가 손상된 데이터그램을 네트워크 계층에 전달하거나, 프레임 헤더의 필드 내용이 손상되었음을 인식하지 못할 수 있습니다.

따라서 이러한 경우의 확률을 작게 유지하는 오류 검출 체계를 선택해야 합니다.
일반적으로 더 정교한 오류 검출 및 정정 기술(검출되지 않는 비트 오류를 허용할 확률이 더 낮은 것들)은 더 큰 오버헤드를 발생시킵니다. 즉, 더 많은 계산과 더 많은 오류 검출 및 정정 비트 전송이 필요합니다.

---

## 6.2.1 패리티 검사 (Parity Checks)

오류 검출의 가장 간단한 형태는 단일 **패리티 비트(parity bit)** 를 사용하는 것입니다.

### 단일 비트 패리티

그림 6.4에서 전송할 정보 *D*가 *d* 비트라고 가정합니다.

<img width="433" height="151" alt="Image" src="https://github.com/user-attachments/assets/e4b145b4-1c57-4a80-9c38-f2c26b9a7ef2" />

**짝수 패리티(even parity) 방식**에서는:
- 송신자가 하나의 추가 비트를 포함
- *d + 1* 비트(원래 정보 + 패리티 비트)에서 1의 총 개수가 **짝수**가 되도록 패리티 비트 값을 선택

**홀수 패리티(odd parity) 방식**에서는:
- 1의 총 개수가 **홀수**가 되도록 패리티 비트 값을 선택

**수신자 동작**:
1. 수신된 *d + 1* 비트에서 1의 개수를 셈
2. 짝수 패리티 방식에서 1의 개수가 홀수이면 → 최소 하나의 비트 오류 발생 감지
3. 더 정확하게는, **홀수 개의 비트 오류**가 발생했음을 알 수 있음

### 짝수 개의 비트 오류 문제

만약 **짝수 개의 비트 오류**가 발생하면 어떻게 될까요?

비트 오류의 확률이 작고 오류가 비트마다 독립적으로 발생한다면, 패킷에서 여러 비트 오류가 발생할 확률은 매우 작습니다.
이 경우 단일 패리티 비트로 충분할 수 있습니다.

그러나 측정 결과에 따르면 오류는 독립적으로 발생하기보다 **"버스트(bursts)"로 함께 군집**되는 경향이 있습니다.
버스트 오류 조건에서 단일 비트 패리티로 보호된 프레임에서 검출되지 않는 오류의 확률은 **50%에 근접**할 수 있습니다.

따라서 실제로는 더 견고한 오류 검출 체계가 필요합니다.

### 2차원 패리티 (Two-dimensional Parity)

그림 6.5는 단일 비트 패리티 방식의 2차원 일반화를 보여줍니다.

<img width="495" height="431" alt="Image" src="https://github.com/user-attachments/assets/4579bc27-5d5c-4c92-94e7-b46eaa111377" />

*D*의 *d* 비트는 *i* 행과 *j* 열로 나뉩니다:
- 각 행에 대해 패리티 값 계산
- 각 열에 대해 패리티 값 계산
- 결과적으로 *i + j + 1* 개의 패리티 비트가 링크 계층 프레임의 오류 검출 비트를 구성

**단일 비트 오류 정정**:
원래 *d* 비트의 정보에서 단일 비트 오류가 발생하면, **2차원 패리티** 방식에서 뒤집힌 비트를 포함한 열과 행 모두의 패리티가 오류 상태가 됩니다.

수신자는:
1. 단일 비트 오류가 발생했음을 **검출**할 수 있음
2. 패리티 오류가 있는 열과 행의 인덱스를 사용하여 손상된 비트를 **식별**하고 **정정**할 수 있음

그림 6.5는 위치 (2,2)의 1값 비트가 손상되어 0으로 바뀐 예시를 보여줍니다. 이 오류는 검출 가능하고 정정 가능합니다.

**2차원 패리티의 능력**:
- 원래 *d* 비트 정보의 단일 오류뿐만 아니라 패리티 비트 자체의 단일 오류도 검출 및 정정 가능
- 패킷의 **두 비트 오류의 모든 조합**을 검출 가능 (정정은 불가)

### 순방향 오류 정정 (FEC)

수신자가 오류를 검출하고 정정하는 능력을 **순방향 오류 정정(FEC, Forward Error Correction)** 이라고 합니다.

FEC 기술은 **오디오 저장 장치**와 **오디오 CD와 같은 재생 장치**에서 흔히 사용됩니다.

네트워크 환경에서 FEC 기술의 장점:
- 단독으로 사용하거나 링크 계층 ARQ 기술과 함께 사용 가능
- 송신자 재전송 횟수를 줄일 수 있어 가치 있음
- 더 중요하게는 수신자에서 **오류의 즉각적인 정정**이 가능
- NAK 패킷을 받고 재전송 패킷이 수신자에게 전파되는 왕복 전파 지연을 기다릴 필요 없음
- **실시간 네트워크 애플리케이션**이나 **긴 전파 지연을 가진 링크(예: 심우주 링크)** 에서 특히 중요한 장점

---

## 6.2.2 체크섬 방식 (Checksumming Methods)

체크섬 기술에서는 그림 6.4의 *d* 비트 데이터를 *k* 비트 정수의 시퀀스로 취급합니다.

### 인터넷 체크섬

간단한 체크섬 방식 중 하나는 이러한 *k* 비트 정수들을 단순히 합산하고 결과 합을 오류 검출 비트로 사용하는 것입니다.

**인터넷 체크섬(Internet checksum)** 은 이 접근법을 기반으로 합니다:
- 데이터의 바이트가 16비트 정수로 취급되고 합산됨
- 이 합의 1의 보수가 세그먼트 헤더에 포함되는 인터넷 체크섬을 형성

섹션 3.3에서 설명한 대로, 수신자는:
1. 수신된 데이터(체크섬 포함)의 합의 1의 보수를 취함
2. 결과가 모두 0 비트인지 확인
3. 비트 중 하나라도 1이면 오류가 표시됨

RFC 1071은 인터넷 체크섬 알고리즘과 그 구현을 상세히 설명합니다.

**TCP와 UDP 프로토콜**에서 인터넷 체크섬은 모든 필드(헤더와 데이터 필드 포함)에 대해 계산됩니다.
**IP**에서는 체크섬이 IP 헤더에 대해 계산됩니다(UDP나 TCP 세그먼트는 자체 체크섬을 가지므로).

### 체크섬의 한계

체크섬 방식은 비교적 **적은 패킷 오버헤드**를 필요로 합니다.
예를 들어, TCP와 UDP의 체크섬은 단 **16비트**만 사용합니다.

그러나 아래에서 설명하고 링크 계층에서 자주 사용되는 **순환 중복 검사(CRC)** 와 비교하면 오류에 대해 상대적으로 **약한 보호**를 제공합니다.

### 전송 계층 vs 링크 계층의 오류 검출

자연스러운 질문: 전송 계층에서는 체크섬을 사용하고 링크 계층에서는 CRC를 사용하는 이유는 무엇일까요?

**전송 계층**:
- 일반적으로 호스트의 운영체제 일부로 **소프트웨어로 구현**
- 전송 계층 오류 검출이 소프트웨어로 구현되므로, 체크섬과 같은 **단순하고 빠른 오류 검출 체계**가 중요

**링크 계층**:
- 어댑터의 전용 **하드웨어로 구현**
- 더 복잡한 CRC 연산을 빠르게 수행 가능

---

## 6.2.3 순환 중복 검사 (CRC)

오늘날 컴퓨터 네트워크에서 널리 사용되는 오류 검출 기술은 **순환 중복 검사(CRC, Cyclic Redundancy Check) 코드**를 기반으로 합니다.

CRC 코드는 **다항식 코드(polynomial codes)** 라고도 불립니다.
이는 전송할 비트 문자열을 계수가 0과 1인 다항식으로 볼 수 있고, 비트 문자열에 대한 연산이 다항식 산술로 해석되기 때문입니다.

<img width="505" height="165" alt="Image" src="https://github.com/user-attachments/assets/19a1998b-9d24-4c24-abe7-0e3e9e2c8d1b" />

### CRC 코드의 동작 원리

송신 노드가 *d* 비트 데이터 *D*를 수신 노드로 보내려 한다고 가정합니다.

송신자와 수신자는 먼저 **생성자(generator)** 라고 알려진 *r + 1* 비트 패턴 *G*에 동의해야 합니다.
*G*의 최상위(가장 왼쪽) 비트는 1이어야 합니다.

**CRC 코드의 핵심 아이디어**:
주어진 데이터 *D*에 대해, 송신자는 *r*개의 추가 비트 *R*을 선택하여 *D*에 추가합니다.
결과 *d + r* 비트 패턴(이진수로 해석)이 *G*로 **정확히 나누어 떨어지도록** (즉, 나머지가 없도록) 합니다.

**오류 검사 과정**:
1. 수신자는 수신된 *d + r* 비트를 *G*로 나눔
2. 나머지가 0이 아니면 → 오류 발생
3. 나머지가 0이면 → 데이터가 올바른 것으로 수락

### 모듈로-2 산술

모든 CRC 계산은 **모듈로-2 산술**로 수행됩니다.
덧셈에서 올림이 없고 뺄셈에서 빌림이 없습니다.

이는 덧셈과 뺄셈이 동일하며, 둘 다 피연산자의 **비트별 XOR(exclusive-or)** 과 동등합니다.

예시:
```
1011 XOR 0101 = 1110
1001 XOR 1101 = 0100
```

마찬가지로:
```
1011 - 0101 = 1110
1001 - 1101 = 0100
```

곱셈과 나눗셈은 2진 산술과 동일하지만, 필요한 덧셈이나 뺄셈은 올림이나 빌림 없이 수행됩니다.

### R 값 계산

*R*을 찾기 위해 다음 조건을 만족해야 합니다:

$$D \cdot 2^r \text{ XOR } R = nG$$

즉, *G*가 *D · 2^r* XOR *R*을 나머지 없이 나누도록 하는 *R*을 선택합니다.

위 방정식의 양변에 *R*을 XOR하면 (모듈로-2, 즉 올림 없이 더하면):

$$D \cdot 2^r = nG \text{ XOR } R$$

이 방정식은 *D · 2^r*을 *G*로 나누면 나머지 값이 정확히 *R*임을 알려줍니다.

따라서 *R*은 다음과 같이 계산할 수 있습니다:

$$R = \text{remainder} \frac{D \cdot 2^r}{G}$$

### CRC 계산 예시

<img width="425" height="325" alt="Image" src="https://github.com/user-attachments/assets/ccecaa7a-f6e8-45b1-bded-c5f2dce37175" />

그림 6.7은 다음 경우의 계산을 보여줍니다:
- *D* = 101110
- *d* = 6
- *G* = 1001
- *r* = 3

이 경우 전송되는 9비트는 **101110 011**입니다.

직접 계산을 확인해볼 수 있습니다:
- *D · 2^r* = 101110 000
- 실제로 *D · 2^r* = 101011 · *G* XOR *R* 임을 확인

### CRC 표준

국제 표준은 8, 12, 16, 32비트 생성자에 대해 정의되어 있습니다.

**CRC-32 32비트 표준**은 여러 링크 수준 IEEE 프로토콜에서 채택되었으며, 다음 생성자를 사용합니다:

$$G_{CRC-32} = 100000100110000010001110110110111$$

### CRC의 오류 검출 능력

각 CRC 표준은 **r + 1 비트 미만의 버스트 오류**를 검출할 수 있습니다.
(즉, *r* 비트 이하의 모든 연속적인 비트 오류가 검출됩니다.)

또한 적절한 가정 하에서:
- *r + 1* 비트보다 긴 버스트는 **1 - 0.5^r** 의 확률로 검출
- 각 CRC 표준은 **모든 홀수 개의 비트 오류**를 검출 가능

CRC 코드의 이론과 더 강력한 코드에 대한 자세한 내용은 이 텍스트의 범위를 벗어납니다.
