## 6.3 다중 접속 링크와 프로토콜

이 장의 도입부에서 두 가지 유형의 네트워크 링크가 있다고 언급했습니다:
- **점대점 링크(point-to-point link)**: 링크의 한쪽 끝에 단일 송신자, 다른 쪽 끝에 단일 수신자가 있는 구조. 많은 링크 계층 프로토콜이 점대점 링크용으로 설계됨 (PPP, 점대점 HDLC 등)
- **브로드캐스트 링크(broadcast link)**: 여러 송신 및 수신 노드가 동일한 단일 공유 브로드캐스트 채널에 모두 연결된 구조

**브로드캐스트(broadcast)** 라는 용어는 한 노드가 프레임을 전송하면 채널이 그 프레임을 브로드캐스트하여 다른 모든 노드가 해당 프레임의 사본을 수신하기 때문에 사용됩니다.

<img width="525" height="444" alt="Image" src="https://github.com/user-attachments/assets/3f0a5e9b-fe69-4b72-82c2-2e872c3ec641" />

### 다중 접속 문제

모든 노드가 프레임을 전송할 수 있으므로, 둘 이상의 노드가 동시에 프레임을 전송할 수 있습니다.
이 경우 모든 노드가 동시에 여러 프레임을 수신하게 됩니다. 즉, 전송된 프레임들이 모든 수신자에서 **충돌(collide)** 합니다.

일반적으로 충돌이 발생하면 수신 노드 중 어느 것도 전송된 프레임의 내용을 이해할 수 없습니다.
충돌하는 프레임의 신호가 서로 뒤엉켜 버리기 때문입니다.

따라서 충돌에 관련된 모든 프레임은 손실되고, 충돌 간격 동안 브로드캐스트 채널이 낭비됩니다.
많은 노드가 자주 프레임을 전송하려 하면 많은 전송이 충돌로 이어지고, 브로드캐스트 채널의 대역폭 대부분이 낭비됩니다.

### 다중 접속 프로토콜의 역할

브로드캐스트 채널이 여러 활성 노드가 있을 때 유용한 작업을 수행하도록 하려면, 활성 노드들의 전송을 조정하는 것이 필요합니다.
이 조정 작업은 **다중 접속 프로토콜(multiple access protocol)** 의 책임입니다.

지난 40년간 수천 개의 논문과 수백 편의 박사 논문이 다중 접속 프로토콜에 대해 작성되었습니다.
또한 새로운 유형의 링크, 특히 새로운 무선 링크의 지속적인 출현으로 인해 다중 접속 프로토콜에 대한 연구가 계속되고 있습니다.

### 다중 접속 프로토콜의 분류

수십 가지의 다중 접속 프로토콜이 다양한 링크 계층 기술에서 구현되었습니다.
그럼에도 불구하고, 거의 모든 다중 접속 프로토콜은 다음 세 가지 범주 중 하나로 분류할 수 있습니다:

1. **채널 분할 프로토콜 (Channel Partitioning Protocols)**
2. **랜덤 접속 프로토콜 (Random Access Protocols)**
3. **순번 프로토콜 (Taking-Turns Protocols)**

### 이상적인 다중 접속 프로토콜의 특성

*R* bps의 브로드캐스트 채널에 대한 다중 접속 프로토콜은 이상적으로 다음과 같은 바람직한 특성을 가져야 합니다:

1. **단일 노드 활성 시**: 해당 노드가 *R* bps의 처리량을 가짐
2. **M개 노드 활성 시**: 각 노드가 평균 *R/M* bps의 처리량을 가짐 (반드시 순간적으로 *R/M*일 필요는 없고, 적절히 정의된 시간 간격 동안 평균적으로)
3. **분산화**: 네트워크의 단일 장애 지점이 되는 마스터 노드가 없음
4. **단순성**: 구현 비용이 저렴함

---

## 6.3.1 채널 분할 프로토콜 (Channel Partitioning Protocols)

섹션 1.3에서 **시분할 다중화(TDM, Time-Division Multiplexing)** 와 **주파수 분할 다중화(FDM, Frequency-Division Multiplexing)** 가 브로드캐스트 채널의 대역폭을 공유하는 모든 노드에게 분할하는 데 사용될 수 있는 두 가지 기술임을 언급했습니다.

<img width="477" height="344" alt="Image" src="https://github.com/user-attachments/assets/0ba3163f-4d71-4cd1-8d63-9455eb0b5368" />

### TDM (시분할 다중화)

채널이 *N*개 노드를 지원하고 전송률이 *R* bps라고 가정합니다.

TDM은 시간을 **타임 프레임(time frames)** 으로 나누고, 각 타임 프레임을 *N*개의 **타임 슬롯(time slots)** 으로 더 나눕니다.
(TDM 타임 프레임은 송수신 어댑터 간에 교환되는 링크 계층 데이터 단위인 프레임과 혼동하지 말 것)

각 타임 슬롯은 *N*개 노드 중 하나에 할당됩니다.
노드가 보낼 패킷이 있으면, 회전하는 TDM 프레임에서 할당된 타임 슬롯 동안 패킷의 비트를 전송합니다.

**TDM의 장점**:
- 충돌을 제거하고 완벽하게 공평함
- 각 노드가 각 프레임 시간 동안 *R/N* bps의 전용 전송률을 얻음

**TDM의 단점**:
1. 유일하게 보낼 패킷이 있는 노드라도 평균 *R/N* bps의 속도로 제한됨
2. 노드는 전송 순서에서 자신의 차례가 올 때까지 항상 기다려야 함 (유일하게 보낼 프레임이 있는 노드라도)

### FDM (주파수 분할 다중화)

TDM이 브로드캐스트 채널을 시간으로 공유하는 반면, FDM은 *R* bps 채널을 서로 다른 주파수로 나눕니다.
각 주파수는 *R/N*의 대역폭을 가지며, *N*개 노드 중 하나에 각 주파수가 할당됩니다.

FDM은 따라서 단일 큰 *R* bps 채널에서 *N*개의 작은 *R/N* bps 채널을 만듭니다.

**FDM의 장단점**:
- TDM과 마찬가지로 충돌을 피하고 *N*개 노드 간에 대역폭을 공평하게 나눔
- TDM과 공유하는 주요 단점: 유일하게 보낼 패킷이 있는 노드라도 *R/N*의 대역폭으로 제한됨

### CDMA (코드 분할 다중 접속)

세 번째 채널 분할 프로토콜은 **코드 분할 다중 접속(CDMA, Code Division Multiple Access)** 입니다.

TDM과 FDM이 각각 타임 슬롯과 주파수를 노드에 할당하는 반면, CDMA는 각 노드에 다른 **코드(code)** 를 할당합니다.
각 노드는 고유한 코드를 사용하여 전송하는 데이터 비트를 인코딩합니다.

코드가 신중하게 선택되면, CDMA 네트워크는 다른 노드의 간섭하는 전송에도 불구하고 서로 다른 노드가 **동시에** 전송할 수 있으며, 각각의 수신자가 송신자의 인코딩된 데이터 비트를 올바르게 수신할 수 있습니다 (수신자가 송신자의 코드를 알고 있다고 가정).

CDMA는 군사 시스템에서 사용되어 왔으며 (재밍 방지 특성 때문에), 이제 민간용으로, 특히 **셀룰러 전화**에서 널리 사용됩니다.
CDMA 사용이 무선 채널과 밀접하게 연결되어 있으므로, CDMA의 기술적 세부 사항은 7장까지 미룹니다.

---

## 6.3.2 랜덤 접속 프로토콜 (Random Access Protocols)

다중 접속 프로토콜의 두 번째 광범위한 클래스는 **랜덤 접속 프로토콜**입니다.

랜덤 접속 프로토콜에서 전송 노드는 항상 채널의 전체 속도인 *R* bps로 전송합니다.
충돌이 발생하면, 충돌에 관련된 각 노드는 충돌 없이 프레임이 통과할 때까지 프레임을 반복적으로 재전송합니다.

그러나 노드가 충돌을 경험하면 반드시 바로 프레임을 재전송하지는 않습니다.
대신 **프레임을 재전송하기 전에 랜덤 지연 시간을 기다립니다**.

충돌에 관련된 각 노드는 독립적인 랜덤 지연을 선택합니다.
랜덤 지연이 독립적으로 선택되기 때문에, 충돌하는 노드 중 하나가 다른 노드들의 지연보다 충분히 짧은 지연을 선택하여 충돌 없이 채널에 프레임을 끼워 넣을 수 있습니다.

문헌에 설명된 랜덤 접속 프로토콜은 수십 개가 있습니다.
이 섹션에서는 가장 일반적으로 사용되는 랜덤 접속 프로토콜 몇 가지를 설명합니다:
- **ALOHA 프로토콜**
- **반송파 감지 다중 접속(CSMA) 프로토콜**

이더넷은 인기 있고 널리 배포된 CSMA 프로토콜입니다.

### 슬롯 ALOHA (Slotted ALOHA)

가장 간단한 랜덤 접속 프로토콜 중 하나인 슬롯 ALOHA 프로토콜로 시작합니다.

슬롯 ALOHA에서는 다음을 가정합니다:
- 모든 프레임은 정확히 *L* 비트로 구성
- 시간은 *L/R* 초 크기의 슬롯으로 나뉨 (즉, 슬롯은 하나의 프레임을 전송하는 시간과 같음)
- 노드는 슬롯의 시작에서만 프레임 전송을 시작
- 노드들은 슬롯이 언제 시작하는지 알도록 동기화됨
- 두 개 이상의 프레임이 한 슬롯에서 충돌하면, 모든 노드가 슬롯이 끝나기 전에 충돌 이벤트를 감지

*p*를 0과 1 사이의 확률이라고 하면, 각 노드에서 슬롯 ALOHA의 동작은 단순합니다:

- 노드가 보낼 새 프레임이 있으면, 다음 슬롯의 시작까지 기다렸다가 슬롯에서 전체 프레임을 전송
- 충돌이 없으면, 노드는 프레임을 성공적으로 전송했으므로 프레임 재전송을 고려할 필요 없음
- 충돌이 있으면, 노드는 슬롯이 끝나기 전에 충돌을 감지. 노드는 충돌 없이 프레임이 전송될 때까지 각 후속 슬롯에서 확률 *p*로 프레임을 재전송

<img width="524" height="355" alt="Image" src="https://github.com/user-attachments/assets/2e7b33ee-f6fe-4d0c-8834-33dca9fb3c8b" />

**슬롯 ALOHA의 장점**:
- 유일하게 활성인 노드일 때 전체 속도 *R*로 연속 전송 가능
- 고도로 분산화됨 (각 노드가 충돌을 감지하고 독립적으로 재전송 결정)
- 슬롯 동기화 필요하지만, 매우 간단한 프로토콜

**슬롯 ALOHA의 효율성**:

여러 활성 노드가 있을 때, 일부 슬롯은 충돌로 "낭비"되고, 다른 일부 슬롯은 모든 활성 노드가 확률적 전송 정책의 결과로 전송을 자제하여 *비어* 있습니다.

정확히 하나의 노드만 전송하는 슬롯을 **성공적인 슬롯(successful slot)** 이라고 합니다.
슬롯 다중 접속 프로토콜의 **효율성(efficiency)** 은 많은 활성 노드가 있고, 각각이 항상 보낼 프레임이 많을 때 성공적인 슬롯의 장기 비율로 정의됩니다.

*N*개 활성 노드가 있을 때, 슬롯 ALOHA의 효율성은 *Np(1 - p)^(N-1)* 입니다.

*N*개 활성 노드에 대한 **최대 효율성**을 얻으려면 이 표현식을 최대화하는 *p\**를 찾아야 합니다.
많은 수의 활성 노드에 대한 최대 효율성을 얻기 위해 *N*이 무한대로 접근할 때 *Np\*(1 - p\*)^(N-1)*의 극한을 취하면:

$$\text{최대 효율성} = \frac{1}{e} = 0.37$$

즉, 많은 수의 노드가 전송할 프레임이 많을 때, 최선의 경우에도 **슬롯의 37%만이 유용한 작업**을 수행합니다.
따라서 채널의 유효 전송률은 *R* bps가 아니라 **0.37R** bps에 불과합니다!

### 순수 ALOHA (Pure ALOHA)

슬롯 ALOHA 프로토콜은 모든 노드가 슬롯의 시작에서 전송을 시작하도록 동기화해야 합니다.

최초의 ALOHA 프로토콜 [Abramson 1970]은 실제로 슬롯이 없는, 완전히 분산화된 프로토콜이었습니다.

**순수 ALOHA**에서는 프레임이 네트워크 계층에서 처음 도착하면 (즉, 송신 노드에서 네트워크 계층 데이터그램이 전달되면), 노드는 즉시 프레임 전체를 브로드캐스트 채널로 전송합니다.

전송된 프레임이 하나 이상의 다른 전송과 충돌을 경험하면, 노드는 즉시 (충돌한 프레임을 완전히 전송한 후) 확률 *p*로 프레임을 재전송합니다.
그렇지 않으면 노드는 프레임 전송 시간 동안 기다린 후 확률 *p*로 프레임을 전송하거나, 확률 *1 - p*로 또 다른 프레임 시간 동안 유휴 상태로 대기합니다.

<img width="498" height="258" alt="Image" src="https://github.com/user-attachments/assets/0945b987-b745-45c2-b2a7-ffea5c0b7e44" />

**순수 ALOHA의 최대 효율성**:

순수 ALOHA 프로토콜의 최대 효율성은 **1/(2e) = 0.18**로, 슬롯 ALOHA의 정확히 절반입니다.
이것이 완전히 분산화된 ALOHA 프로토콜에 대해 지불해야 하는 대가입니다.

---

### 반송파 감지 다중 접속 (CSMA)

슬롯 ALOHA와 순수 ALOHA 모두에서 노드의 전송 결정은 브로드캐스트 채널에 연결된 다른 노드의 활동과 독립적으로 이루어집니다.
특히, 노드는 전송을 시작할 때 다른 노드가 전송 중인지 주의를 기울이지 않으며, 다른 노드가 자신의 전송과 간섭하기 시작해도 전송을 중단하지 않습니다.

칵테일 파티 비유에서, ALOHA 프로토콜은 다른 사람들이 말하고 있는지 여부와 관계없이 계속 떠드는 무례한 파티 참석자와 같습니다.

인간으로서 우리는 예의 바르게 행동할 뿐만 아니라 대화에서 "충돌"하는 시간을 줄이고, 결과적으로 데이터 교환량을 늘리는 프로토콜을 가지고 있습니다.
구체적으로, 예의 바른 인간 대화에는 두 가지 중요한 규칙이 있습니다:

- **말하기 전에 듣기**: 다른 사람이 말하고 있으면, 그들이 끝날 때까지 기다림. 네트워킹 세계에서 이를 **반송파 감지(carrier sensing)** 라고 함 - 노드가 전송하기 전에 채널을 청취. 다른 노드의 프레임이 현재 채널로 전송되고 있으면, 노드는 일정 시간 동안 전송이 없음을 감지할 때까지 기다린 후 전송을 시작

- **다른 사람이 동시에 말하기 시작하면, 말하기 중단**: 네트워킹 세계에서 이를 **충돌 감지(collision detection)** 라고 함 - 전송 노드가 전송하는 동안 채널을 청취. 다른 노드가 간섭하는 프레임을 전송하고 있음을 감지하면, 전송을 중단하고 감지-전송-유휴시-대기 사이클을 반복하기 전에 랜덤 시간 동안 대기

이 두 규칙은 **반송파 감지 다중 접속(CSMA, Carrier Sense Multiple Access)** 과 **충돌 감지를 포함한 CSMA(CSMA/CD, CSMA with Collision Detection)** 프로토콜 계열에 구현되어 있습니다.

### CSMA에서 충돌이 발생하는 이유

모든 노드가 반송파 감지를 수행한다면, 왜 충돌이 처음에 발생할까요?
결국, 노드는 다른 노드가 전송 중임을 감지하면 전송을 자제할 것입니다.

<img width="488" height="494" alt="Image" src="https://github.com/user-attachments/assets/7ead2047-5694-4609-948a-da7a340ca127" />

그림 6.12는 선형 브로드캐스트 버스에 연결된 네 개의 노드(A, B, C, D)의 시공간 다이어그램을 보여줍니다.
수평 축은 공간에서 각 노드의 위치를 나타내고, 수직 축은 시간을 나타냅니다.

시간 *t₀*에서 노드 B는 다른 노드가 현재 전송하지 않으므로 채널이 유휴 상태임을 감지합니다.
따라서 노드 B는 전송을 시작하며, 비트가 브로드캐스트 매체를 따라 양방향으로 전파됩니다.

시간 *t₁* (*t₁ > t₀*)에서, 노드 D가 보낼 프레임이 있습니다.
노드 B가 현재 시간 *t₁*에서 전송 중이지만, B가 전송한 비트는 아직 D에 도달하지 않았으므로 D는 채널이 유휴 상태라고 감지합니다.
CSMA 프로토콜에 따라 D는 프레임 전송을 시작합니다.
잠시 후, B의 전송이 D의 전송과 간섭하기 시작합니다.

그림 6.12에서 명확히 알 수 있듯이, 브로드캐스트 채널의 종단 간 **채널 전파 지연(channel propagation delay)** — 신호가 한 노드에서 다른 노드로 전파되는 데 걸리는 시간 — 이 성능 결정에 중요한 역할을 합니다.
전파 지연이 길수록, 반송파 감지 노드가 네트워크의 다른 노드에서 이미 시작된 전송을 감지하지 못할 가능성이 높아집니다.

### 충돌 감지를 포함한 CSMA (CSMA/CD)

그림 6.12에서 노드들은 충돌 감지를 수행하지 않습니다. B와 D 모두 충돌이 발생했음에도 프레임 전체를 전송합니다.

노드가 충돌 감지를 수행하면, 충돌을 감지하는 즉시 전송을 중단합니다.
그림 6.13은 두 노드가 충돌을 감지한 후 짧은 시간 후에 각각 전송을 중단하는 동일한 시나리오를 보여줍니다.

<img width="497" height="457" alt="Image" src="https://github.com/user-attachments/assets/f8a3747f-449d-4549-a505-e0b72522ebf6" />

명확히, 다중 접속 프로토콜에 충돌 감지를 추가하면 쓸모없고 손상된 (다른 노드의 프레임과의 간섭으로 인해) 프레임을 전체 전송하지 않음으로써 프로토콜 성능에 도움이 됩니다.

### CSMA/CD의 동작

브로드캐스트 채널에 연결된 노드의 어댑터 관점에서 CSMA/CD 동작을 요약합니다:

1. 어댑터가 네트워크 계층에서 데이터그램을 얻고, 링크 계층 프레임을 준비하여 프레임 어댑터 버퍼에 넣음
2. 어댑터가 채널이 유휴 상태임을 감지하면 (즉, 채널에서 어댑터로 들어오는 신호 에너지가 없으면), 프레임 전송을 시작. 반면 채널이 사용 중이면 신호 에너지가 없을 때까지 기다린 후 프레임 전송 시작
3. 전송하는 동안, 어댑터는 브로드캐스트 채널을 사용하는 다른 어댑터로부터의 신호 에너지 존재를 모니터링
4. 어댑터가 다른 어댑터로부터의 신호 에너지를 감지하지 않고 전체 프레임을 전송하면, 어댑터는 프레임 전송을 완료. 반면 전송 중 다른 어댑터로부터의 신호 에너지를 감지하면, 전송을 중단 (즉, 프레임 전송 중지)
5. 중단 후, 어댑터는 랜덤 시간 동안 기다린 후 단계 2로 돌아감

### 이진 지수 백오프 (Binary Exponential Backoff)

랜덤 (고정이 아닌) 시간 동안 기다려야 하는 필요성은 분명합니다.
두 노드가 동시에 프레임을 전송하고 둘 다 같은 고정 시간 동안 기다리면, 영원히 충돌을 계속할 것입니다.

그러나 랜덤 백오프 시간을 선택할 적절한 간격은 무엇일까요?
- 간격이 크고 충돌하는 노드 수가 적으면, 노드들은 감지-전송-유휴시-대기 단계를 반복하기 전에 많은 시간을 기다릴 가능성이 높음 (채널이 유휴 상태로 남아 있는 동안)
- 간격이 작고 충돌하는 노드 수가 많으면, 선택된 랜덤 값들이 거의 같아서 전송하는 노드들이 다시 충돌할 가능성이 높음

**이진 지수 백오프(binary exponential backoff)** 알고리즘은 이더넷과 DOCSIS 케이블 네트워크 다중 접속 프로토콜에서 사용되며, 이 문제를 우아하게 해결합니다.

구체적으로, 이미 *n*번의 충돌을 경험한 프레임을 전송할 때, 노드는 {0, 1, 2, ..., 2^n - 1}에서 랜덤하게 *K* 값을 선택합니다.
따라서 프레임이 경험한 충돌이 많을수록, *K*가 선택되는 간격이 커집니다.

이더넷의 경우, 노드가 기다리는 실제 시간은 K × 512 비트 시간입니다.
(즉, 512 비트를 이더넷으로 전송하는 데 필요한 시간의 K배)
*n*이 취할 수 있는 최대값은 10으로 제한됩니다.

**예시**:
- 노드가 처음으로 프레임을 전송하고 충돌을 감지하면, *K* = 0 (확률 0.5) 또는 *K* = 1 (확률 0.5)을 선택
- *K* = 0이면 즉시 채널 감지 시작
- *K* = 1이면 512 비트 시간을 기다림 (예: 100 Mbps 이더넷에서 5.12 마이크로초)
- 두 번째 충돌 후, *K*는 {0, 1, 2, 3}에서 동일한 확률로 선택
- 세 번째 충돌 후, *K*는 {0, 1, 2, 3, 4, 5, 6, 7}에서 선택
- 10번 이상의 충돌 후, *K*는 {0, 1, 2, ..., 1023}에서 선택

### CSMA/CD 효율성

단 하나의 노드만 보낼 프레임이 있을 때, 노드는 전체 채널 속도로 전송할 수 있습니다 (예: 이더넷 일반적인 속도는 10 Mbps, 100 Mbps, 또는 1 Gbps).

그러나 많은 노드가 전송할 프레임이 있으면, 채널의 유효 전송률은 훨씬 낮아질 수 있습니다.

**CSMA/CD의 효율성**은 많은 활성 노드가 있고, 각 노드가 보낼 프레임이 많을 때 충돌 없이 채널에서 프레임이 전송되는 시간의 장기 비율로 정의됩니다.

CSMA/CD의 효율성에 대한 근사식은 다음과 같습니다:

$$\text{효율성} = \frac{1}{1 + 5d_{prop}/d_{trans}}$$

여기서:
- *d_prop* = 두 어댑터 간 신호 에너지가 전파되는 최대 시간
- *d_trans* = 최대 크기 프레임을 전송하는 시간 (10 Mbps 이더넷에서 약 1.2 msec)

이 공식에서:
- *d_prop*이 0에 접근하면, 효율성은 1에 접근 (전파 지연이 0이면 충돌하는 노드가 채널을 낭비하지 않고 즉시 중단)
- *d_trans*가 매우 커지면, 효율성도 1에 접근 (프레임이 채널을 오랫동안 점유하면 채널이 대부분의 시간 동안 생산적인 작업 수행)

---

## 6.3.3 순번 프로토콜 (Taking-Turns Protocols)

다중 접속 프로토콜의 두 가지 바람직한 특성을 상기하면:
1. 단 하나의 노드만 활성일 때, 활성 노드가 *R* bps의 처리량을 가짐
2. *M*개 노드가 활성일 때, 각 활성 노드가 거의 *R/M* bps의 처리량을 가짐

ALOHA와 CSMA 프로토콜은 첫 번째 특성을 가지지만 두 번째는 아닙니다.
이것이 연구자들에게 또 다른 클래스의 프로토콜인 **순번 프로토콜(taking-turns protocols)** 을 만들도록 동기를 부여했습니다.

랜덤 접속 프로토콜과 마찬가지로 수십 개의 순번 프로토콜이 있으며, 각각 많은 변형이 있습니다.
여기서는 두 가지 중요한 프로토콜을 논의합니다.

### 폴링 프로토콜 (Polling Protocol)

**폴링 프로토콜**은 노드 중 하나가 **마스터 노드**로 지정되도록 요구합니다.
마스터 노드는 라운드 로빈 방식으로 각 노드를 **폴링(poll)** 합니다.

특히, 마스터 노드는 먼저 노드 1에게 메시지를 보내어 최대 일정 수의 프레임까지 전송할 수 있다고 알립니다.
노드 1이 일부 프레임을 전송한 후, 마스터 노드는 노드 2에게 최대 일정 수의 프레임을 전송할 수 있다고 알립니다.
(마스터 노드는 채널의 신호 부재를 관찰하여 노드가 프레임 전송을 완료했는지 확인할 수 있습니다.)

이 절차는 계속되며, 마스터 노드가 각 노드를 순환적으로 폴링합니다.

**폴링 프로토콜의 장점**:
- 랜덤 접속 프로토콜을 괴롭히는 충돌과 빈 슬롯을 제거
- 훨씬 높은 효율성 달성 가능

**폴링 프로토콜의 단점**:
1. **폴링 지연(polling delay)** 도입 - 노드에게 전송할 수 있음을 알리는 데 필요한 시간. 예를 들어, 단 하나의 노드만 활성이면, 그 노드는 *R* bps 미만의 속도로 전송 (마스터 노드가 각 비활성 노드를 순서대로 폴링해야 하므로)
2. 마스터 노드가 실패하면, 전체 채널이 작동 불능 상태가 됨

블루투스 프로토콜(섹션 6.3에서 학습)은 폴링 프로토콜의 예입니다.

### 토큰 전달 프로토콜 (Token-Passing Protocol)

두 번째 순번 프로토콜은 **토큰 전달 프로토콜**입니다.
이 프로토콜에는 마스터 노드가 없습니다.

**토큰(token)** 이라고 알려진 작은 특수 목적 프레임이 고정된 순서로 노드들 사이에서 교환됩니다.
예를 들어, 노드 1은 항상 노드 2에게 토큰을 보내고, 노드 2는 항상 노드 3에게 토큰을 보내고, 노드 N은 항상 노드 1에게 토큰을 보냅니다.

노드가 토큰을 받으면, 전송할 프레임이 있을 때만 토큰을 유지합니다.
그렇지 않으면 즉시 토큰을 다음 노드로 전달합니다.
노드가 전송할 프레임이 있을 때 토큰을 받으면, 최대 일정 수의 프레임까지 전송한 후 토큰을 다음 노드로 전달합니다.

**토큰 전달의 장점**:
- 분산화되어 있고 매우 효율적

**토큰 전달의 단점**:
1. 한 노드의 실패가 전체 채널을 마비시킬 수 있음
2. 노드가 실수로 토큰을 해제하지 않으면, 토큰을 다시 순환시키기 위한 복구 절차가 필요

토큰 전달 프로토콜의 예:
- **FDDI(Fiber Distributed Data Interface)** 프로토콜
- **IEEE 802.5 토큰 링** 프로토콜

---

## 6.3.4 DOCSIS: 케이블 인터넷 접속을 위한 링크 계층 프로토콜

이전 세 하위 섹션에서 세 가지 광범위한 다중 접속 프로토콜 클래스에 대해 배웠습니다:
- 채널 분할 프로토콜
- 랜덤 접속 프로토콜
- 순번 프로토콜

**케이블 접속 네트워크**는 이 세 가지 다중 접속 프로토콜 클래스 각각의 측면을 찾을 수 있는 훌륭한 사례 연구입니다!

<img width="547" height="328" alt="Image" src="https://github.com/user-attachments/assets/c725e676-95cf-4b9c-b305-362856408496" />

섹션 1.2.1에서 케이블 접속 네트워크가 일반적으로 수천 개의 가정용 케이블 모뎀을 케이블 네트워크 헤드엔드의 **케이블 모뎀 종단 시스템(CMTS, Cable Modem Termination System)** 에 연결한다는 것을 상기합니다.

**DOCSIS(Data-Over-Cable Service Interface Specifications)** 는 케이블 데이터 네트워크 아키텍처와 프로토콜을 지정합니다.

### 다운스트림 채널

DOCSIS는 **FDM**을 사용하여 다운스트림(CMTS에서 모뎀으로)과 업스트림(모뎀에서 CMTS로) 네트워크 세그먼트를 여러 주파수 채널로 나눕니다.

- 각 다운스트림 채널은 24 MHz와 192 MHz 사이로, 채널당 최대 약 **1.6 Gbps**의 처리량
- 각 업스트림 채널 너비는 6.4 MHz에서 96 MHz 범위로, 최대 약 **1 Gbps**의 업스트림 처리량

다운스트림 채널로 CMTS가 전송한 프레임은 해당 채널의 모든 케이블 모뎀이 수신합니다.
단일 CMTS만 다운스트림 채널로 전송하므로 다중 접속 문제가 없습니다.

### 업스트림 채널과 다중 접속

그러나 업스트림 방향은 더 흥미롭고 기술적으로 도전적입니다.
여러 케이블 모뎀이 동일한 업스트림 채널(주파수)을 CMTS와 공유하므로 충돌이 잠재적으로 발생할 수 있습니다.

그림 6.14에서 보듯이, 각 업스트림 채널은 **미니 슬롯의 시퀀스를 포함하는 시간 간격**으로 나뉩니다 (TDM과 유사).
CMTS는 특정 미니 슬롯 동안 개별 케이블 모뎀에게 전송 권한을 명시적으로 부여합니다.

CMTS는 다운스트림 채널에서 **MAP 메시지**라는 제어 메시지를 보내어 어떤 케이블 모뎀(데이터를 보낼 것이 있는)이 어떤 미니 슬롯 동안, 제어 메시지에 지정된 시간 간격 동안 전송할 수 있는지를 지정합니다.

미니 슬롯이 케이블 모뎀에 명시적으로 할당되므로, CMTS는 미니 슬롯 동안 충돌하는 전송이 없도록 보장할 수 있습니다.

### 미니 슬롯 요청과 랜덤 접속

그러나 CMTS는 어떤 케이블 모뎀이 처음부터 보낼 데이터가 있는지 어떻게 알 수 있을까요?

이것은 케이블 모뎀이 이 목적을 위해 전용된 특별한 **인터벌 미니 슬롯 세트** 동안 CMTS에 미니 슬롯 요청 프레임을 보내도록 함으로써 달성됩니다.
그림 6.14에서 보듯이, 이러한 미니 슬롯 요청 프레임은 **랜덤 접속 방식**으로 전송되므로 서로 충돌할 수 있습니다.

케이블 모뎀은 업스트림 채널이 사용 중인지 감지할 수도 없고 충돌을 감지할 수도 없습니다.
대신, 케이블 모뎀은 다음 다운스트림 제어 메시지에서 요청된 할당에 대한 응답을 받지 못하면 미니 슬롯 요청 프레임이 충돌을 경험했다고 추론합니다.

충돌이 추론되면, 케이블 모뎀은 **이진 지수 백오프**를 사용하여 미니 슬롯 요청 프레임의 재전송을 미래 타임 슬롯으로 지연합니다.

업스트림 채널에 트래픽이 적을 때, 케이블 모뎀은 실제로 미니 슬롯 요청 프레임용으로 지정된 슬롯 동안 데이터 프레임을 전송할 수 있습니다 (따라서 미니 슬롯 할당을 기다릴 필요 없음).

### 케이블 접속 네트워크: 다중 접속 프로토콜의 종합

케이블 접속 네트워크는 다중 접속 프로토콜의 훌륭한 예입니다:
- **FDM**: 다운스트림과 업스트림 채널을 주파수로 분할
- **TDM**: 업스트림 채널을 미니 슬롯으로 분할
- **랜덤 접속**: 미니 슬롯 요청 프레임 전송
- **중앙 할당된 타임 슬롯**: CMTS가 케이블 모뎀에 미니 슬롯 할당

하나의 네트워크 내에서 FDM, TDM, 랜덤 접속, 그리고 중앙 할당된 타임 슬롯 모두가 동작합니다!
