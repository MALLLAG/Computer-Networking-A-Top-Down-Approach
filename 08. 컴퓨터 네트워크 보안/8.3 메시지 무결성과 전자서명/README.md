## 8.3 메시지 무결성과 전자서명

이전 절에서 암호화를 사용하여 두 통신 엔티티 간에 **기밀성(confidentiality)** 을 제공하는 방법을 살펴보았습니다.
이 절에서는 동등하게 중요한 암호학 주제인 **메시지 무결성(message integrity)** (메시지 인증이라고도 함)을 제공하는 데 초점을 맞춥니다.

메시지 무결성과 함께, 이 절에서는 두 가지 관련 주제를 다룹니다:
- **전자서명(digital signatures)**
- **종단점 인증(end-point authentication)**

메시지 무결성의 문제가 거의 모든 안전한 네트워킹 프로토콜에서 중요한 관심사임을 8장을 통해 8절까지 살펴볼 것입니다.

---

## 8.3.1 암호화 해시 함수

<img width="504" height="274" alt="Image" src="https://github.com/user-attachments/assets/89ea0e0f-8bfd-4cad-9ed8-097e7f9b9dd1" />

해시 함수는 입력 *m*을 받아 **H(m)** 으로 알려진 고정 크기 문자열을 계산합니다.
인터넷 체크섬(3장)과 CRC(6장)는 이 정의를 충족합니다.
**암호화 해시 함수(cryptographic hash function)** 는 다음의 추가적인 속성을 만족해야 합니다:

- **H(x) = H(y)** 인 두 개의 다른 메시지 *x*와 *y*를 찾는 것이 **계산적으로 불가능**해야 합니다.

비공식적으로 이 속성은 침입자가 해시 함수로 보호되는 다른 메시지를 원본 메시지로 대체하는 것이 **계산적으로 불가능**함을 의미합니다.
즉, 메시지 *m*과 그 해시 *H(m)*이 있다면, 침입자는 *H(m) = H(m')*인 다른 메시지 *m'*을 위조할 수 없습니다.

### 왜 단순 체크섬은 불충분한가

<img width="484" height="304" alt="Image" src="https://github.com/user-attachments/assets/b1b15262-ddd0-4b0f-ae4a-2dce417c7b54" />

구체적인 예로, 링크 상태 라우팅 알고리즘(OSPF 등)을 사용하여 네트워크의 라우터 쌍 사이의 경로를 결정하는 컴퓨터 네트워크를 고려합니다.
각 라우터는 자신과 직접 연결된 이웃들 및 이러한 이웃들에 대한 직접 비용을 포함하는 링크 상태 메시지를 네트워크의 모든 다른 라우터에 브로드캐스트해야 합니다.

라우터가 다른 모든 라우터로부터 링크 상태 메시지를 수신하면, 전체 네트워크 맵을 생성하고 최소 비용 라우팅 알고리즘을 실행하며 포워딩 테이블을 구성할 수 있습니다.
따라서 메시지 무결성의 필요성이 있습니다 - 라우터 A가 라우터 B로부터 링크 상태 메시지를 받을 때, 라우터 A는 라우터 B가 실제로 그 메시지를 보냈는지, 그리고 아무도 전송 중에 메시지를 변조하지 않았는지 확인해야 합니다.

밥이 앨리스에게 IOU(차용증)를 보내는 예를 생각해 봅시다.
밥이 앨리스에게 $100.99를 빚지고 "IOU100.99BOB"라는 텍스트 문자열을 보낸다고 가정합니다.
ASCII 표현을 사용하고 4바이트 청크 단위로 바이트를 더하면 체크섬은 **B2 C1 D2 AC**가 됩니다.

그러나 그림 8.8에서 보듯이 "IOU100.99BOB"와 "IOU900.19BOB" 메시지는 **동일한 체크섬**을 가집니다!
따라서 이 단순한 체크섬 알고리즘은 위의 요구사항을 위반합니다.
원본 데이터가 주어지면 동일한 체크섬을 가진 다른 데이터 집합을 찾기가 **쉽습니다**.
보안 목적으로는 체크섬보다 더 강력한 해시 함수가 필요합니다.

### MD5 해시 알고리즘

Ron Rivest의 **MD5 해시 알고리즘** [RFC 1321]은 오늘날 널리 사용됩니다.
이 알고리즘은 4단계 프로세스로 **128비트 해시**를 계산합니다:

1. **패딩 단계**: 메시지 길이가 특정 조건을 만족하도록 1 다음에 충분한 0을 추가
2. **추가 단계**: 패딩 전 메시지 길이의 64비트 표현을 추가
3. **누산기 초기화**: 누산기의 초기화
4. **최종 루핑 단계**: 메시지의 16워드 블록이 4라운드로 처리(맹글링)

MD5에 대한 자세한 설명(C 소스 코드 구현 포함)은 [RFC 1321]을 참조하세요.

### SHA-1 해시 알고리즘

오늘날 사용되는 두 번째 주요 해시 알고리즘은 **SHA-1(Secure Hash Algorithm)** [FIPS 1995]입니다.
이 알고리즘은 MD5의 전신인 MD4 [RFC 1320]의 설계와 유사한 원리에 기반합니다.

SHA-1은 미국 연방 표준으로, 연방 애플리케이션에서 암호화 해시 알고리즘이 필요할 때 사용해야 합니다.
이 알고리즘은 **160비트 메시지 다이제스트**를 생성합니다.
더 긴 출력 길이가 SHA-1을 더 안전하게 만듭니다.

---

## 8.3.2 메시지 인증 코드 (MAC)

이제 해시 함수를 이해했으니, 메시지 무결성을 수행하는 방법에 대한 첫 번째 시도를 해봅시다:

1. 앨리스가 메시지 *m*을 생성하고 해시 *H(m)*을 계산합니다 (예: SHA-1 사용).
2. 앨리스가 메시지 *m*에 *H(m)*을 추가하여 확장된 메시지 *(m, H(m))*을 생성하고 밥에게 보냅니다.
3. 밥이 확장된 메시지 *(m, h)*를 받고 *H(m)*을 계산합니다. *H(m) = h*이면 모든 것이 정상이라고 결론짓습니다.

이 접근 방식은 **명백히 결함**이 있습니다.
트루디가 가짜 메시지 *m'*을 생성하고, *H(m')*을 계산하여 밥에게 *(m', H(m'))*을 보낼 수 있습니다.
밥이 메시지를 받으면 3단계에서 모든 것이 정상으로 확인되어 밥은 수상한 것을 의심하지 않습니다.

### 공유 비밀을 사용한 메시지 무결성

메시지 무결성을 수행하려면 암호화 해시 함수 사용 외에도 앨리스와 밥이 **공유 비밀 *s***를 가져야 합니다.
이 공유 비밀(비트 문자열에 불과함)은 **인증 키(authentication key)** 라고 합니다.

이 공유 비밀을 사용하여 메시지 무결성은 다음과 같이 수행됩니다:

1. 앨리스가 메시지 *m*을 생성하고, *s*를 *m*과 연결하여 *m + s*를 만들고, 해시 *H(m + s)*를 계산합니다 (예: SHA-1 사용). *H(m + s)*를 **메시지 인증 코드(Message Authentication Code, MAC)** 라고 합니다.

2. 앨리스가 MAC을 메시지 *m*에 추가하여 확장된 메시지 *(m, H(m + s))*를 생성하고 밥에게 보냅니다.

3. 밥이 확장된 메시지 *(m, h)*를 받고 *s*를 알고 있으므로 MAC *H(m + s)*를 계산합니다. *H(m + s) = h*이면 모든 것이 정상이라고 결론짓습니다.

<img width="504" height="278" alt="Image" src="https://github.com/user-attachments/assets/35ff669a-4691-4fcd-8669-d2a379a028e0" />

그림 8.9는 이 절차를 요약합니다.

여기서 MAC(메시지 인증 코드)은 링크 계층 프로토콜에서 사용되는 MAC(매체 접근 제어)과 **같지 않음**을 주의하세요!

MAC의 좋은 특징 중 하나는 **암호화 알고리즘이 필요하지 않다**는 것입니다.
실제로 많은 애플리케이션에서 앞서 설명한 링크 상태 라우팅 알고리즘을 포함하여, 통신 엔티티는 메시지 무결성에만 관심이 있고 메시지 기밀성에는 관심이 없습니다.
MAC을 사용하면 엔티티들은 복잡한 암호화 알고리즘을 무결성 프로세스에 통합할 필요 없이 서로에게 보내는 메시지를 인증할 수 있습니다.

### HMAC

예상할 수 있듯이 MAC에 대한 여러 다른 표준이 제안되어 왔습니다.
오늘날 가장 인기 있는 표준은 **HMAC**으로, MD5 또는 SHA-1과 함께 사용할 수 있습니다.
HMAC은 실제로 데이터와 인증 키를 해시 함수를 통해 **두 번** 실행합니다 [Kaufman 2002; RFC 2104].

### 인증 키 배포 문제

여전히 중요한 문제가 남아 있습니다: **공유 인증 키를 통신 엔티티에 어떻게 배포할 것인가?**

예를 들어, 링크 상태 라우팅 알고리즘에서는 자율 시스템의 각 라우터에 비밀 인증 키를 배포해야 합니다.
(모든 라우터가 동일한 인증 키를 사용할 수 있습니다.)

네트워크 관리자가 실제로 각 라우터를 물리적으로 방문하여 이를 수행할 수 있습니다.
또는 각 라우터가 자체 공개키를 가지고 있다면, 네트워크 관리자는 라우터의 공개키로 암호화한 다음 네트워크를 통해 암호화된 키를 라우터에 전송하여 인증 키를 라우터에 배포할 수 있습니다.

따라서 MAC은 여기서 작업을 완료하지 못합니다.

---

## 8.3.3 전자서명

지난 주에 서명한 횟수를 생각해 보세요.
수표, 신용카드 영수증, 법률 문서, 편지에 서명합니다.
서명은 당신이(다른 누군가가 아닌) 문서의 내용을 인정하고/또는 동의했다는 사실을 증명합니다.

디지털 세계에서도 문서의 소유자나 작성자를 표시하거나, 문서 내용에 대한 동의를 나타내고 싶은 경우가 많습니다.
**전자서명(digital signature)** 은 디지털 세계에서 이러한 목표를 달성하기 위한 암호 기술입니다.

수기 서명과 마찬가지로 디지털 서명은 **검증 가능하고 위조 불가능**한 방식으로 이루어져야 합니다.
즉, 개인이 서명한 문서가 실제로 그 개인에 의해 서명되었음을 증명할 수 있어야 하고(서명이 검증 가능해야 함), **오직** 그 개인만이 문서에 서명할 수 있었음을 증명할 수 있어야 합니다(서명이 위조될 수 없어야 함).

### 전자서명 체계 설계

디지털 서명 체계를 어떻게 설계할 수 있을지 고려해 봅시다.
밥이 메시지에 서명할 때, 밥은 자신에게 고유한 무언가를 메시지에 넣어야 합니다.

밥은 서명에 MAC을 첨부하는 것을 고려할 수 있습니다. MAC은 자신의 키(그에게 고유한)를 메시지에 추가한 다음 해시를 취하여 생성됩니다.
그러나 앨리스가 서명을 검증하려면 키의 복사본도 가지고 있어야 하는데, 이 경우 키가 밥에게 고유하지 않게 됩니다.
따라서 MAC은 여기서 작업을 완료하지 못합니다.

공개키 암호화에서 밥은 공개키와 개인키를 모두 가지고 있으며, 이 키들 모두 밥에게 고유합니다.
따라서 **공개키 암호화는 전자서명을 제공하기 위한 훌륭한 후보**입니다.

### 공개키를 사용한 전자서명

<img width="509" height="281" alt="Image" src="https://github.com/user-attachments/assets/148839a7-a38c-493a-98dc-8c0e37ec80c2" />

밥이 문서 *m*에 디지털 서명하려 한다고 가정합니다.
문서를 파일이나 밥이 서명하고 보내려는 메시지로 생각할 수 있습니다.

그림 8.10에서 보듯이, 이 문서에 서명하기 위해 밥은 단순히 자신의 개인키 **K_B⁻**를 사용하여 **K_B⁻(m)**을 계산합니다.

처음에는 밥이 자신의 개인키를 사용하는 것이 이상하게 보일 수 있습니다(8.2절에서 보았듯이 공개키로 암호화된 메시지를 복호화하는 데 사용됨).
그러나 암호화와 복호화가 RSA에서 *e* 또는 *d*의 거듭제곱으로 지수화하는 것에 불과한 수학적 연산임을 기억하세요(8.2절 참조).
또한 밥의 목표는 문서의 내용을 스크램블하거나 모호하게 만드는 것이 아니라, 검증 가능하고 위조 불가능한 방식으로 문서에 서명하는 것임을 기억하세요.

**밥의 전자서명은 K_B⁻(m)입니다.**

### 전자서명 검증

전자서명 **K_B⁻(m)**이 검증 가능하고 위조 불가능한 요구사항을 충족하는지 확인해 봅시다.

앨리스가 *m*과 *K_B⁻(m)*을 가지고 있다고 가정합니다.
그녀는 밥이 실제로 문서에 서명했고 그 문서에 서명할 수 있었던 유일한 사람임을 법정에서 증명하고 싶습니다(소송 중이라면).

앨리스는 밥의 공개키 **K_B⁺**를 가져와서 문서 *m*에 연결된 전자서명 *K_B⁻(m)*에 적용합니다.
즉, **K_B⁺(K_B⁻(m))**을 계산하고, 놀랍게도 원본 문서 *m*과 정확히 일치하는 *m*을 생성합니다!

그러면 앨리스는 다음과 같은 이유로 밥만이 문서에 서명할 수 있었다고 주장합니다:

- 메시지에 서명한 사람은 **K_B⁺(K_B⁻(m)) = m**이 되도록 서명 *K_B⁻(m)*을 계산할 때 개인키 **K_B⁻**를 사용했어야 합니다.

- 개인키 **K_B⁻**를 알 수 있었던 유일한 사람은 밥입니다. 8.2절의 RSA 논의에서 공개키 **K_B⁺**를 아는 것이 개인키 **K_B⁻**를 알아내는 데 **도움이 되지 않음**을 기억하세요. 따라서 **K_B⁻**를 알 수 있는 유일한 사람은 처음에 키 쌍 *(K_B⁺, K_B⁻)*을 생성한 사람, 밥입니다. (이것은 밥이 **K_B⁻**를 아무에게도 주지 않았고 아무도 밥에게서 **K_B⁻**를 훔치지 않았다고 가정합니다.)

### 전자서명과 메시지 무결성

원본 문서 *m*이 어떤 대체 형태 *m'*으로 수정되면, 밥이 *m*에 대해 생성한 서명은 *m'*에 대해 유효하지 않습니다.
**K_B⁺(K_B⁻(m))은 m'와 같지 않기 때문**입니다.

따라서 전자서명은 **메시지 무결성**도 제공하여, 수신자가 메시지가 변경되지 않았음과 메시지의 출처를 확인할 수 있게 합니다.

### 해시 함수를 사용한 효율적인 전자서명

암호화로 데이터에 서명하는 것의 한 가지 우려는 암호화와 복호화가 **계산적으로 비용이 많이 든다**는 것입니다.
암호화 및 복호화의 오버헤드를 고려할 때, 완전한 암호화/복호화를 통해 데이터에 서명하는 것은 과도할 수 있습니다.

더 효율적인 접근 방식은 전자서명에 **해시 함수를 도입**하는 것입니다.
8.3.2절에서 해시 알고리즘이 임의의 길이의 메시지 *m*을 취해 메시지의 고정 길이 "지문" **H(m)**을 계산함을 기억하세요.

해시 함수를 사용하여 밥은 메시지 자체가 아닌 **메시지의 해시에 서명**합니다.
즉, 밥은 **K_B⁻(H(m))**을 계산합니다.

*H(m)*이 일반적으로 원본 메시지 *m*보다 훨씬 작으므로, 전자서명을 생성하는 데 필요한 계산 노력이 **상당히 감소**합니다.

<img width="567" height="413" alt="Image" src="https://github.com/user-attachments/assets/90345c56-1ae9-4505-a427-4e66818dacf8" />

그림 8.11은 밥이 앨리스에게 메시지를 보내는 맥락에서 전자서명을 생성하는 운영 절차를 요약합니다:
1. 밥이 원본 긴 메시지를 해시 함수에 통과시킵니다
2. 결과 해시를 자신의 개인키로 디지털 서명합니다
3. 원본 메시지(평문)와 디지털 서명된 메시지 다이제스트(이하 전자서명이라 함)를 앨리스에게 보냅니다

<img width="592" height="461" alt="Image" src="https://github.com/user-attachments/assets/ee8beecd-43f1-4dbe-964d-5189d57e3d35" />

그림 8.12는 서명 검증의 운영 절차를 요약합니다:
1. 앨리스가 송신자의 공개키를 서명된 해시에 적용하여 해시 결과를 얻습니다
2. 앨리스가 평문 메시지에 해시 함수를 적용하여 두 번째 해시 결과를 얻습니다
3. 두 해시가 일치하면 앨리스는 메시지의 무결성과 작성자에 대해 확신할 수 있습니다

### MAC과 전자서명 비교

진행하기 전에 전자서명과 MAC을 간단히 비교해 봅시다.
둘 다 유사점이 있지만 중요한 미묘한 차이점도 있습니다.

| | MAC | 전자서명 |
|---|-----|---------|
| **시작점** | 메시지(또는 문서) | 메시지(또는 문서) |
| **생성 방법** | 메시지에 인증 키를 추가한 후 해시 | 메시지의 해시를 먼저 취한 후 개인키로 암호화 |
| **암호화 필요 여부** | 공개키나 대칭키 암호화 불필요 | 공개키 암호화 필요 |
| **인프라 요구사항** | 없음 | 인증 기관(CA)을 포함한 공개키 기반구조(PKI) 필요 |

- **PGP**(인기 있는 안전한 이메일 시스템)는 메시지 무결성에 전자서명을 사용합니다
- **OSPF**는 메시지 무결성에 MAC을 사용합니다
- 8.5절과 8.6절에서 MAC이 인기 있는 전송 계층 및 네트워크 계층 보안 프로토콜에서도 사용됨을 볼 것입니다

---

## 공개키 인증

전자서명의 중요한 응용은 **공개키 인증(public key certification)** 입니다.
즉, 공개키가 특정 엔티티에 속함을 인증하는 것입니다.
공개키 인증은 IPsec과 TLS를 포함한 많은 인기 있는 안전한 네트워킹 프로토콜에서 사용됩니다.

### 피자 장난 문제

이 문제에 대한 통찰을 얻기 위해, 고전적인 "피자 장난"의 인터넷 상거래 버전을 고려해 봅시다.

앨리스는 피자 배달 사업을 하며 인터넷을 통해 주문을 받습니다.
피자 애호가 밥은 앨리스에게 자신의 집 주소와 원하는 피자 종류를 포함한 평문 메시지를 보냅니다.
이 메시지에서 밥은 자신이 메시지의 진정한 출처임을 앨리스에게 증명하기 위해 전자서명(즉, 원본 평문 메시지의 서명된 해시)도 포함합니다.

서명을 검증하기 위해 앨리스는 밥의 공개키를 얻고(공개키 서버나 이메일 메시지에서) 전자서명을 확인합니다.
이렇게 해서 앨리스는 청소년 장난꾼이 아닌 밥이 주문했음을 확인합니다.

### 트루디의 위장 공격

<img width="622" height="434" alt="Image" src="https://github.com/user-attachments/assets/287edf89-8e12-4738-868a-5ec0ee5d34a6" />

영리한 트루디가 나타날 때까지 모든 것이 순조롭습니다.
그림 8.13에서 보듯이, 트루디가 장난을 치고 있습니다.

트루디는 앨리스에게 자신이 밥이라고 말하고, 밥의 집 주소를 알려주며, 피자를 주문하는 메시지를 보냅니다.
이 메시지에서 트루디는 자신의(트루디의) 공개키도 포함하지만, 앨리스는 당연히 그것이 밥의 공개키라고 가정합니다.
트루디는 또한 자신의(트루디의) 개인키로 생성된 전자서명을 첨부합니다.

메시지를 받은 후, 앨리스는 트루디의 공개키(밥의 것이라고 생각함)를 전자서명에 적용하고 평문 메시지가 실제로 밥에 의해 생성되었다고 결론짓습니다.
배달원이 페퍼로니와 앤초비 피자를 가지고 오면 밥은 매우 놀랄 것입니다!

### 인증 기관 (CA)

이 예에서 공개키 암호화가 유용하려면, 통신하고자 하는 엔티티(사람, 라우터, 브라우저 등)의 **실제 공개키**를 가지고 있는지 확인할 수 있어야 합니다.

예를 들어, 앨리스가 공개키 암호화를 사용하여 밥과 통신하려 할 때, 그녀는 밥의 것으로 추정되는 공개키가 실제로 밥의 것인지 확인해야 합니다.

공개키를 특정 엔티티에 바인딩하는 것은 일반적으로 **인증 기관(Certification Authority, CA)** 에 의해 수행됩니다.
CA의 역할은 신원을 검증하고 인증서를 발급하는 것입니다.

CA는 다음과 같은 역할을 합니다:

1. **CA는 엔티티(사람, 라우터 등)가 자신이 말하는 대로인지 확인합니다.**
   인증이 어떻게 수행되는지에 대한 의무적인 절차는 없습니다.
   CA를 다룰 때는 CA가 적절히 엄격한 신원 확인을 수행했다고 신뢰해야 합니다.
   예를 들어, 트루디가 Fly-by-Night CA에 가서 단순히 "나는 앨리스다"라고 선언하고 앨리스의 신원과 연결된 인증서를 받을 수 있다면, Fly-by-Night CA가 인증한 공개키에 대해 큰 신뢰를 두어서는 안 됩니다.

2. **CA가 엔티티의 신원을 확인하면, CA는 엔티티의 공개키를 신원에 바인딩하는 인증서를 생성합니다.**
   인증서에는 공개키와 공개키 소유자에 대한 전역적으로 고유한 식별 정보(예: 사람 이름이나 IP 주소)가 포함됩니다.
   인증서는 CA에 의해 **디지털 서명**됩니다.

<img width="484" height="312" alt="Image" src="https://github.com/user-attachments/assets/1462ece1-4344-43b1-9b15-ddc71475d963" />

그림 8.14에서 이 단계들을 보여줍니다.

### 인증서를 사용한 피자 주문

이제 인증서가 피자 주문 장난꾼인 트루디와 다른 바람직하지 않은 사람들을 방지하는 데 어떻게 사용될 수 있는지 살펴봅시다.

밥이 주문할 때 자신의 CA 서명 인증서도 보냅니다.
앨리스는 CA의 공개키를 사용하여 밥의 인증서 유효성을 확인하고 밥의 공개키를 추출합니다.

ITU(International Telecommunication Union)와 IETF 모두 CA에 대한 표준을 개발했습니다.
**ITU X.509** [ITU 2005a]는 인증 서비스뿐만 아니라 인증서에 대한 특정 구문을 지정합니다.
[RFC 1422]는 안전한 인터넷 이메일에서 사용하기 위한 CA 기반 키 관리를 설명합니다.

### X.509 인증서의 주요 필드

**표 8.4: X.509 및 RFC 1422 공개키 인증서의 주요 필드**

| 필드 이름 | 설명 |
|---------|------|
| Version | X.509 사양의 버전 번호 |
| Serial number | CA가 발급한 인증서의 고유 식별자 |
| Signature | CA가 이 인증서에 서명하는 데 사용한 알고리즘 지정 |
| Issuer name | 이 인증서를 발급한 CA의 신원, DN(Distinguished Name) [RFC 4514] 형식 |
| Validity period | 인증서의 유효 기간 시작과 끝 |
| Subject name | 이 인증서와 연결된 공개키를 가진 엔티티의 신원, DN 형식 |
| Subject public key | 주체의 공개키와 공개키 알고리즘(및 이 키와 함께 사용할 알고리즘 매개변수)의 표시 |
