## 8.2 암호의 원리

암호학은 적어도 율리우스 카이사르 시대까지 거슬러 올라가는 오랜 역사를 가지고 있지만, 인터넷에서 사용되는 것을 포함한 현대 암호 기술은 지난 30년간의 발전에 기반합니다.
Kahn의 책 *The Codebreakers* [Kahn 1967]와 Singh의 책 *The Code Book: The Science of Secrecy from Ancient Egypt to Quantum Cryptography* [Singh 1999]는 암호학의 흥미로운 역사를 제공합니다.

이 절에서는 인터넷에서 실제로 사용되는 암호학의 핵심적인 측면만을 다룹니다.
암호 기술은 기밀성뿐만 아니라 **인증(authentication)**, **메시지 무결성(message integrity)**, **부인 방지(nonrepudiation)** 등에도 밀접하게 연관되어 있습니다.

암호 기술을 통해 송신자는 데이터를 위장하여 침입자가 가로챈 데이터로부터 **아무런 정보도 얻을 수 없도록** 할 수 있습니다.
물론 수신자는 위장된 데이터로부터 원본 데이터를 복원할 수 있어야 합니다.

### 암호 시스템의 구성 요소

앨리스가 밥에게 메시지를 보내려 한다고 가정합니다.
앨리스의 메시지가 원래 형태(예: "Bob, I love you. Alice")일 때 이를 **평문(plaintext)** 또는 **클리어텍스트(cleartext)** 라고 합니다.

앨리스는 **암호화 알고리즘(encryption algorithm)** 을 사용하여 평문 메시지를 암호화합니다.
암호화된 메시지는 **암호문(ciphertext)** 이라 하며, 침입자에게는 이해할 수 없는 형태로 보입니다.

흥미롭게도 인터넷에서 사용되는 것을 포함한 많은 현대 암호 시스템에서 암호화 기술 자체는 **공개되어 있고 표준화**되어 있습니다(예: RFC 1321, RFC 3447, RFC 2420, NIST 2001).
따라서 침입자가 전송된 데이터를 복호화하는 것을 막는 비밀 정보가 있어야 합니다 - 이것이 바로 **키(key)** 입니다.

<img width="563" height="303" alt="Image" src="https://github.com/user-attachments/assets/e59168cc-395a-4ac3-87b5-1f7d22dd4d36" />

그림 8.2에서 앨리스는 암호화 알고리즘에 **키 K_A**(숫자 또는 문자의 문자열)를 입력으로 제공합니다.
암호화 알고리즘은 키와 평문 메시지 *m*을 입력받아 암호문을 출력합니다.
**K_A(m)** 표기법은 평문 메시지 *m*을 키 K_A로 암호화한 암호문 형태를 나타냅니다.

마찬가지로 밥은 **복호화 알고리즘(decryption algorithm)** 에 키 **K_B**를 제공합니다.
밥이 암호화된 메시지 K_A(m)을 받으면, K_B(K_A(m)) = m을 계산하여 복호화합니다.

### 대칭키 시스템과 공개키 시스템

- **대칭키 시스템(symmetric key systems)**: 앨리스와 밥의 키가 **동일**하고 비밀로 유지됩니다.
- **공개키 시스템(public key systems)**: 한 쌍의 키가 사용됩니다. 하나의 키는 밥과 앨리스 모두에게(실제로 전 세계에) 알려져 있고, 다른 키는 밥 또는 앨리스 중 한 명만 알고 있습니다.

---

## 8.2.1 대칭키 암호화

모든 암호화 알고리즘은 한 것을 다른 것으로 대체하는 것을 포함합니다.
예를 들어, 평문 조각을 취해 적절한 암호문을 계산하고 대체하여 암호화된 메시지를 생성합니다.

### 시저 암호 (Caesar Cipher)

현대의 키 기반 암호 시스템을 학습하기 전에, 율리우스 카이사르에게 귀속되는 매우 오래되고 간단한 대칭키 알고리즘인 **시저 암호(Caesar cipher)** 를 살펴봅니다.

영문 텍스트의 경우, 시저 암호는 평문 메시지의 각 문자를 취해 알파벳에서 *k*개 뒤의 문자로 대체합니다(순환 적용).
예를 들어, k = 3이면:
- 평문의 *a*는 암호문에서 *d*가 됩니다
- 평문의 *b*는 암호문에서 *e*가 됩니다

예시: 평문 메시지 "bob, i love you. Alice"는 암호문 "ere, l oryh brx. dolfh"가 됩니다.

암호문이 의미 없는 문자열처럼 보이지만, 시저 암호가 사용되고 있다는 것을 안다면 가능한 키 값이 25개뿐이므로 코드를 해독하는 데 오래 걸리지 않습니다.

### 단일 알파벳 암호 (Monoalphabetic Cipher)

시저 암호의 개선된 형태로 **단일 알파벳 암호(monoalphabetic cipher)** 가 있습니다.
이 방식도 알파벳의 한 문자를 다른 문자로 대체하지만, 일정한 패턴(모든 문자에 *k*만큼 오프셋)이 아닌 **임의의 대체 규칙**을 사용합니다.
각 문자가 고유한 대체 문자를 가지며, 그 역도 성립합니다.

```
평문 문자:   a b c d e f g h i j k l m n o p q r s t u v w x y z
암호문 문자: m n b v c x z a s d f g h j k l p o i u y t r e w q
```

평문 메시지 "bob, i love you. Alice"는 "nkn, s gktc wky. Mgsbc"가 됩니다.

단일 알파벳 암호는 26개 문자의 가능한 쌍이 10^26 정도(25개보다 훨씬 많은)이므로 시저 암호보다 나아 보입니다.
그러나 평문 언어의 **통계적 분석**을 통해 비교적 쉽게 해독할 수 있습니다:
- 영어 텍스트에서 *e*와 *t*가 가장 빈번히 등장합니다(각각 13%와 9%)
- 특정 2글자, 3글자 조합("in", "it", "the", "ion", "ing" 등)이 자주 나타납니다

### 암호 공격의 유형

밥과 앨리스의 암호화 체계를 트루디가 깨려 할 때, 침입자가 가진 정보에 따라 세 가지 시나리오를 구분할 수 있습니다:

#### 암호문 단독 공격 (Ciphertext-only Attack)

침입자가 가로챈 암호문에만 접근할 수 있고, 평문 메시지 내용에 대한 확실한 정보가 없는 경우입니다.
통계적 분석이 암호화 체계에 대한 **암호문 단독 공격**에 도움이 될 수 있습니다.

#### 알려진 평문 공격 (Known-plaintext Attack)

침입자가 일부 (평문, 암호문) 쌍을 알고 있는 경우입니다.
예를 들어, 트루디가 "bob"과 "alice"라는 이름이 암호문에 나타난다는 것을 확실히 안다면, *a, l, i, c, e, b, o* 문자에 대한 쌍을 즉시 알 수 있습니다.
또한 트루디가 모든 암호문 전송을 기록하고 밥이 복호화한 버전 중 하나를 발견할 수도 있습니다.

#### 선택 평문 공격 (Chosen-plaintext Attack)

침입자가 평문 메시지를 선택하고 해당 암호문 형태를 얻을 수 있는 경우입니다.
단순한 암호화 알고리즘의 경우, 트루디가 앨리스에게 "The quick brown fox jumps over the lazy dog" 메시지를 보내게 할 수 있다면 암호화 체계를 완전히 깰 수 있습니다.
더 정교한 암호화 기술에서는 선택 평문 공격이 반드시 암호화 기술을 깰 수 있음을 의미하지는 않습니다.

### 다중 알파벳 암호 (Polyalphabetic Encryption)

<img width="565" height="146" alt="Image" src="https://github.com/user-attachments/assets/a126f425-be0d-4f85-bbe3-7031605d6876" />

500년 전, 단일 알파벳 암호화를 개선하는 기술인 **다중 알파벳 암호화(polyalphabetic encryption)** 가 발명되었습니다.
이 아이디어는 **여러 개의 단일 알파벳 암호**를 사용하여 평문 메시지의 특정 위치에 따라 다른 암호를 적용하는 것입니다.
따라서 같은 문자가 평문 메시지의 다른 위치에 나타나면 다르게 인코딩될 수 있습니다.

그림 8.4는 두 개의 시저 암호(k = 5와 k = 19)를 사용하는 다중 알파벳 암호화 체계의 예를 보여줍니다.
C₁, C₂, C₂, C₁, C₂ 패턴으로 반복하여 사용하면:
- 평문 메시지 "bob, i love you."는 "ghu, n etox dhz."로 암호화됩니다

이 예에서 암호화 및 복호화 "키"는 두 시저 키(k = 5, k = 19)의 지식과 C₁, C₂, C₂, C₁, C₂ 패턴입니다.

### 블록 암호 (Block Ciphers)

이제 현대로 넘어와 오늘날 대칭키 암호화가 어떻게 이루어지는지 살펴봅니다.
**블록 암호(block ciphers)** 는 PGP(안전한 이메일), TLS(TCP 연결 보안), IPsec(네트워크 계층 전송 보안) 등 많은 안전한 인터넷 프로토콜에서 사용됩니다.

블록 암호에서 암호화할 메시지는 *k* 비트의 블록 단위로 처리됩니다.
예를 들어, k = 64이면 메시지를 64비트 블록으로 나누고 각 블록을 독립적으로 암호화합니다.
블록을 인코딩하기 위해 암호는 *k* 비트 클리어텍스트 블록을 *k* 비트 암호문 블록으로 **일대일 매핑**합니다.

k = 3인 예시(표 8.1):

| 입력 | 출력 | 입력 | 출력 |
|-----|-----|-----|-----|
| 000 | 110 | 100 | 011 |
| 001 | 111 | 101 | 010 |
| 010 | 101 | 110 | 000 |
| 011 | 100 | 111 | 001 |

이 8개의 입력은 8! = 40,320가지 다른 방식으로 순열될 수 있습니다.
이러한 각 매핑을 키로 볼 수 있습니다 - 앨리스와 밥이 모두 매핑(키)을 안다면 그들 사이의 메시지를 암호화하고 복호화할 수 있습니다.

k = 3인 경우 40,320개의 매핑만으로는 데스크톱 PC에서 빠르게 무차별 대입 공격이 가능합니다.
무차별 대입 공격을 막기 위해 블록 암호는 일반적으로 **k = 64 비트 이상**의 훨씬 큰 블록을 사용합니다.
일반적인 *k*-블록 암호에 대한 가능한 매핑 수는 **2^k!** 로, k = 64와 같은 적당한 값에서도 천문학적입니다.

### 실제 블록 암호의 구현

<img width="567" height="361" alt="Image" src="https://github.com/user-attachments/assets/8146a418-5453-40b4-8cde-c4d1f3d9ff31" />

k = 64인 경우 주어진 매핑에 대해 앨리스와 밥은 2^64개의 입력 값을 가진 테이블을 유지해야 하는데, 이는 실현 불가능합니다.
대신 블록 암호는 일반적으로 **무작위 순열 테이블을 시뮬레이션하는 함수**를 사용합니다.

그림 8.5에서 k = 64비트인 함수의 예를 보여줍니다:
1. 64비트 블록을 8개의 청크로 나눕니다(각 8비트)
2. 각 8비트 청크는 8비트를 8비트로 매핑하는 테이블(T₁~T₈)로 처리됩니다
3. 8개의 출력 청크가 64비트 블록으로 재조립됩니다
4. 64비트 블록의 위치들이 스크램블(순열)되어 64비트 출력을 생성합니다
5. 이 출력이 다시 64비트 입력으로 피드백되어 다른 사이클이 시작됩니다
6. *n* 사이클 후에 64비트 암호문 블록이 생성됩니다

라운드의 목적은 각 입력 비트가 최종 출력 비트의 대부분(전부가 아니라면)에 영향을 미치도록 하는 것입니다.

### 주요 블록 암호 표준

오늘날 여러 인기 있는 블록 암호가 있습니다:

- **DES (Data Encryption Standard)**: 미리 결정된 테이블 대신 함수를 사용하며, 56비트 키로 64비트 블록을 사용합니다.
- **3DES**: DES를 세 번 적용하여 보안을 강화합니다.
- **AES (Advanced Encryption Standard)**: 128비트 블록을 사용하고 128, 192, 256비트 키로 작동할 수 있습니다.

각 알고리즘의 키는 알고리즘 내부의 특정 "미니 테이블" 매핑과 순열을 결정합니다.

무차별 대입 공격은 모든 키를 순환하며 각 키로 복호화 알고리즘을 적용하는 것입니다.
키 길이가 *n*이면 **2^n**개의 가능한 키가 있습니다.
NIST [NIST 2001]은 1초에 56비트 DES를 깰 수 있는 기계(즉, 1초에 2^56개 키를 시도)가 **128비트 AES 키를 깨는 데 약 149조 년**이 걸릴 것으로 추정합니다.

### 암호 블록 체이닝 (Cipher Block Chaining, CBC)

컴퓨터 네트워킹 애플리케이션에서는 일반적으로 긴 메시지나 긴 데이터 스트림을 암호화해야 합니다.
단순히 메시지를 *k* 비트 블록으로 나누고 각 블록을 독립적으로 암호화하면 미묘하지만 중요한 문제가 발생합니다:
두 개 이상의 클리어텍스트 블록이 **동일할 수 있습니다**.

예를 들어, 두 개 이상의 블록에서 클리어텍스트가 "HTTP/1.1"일 수 있습니다.
이러한 동일한 블록에 대해 블록 암호는 당연히 **같은 암호문**을 생성합니다.
공격자는 동일한 암호문 블록을 볼 때 클리어텍스트를 추측하고, 동일한 암호문 블록을 식별하고 기본 프로토콜 구조에 대한 지식을 사용하여 전체 메시지를 복호화할 수도 있습니다.

이 문제를 해결하기 위해 동일한 평문 블록이 다른 암호문 블록을 생성하도록 **무작위성을 혼합**할 수 있습니다.

*m(i)*를 *i*번째 평문 블록, *c(i)*를 *i*번째 암호문 블록, *a ⊕ b*를 두 비트 문자열 *a*와 *b*의 **배타적 OR(XOR)** 라 합니다.
(0 ⊕ 0 = 1 ⊕ 1 = 0이고 0 ⊕ 1 = 1 ⊕ 0 = 1이며, 두 비트 문자열의 XOR는 비트 단위로 수행됩니다.)

키 *S*를 가진 블록 암호 암호화 알고리즘을 *K_S*라 합니다.
기본 아이디어는 다음과 같습니다:
- 송신자는 *i*번째 블록에 대해 무작위 *k* 비트 숫자 *r(i)*를 생성합니다
- *c(i) = K_S(m(i) ⊕ r(i))*를 계산합니다
- 송신자는 *c(1), r(1), c(2), r(2), c(3), r(3), ...* 등을 보냅니다

수신자는 *c(i)*를 받으면 *K_S*로 복호화하여 *s(i) = m(i) ⊕ r(i)*를 얻습니다.
*r(i - 1)*도 알고 있으므로 *m(i) = s(i) ⊕ r(i)*로 클리어텍스트 블록을 얻습니다.

*r(i)*가 평문으로 전송되어 트루디에게 스니핑될 수 있지만, 트루디는 비밀 키 *K_S*를 모르기 때문에 평문 *m(i)*를 얻을 수 없습니다.
또한 두 평문 블록 *m(i)*와 *m(j)*가 같더라도 무작위 숫자 *r(i)*와 *r(j)*가 다르면(매우 높은 확률로) 해당 암호문 블록 *c(i)*와 *c(j)*도 달라집니다.

그러나 무작위성을 도입하면 한 가지 문제를 해결하지만 다른 문제를 만듭니다:
앨리스는 각 암호 비트에 대해 무작위 비트도 보내야 하므로 필요한 대역폭이 **두 배**가 됩니다.

이를 해결하기 위해 블록 암호는 일반적으로 **암호 블록 체이닝(Cipher Block Chaining, CBC)** 이라는 기술을 사용합니다.
기본 아이디어는 **첫 번째 메시지와 함께 하나의 무작위 값만 보내고**, 송신자와 수신자가 이후 무작위 숫자 대신 **계산된 코드화된 블록**을 사용하는 것입니다.

CBC는 다음과 같이 동작합니다:

1. 메시지(또는 데이터 스트림)를 암호화하기 전에 송신자는 무작위 *k* 비트 문자열인 **초기화 벡터(Initialization Vector, IV)** 를 생성합니다. 이 IV를 *c(0)*이라 합니다. 송신자는 IV를 *평문*으로 수신자에게 보냅니다.

2. 첫 번째 블록에서 송신자는 *m(1) ⊕ c(0)*을 계산합니다. 즉, 첫 번째 클리어텍스트 블록과 IV의 배타적 OR를 계산합니다. 그런 다음 이 결과를 블록 암호 알고리즘에 통과시켜 해당 암호문 블록을 얻습니다. 즉, *c(1) = K_S(m(1) ⊕ c(0))*입니다. 송신자는 암호화된 블록 *c(1)*을 수신자에게 보냅니다.

3. *i*번째 블록에서 송신자는 *c(i) = K_S(m(i) ⊕ c(i - 1))*로 *i*번째 암호문 블록을 생성합니다.

이 접근 방식의 결과:
- 수신자는 여전히 원본 메시지를 복원할 수 있습니다. *c(i)*를 받으면 *K_S*로 복호화하여 *s(i) = m(i) ⊕ c(i - 1)*을 얻습니다. *c(i - 1)*도 알고 있으므로 *m(i) = s(i) ⊕ c(i - 1)*로 평문을 얻습니다.
- 두 클리어텍스트 블록이 동일해도 해당 암호문은 (거의 항상) 다릅니다.
- 송신자가 IV를 평문으로 보내도 침입자는 비밀 키 *S*를 모르기 때문에 암호문 블록을 복호화할 수 없습니다.
- 송신자는 긴 메시지(수백 개의 블록으로 구성)에 대해 하나의 오버헤드 블록(IV)만 보내므로 대역폭 사용이 무시할 정도로 증가합니다.

CBC는 안전한 네트워크 프로토콜을 설계할 때 중요한 결과를 가집니다:
IV를 송신자에서 수신자로 배포하는 메커니즘을 프로토콜 내에 제공해야 합니다.

---

## 8.2.2 공개키 암호화

2,000년 이상(시저 암호 시대부터 1970년대까지) 암호화된 통신은 통신하는 두 당사자가 공통의 비밀인 **암호화와 복호화에 사용되는 대칭키**를 공유해야 했습니다.

이 접근 방식의 어려움은 두 당사자가 어떻게든 **공유 키에 합의**해야 한다는 것입니다.
하지만 이를 위해서는 안전한 통신이 필요합니다.
당사자들이 직접 만나서 키에 합의할 수도 있지만(예: 카이사르의 백인대장 둘이 로마 목욕탕에서 만남), 네트워크화된 세계에서 통신하는 당사자들은 네트워크를 통해서만 대화하고 직접 만나지 않을 수도 있습니다.

1976년 Diffie와 Hellman [Diffie 1976]은 **디피-헬만 키 교환(Diffie-Hellman Key Exchange)** 으로 알려진 알고리즘을 시연했습니다.
이는 사전에 알려진 공유 비밀 키 없이 두 당사자가 암호화와 함께 통신할 수 있게 하는 근본적으로 다르고 놀랍도록 우아한 접근 방식으로, 오늘날의 **공개키 암호 시스템(public key cryptography systems)** 의 발전으로 이어졌습니다.

공개키 암호 시스템은 암호화뿐만 아니라 **인증과 디지털 서명**에도 유용한 여러 훌륭한 속성을 가지고 있습니다.
흥미롭게도 [Diffie 1976]과 [RSA 1978]의 아이디어와 유사한 아이디어가 1970년대 초에 영국의 Communications-Electronics Security Group 연구원들에 의해 일련의 비밀 보고서에서 독립적으로 개발되었습니다 [Ellis 1987].

### 공개키 암호화의 개념

<img width="547" height="300" alt="Image" src="https://github.com/user-attachments/assets/aa107b50-522b-4c79-ae77-1850af3c4ec2" />

공개키 암호화의 사용은 개념적으로 매우 간단합니다.

그림 8.6에서 보듯이, 앨리스가 밥과 통신하고 싶다고 가정합니다.
밥과 앨리스가 단일 비밀 키를 공유하는(대칭키 시스템의 경우처럼) 대신, 밥(앨리스 메시지의 수신자)은 두 개의 키를 가집니다:

- **공개키(public key)**: 전 세계 모든 사람(트루디 침입자 포함)이 사용할 수 있는 키
- **개인키(private key)**: 밥만 알고 있는 키

밥의 공개키와 개인키를 각각 **K_B⁺**와 **K_B⁻**로 표기합니다.

밥과 통신하기 위해 앨리스는 먼저 밥의 공개키를 가져옵니다.
그런 다음 앨리스는 자신의 메시지 *m*을 밥의 공개키와 알려진(예: 표준화된) 암호화 알고리즘을 사용하여 암호화합니다.
즉, 앨리스는 **K_B⁺(m)**을 계산합니다.

밥은 앨리스의 암호화된 메시지를 받고 자신의 개인키와 알려진(예: 표준화된) 복호화 알고리즘을 사용하여 복호화합니다.
즉, 밥은 **K_B⁻(K_B⁺(m)) = m**을 계산합니다.

이는 놀라운 결과입니다!
이런 방식으로 앨리스는 밥의 공개적으로 사용 가능한 키를 사용하여 **비밀 키를 배포할 필요 없이** 밥에게 비밀 메시지를 보낼 수 있습니다!

곧 공개키와 개인키 암호화를 교환해도 같은 놀라운 결과를 얻을 수 있음을 알게 됩니다:
**K_B⁻(K_B⁺(m)) = K_B⁺(K_B⁻(m)) = m**

공개키 암호화가 매력적이지만 한 가지 우려가 즉시 떠오릅니다.
밥의 암호화 키가 공개되어 있으므로 **앨리스나 앨리스인 척하는 누구나** 밥에게 암호화된 메시지를 보낼 수 있습니다.
단일 공유 비밀 키의 경우 송신자가 비밀 키를 안다는 사실이 암묵적으로 송신자를 수신자에게 식별시킵니다.
그러나 공개키 암호화의 경우 누구나 밥의 공개 키를 사용하여 암호화된 메시지를 보낼 수 있으므로 이것이 더 이상 성립하지 않습니다.
**디지털 서명(digital signature)** 은 8.3절에서 학습할 주제로, 송신자를 메시지에 바인딩하는 데 필요합니다.

### RSA 알고리즘

이러한 우려를 해결하는 많은 알고리즘이 있을 수 있지만, **RSA 알고리즘**(창시자 Ron Rivest, Adi Shamir, Leonard Adleman의 이름을 따서 명명)은 공개키 암호화와 거의 동의어가 되었습니다.

RSA는 **모듈로-n 연산**을 사용하여 산술 연산을 광범위하게 활용합니다.
*x* mod *n*은 단순히 *x*를 *n*으로 나눈 나머지를 의미합니다. 예를 들어, 19 mod 5 = 4입니다.

모듈러 연산에서는 덧셈, 뺄셈, 곱셈, 거듭제곱의 일반적인 연산을 수행하지만 결과는 *n*으로 나눈 정수 나머지로 대체됩니다:

- [(a mod n) + (b mod n)] mod n = (a + b) mod n
- [(a mod n) - (b mod n)] mod n = (a - b) mod n
- [(a mod n) · (b mod n)] mod n = (a · b) mod n

세 번째 사실에서 **(a mod n)^d mod n = a^d mod n**이 됨을 알 수 있습니다.

### RSA 키 생성

공개 및 개인 RSA 키를 생성하기 위해 밥은 다음 단계를 수행합니다:

1. 두 개의 큰 소수 **p**와 **q**를 선택합니다. 값이 클수록 RSA를 깨기가 더 어렵지만 인코딩과 디코딩에 더 오래 걸립니다. RSA Laboratories는 *p*와 *q*의 곱이 **1,024비트** 정도일 것을 권장합니다.

2. **n = pq**와 **z = (p - 1)(q - 1)**을 계산합니다.

3. *z*와 공통 인수가 없는(1 제외) *n*보다 작은 숫자 **e**를 선택합니다. (이 경우 *e*와 *z*는 **서로소**라고 합니다.) *e*는 암호화에 사용됩니다.

4. **ed - 1**이 *z*로 정확히 나누어지는(나머지 없이) 숫자 **d**를 찾습니다. *d*는 복호화에 사용됩니다. 다른 방식으로 표현하면, *e*가 주어지면 **ed mod z = 1**이 되도록 *d*를 선택합니다.

5. 밥이 세계에 공개하는 공개키 **K_B⁺**는 숫자 쌍 **(n, e)**입니다. 그의 개인키 **K_B⁻**는 숫자 쌍 **(n, d)**입니다.

### RSA 암호화와 복호화

앨리스의 암호화와 밥의 복호화는 다음과 같이 수행됩니다:

- 앨리스가 밥에게 정수 숫자 *m*으로 표현된 비트 패턴을 보내려 한다고 가정합니다(*m* < *n*인 경우). 인코딩하기 위해 앨리스는 거듭제곱 *m^e*를 수행하고 *m^e*를 *n*으로 나눈 정수 나머지를 계산합니다. 앨리스의 평문 메시지 *m*의 암호화된 값 *c*는:

  **c = m^e mod n**

  이 암호문 *c*에 해당하는 비트 패턴이 밥에게 전송됩니다.

- 수신한 암호문 메시지 *c*를 복호화하기 위해 밥은 다음을 계산합니다:

  **m = c^d mod n**

  이는 개인키 *(n, d)*의 사용을 필요로 합니다.

### RSA 예시

RSA의 간단한 예로, 밥이 p = 5와 q = 7을 선택한다고 가정합니다.
(물론 이 값들은 보안에 너무 작습니다.)
그러면 n = 35이고 z = 24입니다.
밥은 e = 5를 선택합니다(5와 24는 공통 인수가 없으므로).
밥은 d = 29를 선택합니다(5·29 - 1 = 144가 24로 정확히 나누어지므로).
밥은 두 값 n = 35와 e = 5를 공개하고 d = 29는 비밀로 유지합니다.

이 두 공개 값을 관찰하면서 앨리스가 문자 *l, o, v, e*를 밥에게 보내려 한다고 가정합니다.
각 문자를 1과 26 사이의 숫자로 해석하면(*a*가 1, *z*가 26), 앨리스와 밥은 다음과 같이 암호화와 복호화를 수행합니다:

**표 8.2: 앨리스의 RSA 암호화, e = 5, n = 35**

| 평문 문자 | m: 숫자 표현 | m^e | 암호문 c = m^e mod n |
|---------|------------|-----|-------------------|
| l | 12 | 248832 | 17 |
| o | 15 | 759375 | 15 |
| v | 22 | 5153632 | 22 |
| e | 5 | 3125 | 10 |

**표 8.3: 밥의 RSA 복호화, d = 29, n = 35**

| 암호문 c | c^d | m = c^d mod n | 평문 문자 |
|--------|-----|--------------|---------|
| 17 | 48196857210675091411825223071697 | 12 | l |
| 15 | 12783403948858939111232757568359375 | 15 | o |
| 22 | 851643319086537701956194499721106030592 | 22 | v |
| 10 | 100000000000000000000000000000 | 5 | e |

### 세션 키 (Session Keys)

RSA에 필요한 거듭제곱은 다소 **시간이 많이 소요되는 과정**입니다.
그 결과 RSA는 실제로 **대칭키 암호화와 함께** 사용되는 경우가 많습니다.

예를 들어, 앨리스가 밥에게 대량의 암호화된 데이터를 보내려면 다음과 같이 할 수 있습니다:

1. 앨리스는 데이터 자체를 인코딩하는 데 사용할 키를 선택합니다. 이 키를 **세션 키(session key)** 라 하고 *K_S*로 표기합니다.

2. 앨리스는 밥에게 세션 키를 알려야 합니다(이것이 대칭키 암호에 사용할 공유 대칭키이므로, 예: DES나 AES).

3. 앨리스는 밥의 공개키를 사용하여 세션 키를 암호화합니다. 즉, **c = (K_S)^e mod n**을 계산합니다.

4. 밥은 RSA로 암호화된 세션 키 *c*를 받고 복호화하여 세션 키 *K_S*를 얻습니다.

5. 이제 밥은 앨리스가 암호화된 데이터 전송에 사용할 세션 키를 알게 됩니다.

### RSA가 작동하는 이유

RSA 암호화/복호화는 다소 마법처럼 보입니다.
암호화 알고리즘을 적용한 다음 복호화 알고리즘을 적용하면 원본 메시지가 복원되는 이유는 무엇일까요?

RSA가 작동하는 이유를 이해하기 위해 **n = pq**라 하고(*p*와 *q*는 RSA 알고리즘에서 사용되는 큰 소수), RSA 암호화에서 메시지(정수로 고유하게 표현됨) *m*은 모듈로-*n* 연산을 사용하여 *e*의 거듭제곱으로 지수화됩니다:

**c = m^e mod n**

복호화는 이 값을 다시 모듈로-*n* 연산을 사용하여 *d*의 거듭제곱으로 올려 수행됩니다.
암호화 단계 다음에 복호화 단계의 결과는 **(m^e mod n)^d mod n**입니다.

앞서 언급한 모듈로 연산의 중요한 속성인 **(a mod n)^d mod n = a^d mod n**을 사용하면:

**(m^e mod n)^d mod n = m^ed mod n**

따라서 **m^ed mod n = m**임을 보이면 됩니다.

이를 위해 정수론의 결과가 필요합니다.
구체적으로, *p*와 *q*가 소수이고 n = pq, z = (p - 1)(q - 1)이면 **x^y mod n**은 **x^(y mod z) mod n**과 같습니다 [Kaufman 2002].

이 결과를 x = m, y = ed로 적용하면:

**m^ed mod n = m^(ed mod z) mod n**

**ed mod z = 1**이 되도록 *e*와 *d*를 선택했음을 기억하면:

**m^ed mod n = m^1 mod n = m**

이것이 바로 우리가 찾던 결과입니다!
*e*의 거듭제곱으로 먼저 지수화(즉, 암호화)한 다음 *d*의 거듭제곱으로 지수화(즉, 복호화)하면 원래 값 *m*을 얻습니다.

더욱 놀라운 것은 먼저 *d*의 거듭제곱으로 지수화한 다음 *e*의 거듭제곱으로 지수화해도(즉, 암호화와 복호화 순서를 바꿔도) 원래 값 *m*을 얻는다는 사실입니다.
이 놀라운 결과는 모듈러 연산에서 즉시 따릅니다:

**(m^d mod n)^e mod n = m^de mod n = m^ed mod n = (m^e mod n)^d mod n**

### RSA의 보안

RSA의 보안은 숫자, 이 경우 공개 값 *n*을 소수 *p*와 *q*로 **빠르게 인수분해하는 알려진 알고리즘이 없다**는 사실에 의존합니다.
*p*와 *q*를 알면 공개 값 *e*가 주어졌을 때 비밀 키 *d*를 쉽게 계산할 수 있습니다.

반면에 숫자를 인수분해하는 빠른 알고리즘이 존재하는지 여부는 알려져 있지 않으며, 이런 의미에서 RSA의 보안은 **보장되지 않습니다**.
최근 양자 컴퓨팅의 발전과 양자 컴퓨터를 위한 빠른 인수분해 알고리즘의 발표로 RSA가 영원히 안전하지 않을 수 있다는 우려가 있습니다 [MIT TR 2019].
그러나 이러한 알고리즘의 실제 구현은 아직 먼 미래의 일로 보입니다.

### 디피-헬만 알고리즘

또 다른 인기 있는 공개키 암호화 알고리즘은 **디피-헬만(Diffie-Hellman) 알고리즘**입니다.
디피-헬만은 임의 길이의 메시지를 암호화하는 데 사용할 수 없다는 점에서 RSA만큼 다재다능하지 않습니다.
그러나 **대칭 세션 키를 설정**하는 데 사용할 수 있으며, 이 세션 키가 메시지 암호화에 사용됩니다.
