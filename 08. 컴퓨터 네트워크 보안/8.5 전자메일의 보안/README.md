## 8.5 전자메일의 보안

이전 절에서는 대칭키 및 공개키 암호화, 종단점 인증, 키 배포, 메시지 무결성, 전자서명을 포함한 네트워크 보안의 기본적인 문제들을 살펴보았습니다.
이제 이러한 도구가 인터넷에서 보안을 제공하는 데 어떻게 사용되는지 살펴봅니다.

흥미롭게도 인터넷의 상위 4개 계층 모두에서 보안 서비스를 제공하는 것이 가능합니다.
네트워크 계층 이상의 상위 계층에서 보안이 제공될 때, 프로토콜을 사용하는 애플리케이션은 하나 이상의 보안 서비스를 누릴 수 있습니다.

전송 계층에서 보안이 제공될 때, 전송 계층 프로토콜을 사용하는 모든 애플리케이션이 보안 서비스를 누릴 수 있습니다.
네트워크 계층에서 보안이 제공될 때, 네트워크 계층 서비스의 모든 사용자가 보안 서비스를 누릴 수 있습니다.

링크에서 보안이 제공될 때, 링크를 통해 이동하는 모든 데이터에 대한 보안 서비스를 누립니다.

이 절에서는 8.2절부터 8.4절에서 배운 보안 도구가 애플리케이션 계층, 전송 계층, 네트워크 계층에서 어떻게 사용되는지 살펴봅니다.
먼저 이메일 보안부터 시작합니다.

---

## 8.5.1 안전한 이메일

이제 8.2절부터 8.3절까지의 암호화 원리를 사용하여 **안전한 이메일 시스템**을 만듭니다.
이 하향식 설계를 점진적인 방식으로 수행합니다.
각 단계에서 새로운 보안 서비스를 도입하면서 진행합니다.

먼저, 8.4절에서 소개된 앨리스와 밥의 사랑 이야기를 떠올려 봅시다.
안전한 이메일 시스템을 설계할 때 앨리스와 밥 사이의 **비밀 이메일** 메시지가 있다는 것을 염두에 두어야 합니다.

앞으로 나아가기 전에 앨리스와 밥을 위한 안전한 이메일 시스템을 설계하고 있으며, 어떤 보안 기능이 그들에게 바람직할지 고려해야 합니다.

- 첫 번째로 가장 중요한 것은 **기밀성(confidentiality)** 입니다.
- 밥이 "I don't love you anymore. I never want to see you again. Formerly yours, Alice"라는 메시지를 받을 때, 그는 당연히 메시지가 앨리스에게서 왔고 트루디에게서 온 것이 아님을 확인하고 싶어합니다. 따라서 **송신자 인증(sender authentication)** 이 필요합니다.
- 밥은 또한 메시지가 전송 중에 변경되지 않았음을 확인하고 싶어합니다. 따라서 **메시지 무결성(message integrity)** 이 필요합니다.

### 기밀성 제공

먼저 기밀성을 제공하는 이메일 시스템을 설계해 봅시다.
가장 직접적인 방법은 앨리스가 **대칭키 기술**(예: DES 또는 AES)을 사용하여 메시지를 암호화하고, 밥이 받으면 메시지를 복호화하는 것입니다.

8.2절에서 논의했듯이, 대칭키를 미리 결정하려면 앨리스와 밥이 어떻게든 만나서 합의하거나 신뢰할 수 있는 제3자를 사용해야 합니다.
대안적인 접근 방식으로 **공개키 암호화**(예: RSA)를 사용할 수 있습니다.

공개키 접근 방식에서 밥은 자신의 공개키를 공개적으로 제공하고(예: 공개키 서버나 개인 웹 페이지에), 앨리스는 밥의 공개키로 메시지를 암호화하여 밥의 이메일 주소로 보냅니다.
밥이 메시지를 받으면 자신의 개인키로 복호화합니다.

앨리스가 공개키가 밥의 것임을 확실히 안다면, 이 접근 방식은 원하는 기밀성을 제공하는 훌륭한 방법입니다.
그러나 한 가지 문제는 공개키 암호화가 **상대적으로 비효율적**이며, 특히 긴 메시지의 경우 더욱 그렇습니다.

### 세션 키를 사용한 효율적인 기밀성

효율성 문제를 극복하기 위해 8.2.2절에서 논의한 **세션 키(session key)** 를 활용합니다.

구체적으로, 앨리스는:
1. 무작위 대칭 세션 키 **K_S**를 선택합니다
2. 대칭키로 메시지 *m*을 암호화합니다
3. 대칭키를 밥의 공개키 **K_B⁺**로 암호화합니다
4. 암호화된 메시지와 암호화된 대칭키를 연결하여 "패키지"를 만듭니다
5. 패키지를 밥의 이메일 주소로 보냅니다

<img width="514" height="285" alt="Image" src="https://github.com/user-attachments/assets/946e41ad-5ea8-4342-8935-b3fea38c600d" />

이 단계들은 그림 8.19에 설명되어 있습니다.
(이 그림과 이후 그림들에서 원 안의 "+"는 연결을, 원 안의 "-"는 분리를 나타냅니다.)

밥이 패키지를 받으면:
1. 자신의 개인키 **K_B⁻**를 사용하여 대칭키 **K_S**를 얻습니다
2. 대칭키 **K_S**를 사용하여 메시지 *m*을 복호화합니다

### 송신자 인증과 메시지 무결성

기밀성을 제공하는 안전한 이메일 시스템을 설계했으니, 이제 **송신자 인증**과 **메시지 무결성**을 모두 제공하는 다른 시스템을 설계해 봅시다.

현재는 앨리스와 밥이 기밀성에 관심이 없다고(그들은 모든 사람과 감정을 공유하고 싶어함!) 가정하고, 송신자 인증과 메시지 무결성에만 관심이 있다고 합시다.

이 작업을 수행하기 위해 8.3절에서 설명한 **전자서명과 메시지 다이제스트**를 사용합니다.

구체적으로, 앨리스는:
1. 메시지 *m*에 해시 함수 *H*(예: MD5)를 적용하여 **메시지 다이제스트**를 얻습니다
2. 해시 함수의 결과를 자신의 개인키 **K_A⁻**로 서명하여 **전자서명**을 생성합니다
3. 원본(암호화되지 않은) 메시지와 서명을 연결하여 패키지를 만듭니다
4. 패키지를 밥의 이메일 주소로 보냅니다

밥이 패키지를 받으면:
1. 앨리스의 공개키 **K_A⁺**를 서명된 메시지 다이제스트에 적용합니다
2. 이 결과를 자신이 직접 계산한 메시지의 해시 *H*와 **비교**합니다

<img width="599" height="258" alt="Image" src="https://github.com/user-attachments/assets/6f2b9bab-5dfd-4a8c-af3d-fa4f05ae476d" />

이 단계들은 그림 8.20에 설명되어 있습니다.

8.3절에서 논의했듯이, 두 결과가 같으면 밥은 메시지가 앨리스에게서 왔고 변경되지 않았음을 상당히 확신할 수 있습니다.

### 기밀성, 송신자 인증, 메시지 무결성 결합

이제 **기밀성, 송신자 인증, 메시지 무결성**을 모두 제공하는 이메일 시스템을 설계해 봅시다.

이것은 그림 8.19와 8.20의 절차를 결합하여 수행할 수 있습니다:

1. 앨리스가 먼저 그림 8.20과 같이 원본 메시지와 메시지의 디지털 서명된 해시로 구성된 **예비 패키지**를 만듭니다
2. 그런 다음 이 예비 패키지를 메시지 자체로 취급하고 그림 8.19의 송신자 단계를 통해 보내어 밥에게 보낼 **새 패키지**를 만듭니다

<img width="520" height="284" alt="Image" src="https://github.com/user-attachments/assets/cd32b073-9887-4192-af8a-c9e64a4439ff" />

앨리스가 적용하는 단계는 그림 8.21에 나와 있습니다.

밥이 패키지를 받으면:
1. 먼저 그림 8.19의 자신의 측면을 적용합니다
2. 그런 다음 그림 8.20의 자신의 측면을 적용합니다

이 설계가 **기밀성, 송신자 인증, 메시지 무결성**의 목표를 달성함을 명확히 해야 합니다.

이 체계에서 앨리스는 공개키 암호화를 **두 번** 사용합니다:
- 자신의 개인키로 한 번
- 밥의 공개키로 한 번

마찬가지로 밥도 공개키 암호화를 **두 번** 사용합니다:
- 자신의 개인키로 한 번
- 앨리스의 공개키로 한 번

### 공개키 배포 문제

그림 8.21에 설명된 안전한 이메일 설계는 대부분의 경우 대부분의 이메일 사용자에게 만족스러운 보안을 제공할 것입니다.
그러나 여전히 해결해야 할 한 가지 중요한 문제가 남아 있습니다.

그림 8.21의 설계는 앨리스가 밥의 공개키를 얻고, 밥이 앨리스의 공개키를 얻어야 합니다.
이러한 공개키의 배포는 **사소하지 않은 문제**입니다.

예를 들어, 트루디가 밥으로 가장하여 앨리스에게 자신의 공개키를 밥의 공개키라고 하면서 줄 수 있습니다.
이렇게 되면 앨리스가 밥에게 보내려던 메시지를 트루디가 받을 수 있게 됩니다.

8.3절에서 배운 것처럼, 공개키를 안전하게 배포하는 인기 있는 접근 방식은 **CA(인증 기관)** 를 사용하여 공개키를 **인증(certify)** 하는 것입니다.

---

## 8.5.2 PGP

1991년 Phil Zimmermann이 작성한 **PGP(Pretty Good Privacy)** 는 이메일 암호화 체계의 좋은 예입니다 [PGP 2020].

PGP 설계는 본질적으로 그림 8.21에 보여진 설계와 같습니다.
버전에 따라 PGP 소프트웨어는:
- 메시지 다이제스트 계산에 **MD5** 또는 **SHA**를 사용합니다
- 대칭키 암호화에 **CAST**, **triple-DES**, 또는 **IDEA**를 사용합니다
- 공개키 암호화에 **RSA**를 사용합니다

### PGP 설치 및 사용

PGP가 설치되면 소프트웨어는 사용자를 위한 **공개키 쌍**을 생성합니다.
공개키는 사용자의 웹 사이트에 게시하거나 공개키 서버에 배치할 수 있습니다.
개인키는 **비밀번호** 사용으로 보호됩니다.
비밀번호는 사용자가 개인키에 접근할 때마다 입력해야 합니다.

PGP는 사용자에게 다음 옵션을 제공합니다:
- 메시지에 디지털 서명
- 메시지 암호화
- 디지털 서명과 암호화 모두

### PGP 서명된 메시지

<img width="493" height="221" alt="Image" src="https://github.com/user-attachments/assets/66927afb-b9ea-4796-a8f0-d22615a165f7" />

그림 8.22는 **PGP 서명된 메시지**를 보여줍니다.
이 메시지는 MIME 헤더 뒤에 나타납니다.

메시지에 인코딩된 데이터는 **K_A⁻(H(m))**입니다.
즉, 디지털 서명된 메시지 다이제스트입니다.

위에서 논의한 것처럼, 밥이 메시지의 무결성을 검증하려면 앨리스의 공개키에 접근해야 합니다.

### PGP 비밀 메시지

<img width="467" height="155" alt="Image" src="https://github.com/user-attachments/assets/40119350-9ae4-4830-928f-db2267a89df5" />

그림 8.23은 **비밀 PGP 메시지**를 보여줍니다.
이 메시지도 MIME 헤더 뒤에 나타납니다.

물론 평문 메시지는 비밀 이메일 메시지 내에 포함되지 않습니다.

송신자(예: 앨리스)가 기밀성과 무결성을 모두 원할 때, PGP는 그림 8.23의 메시지를 그림 8.22의 메시지 내에 포함합니다.

### PGP의 신뢰 웹 (Web of Trust)

PGP는 공개키 인증을 위한 메커니즘도 제공하지만, 이 메커니즘은 더 전통적인 CA와는 상당히 다릅니다.

PGP 공개키는 **신뢰 웹(web of trust)** 에 의해 인증됩니다:
- 앨리스 자신이 키/사용자 이름 쌍이 실제로 함께 속한다고 믿을 때 **직접 인증**할 수 있습니다
- 또한 PGP는 앨리스가 다른 사용자의 키 인증을 **보증**할 수 있도록 허용합니다

일부 PGP 사용자들은 **키 서명 파티(key-signing parties)** 를 개최하여 서로의 키에 서명합니다.
사용자들이 물리적으로 모여 공개키를 교환하고, 자신의 개인키로 서명하여 서로의 키를 인증합니다.
