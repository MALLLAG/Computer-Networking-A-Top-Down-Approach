## 8.4 종단점 인증

**종단점 인증(End-point authentication)** 은 컴퓨터 네트워크를 통해 한 엔티티가 다른 엔티티에게 자신의 신원을 증명하는 과정입니다.
예를 들어, 이메일 서버에 자신의 신원을 증명하는 사용자가 있습니다.

인간으로서 우리는 여러 방식으로 서로를 인증합니다:
- 만날 때 서로의 **얼굴**을 인식합니다
- 전화에서 서로의 **목소리**를 인식합니다
- 여권의 사진과 대조하여 검사하는 **세관 공무원**에 의해 인증됩니다

이 절에서는 네트워크를 통해 통신하는 두 당사자 중 한 당사자가 다른 당사자를 어떻게 인증할 수 있는지 고려합니다.
여기서는 통신이 **실제로 발생하는 시점**에 "라이브" 당사자를 인증하는 데 초점을 맞춥니다.

이것은 과거 어떤 시점에 받은 메시지가 실제로 주장된 송신자로부터 왔음을 증명하는 것(8.3절에서 학습)과는 미묘하게 다른 문제입니다.

### 인증 프로토콜

네트워크를 통해 인증을 수행할 때, 통신 당사자들은 시각적 외모나 음성 같은 **생체 정보에 의존할 수 없습니다**.
실제로 나중에 사례 연구에서 볼 것처럼, 서로를 인증해야 하는 것은 종종 라우터와 클라이언트/서버 프로세스와 같은 네트워크 요소입니다.

여기서 인증은 **인증 프로토콜(authentication protocol)** 의 일부로 교환되는 메시지와 데이터만을 기반으로 수행되어야 합니다.

일반적으로 인증 프로토콜은 두 통신 당사자가 다른 프로토콜(예: 신뢰성 있는 데이터 전송 프로토콜, 라우팅 정보 교환 프로토콜, 이메일 프로토콜)을 실행하기 **전에** 실행됩니다.
인증 프로토콜이 먼저 당사자들의 신원을 서로에게 확립하고, 인증 후에야 당사자들이 본격적인 작업에 들어갑니다.

3장에서 신뢰성 있는 데이터 전송(rdt) 프로토콜을 개발한 것처럼, 여기서도 인증 프로토콜의 다양한 버전을 개발하고 진행하면서 각 버전의 **구멍을 찾아보는** 것이 유익합니다.
(이 단계적 설계 진화를 즐긴다면 [Bryant 1988]을 읽어보세요. 이 책은 개방형 네트워크 인증 시스템 설계자들 사이의 허구적 이야기와 그들이 발견한 많은 미묘한 문제들을 다룹니다.)

앨리스가 밥에게 자신을 인증해야 한다고 가정합시다.

---

### 인증 프로토콜 ap1.0

<img width="507" height="275" alt="Image" src="https://github.com/user-attachments/assets/f1f75edb-0bae-4822-9b44-99f069b2bc87" />

우리가 상상할 수 있는 가장 간단한 인증 프로토콜은 앨리스가 단순히 밥에게 자신이 앨리스라는 메시지를 보내는 것입니다.

이 프로토콜은 그림 8.15에 나와 있습니다.

여기서 결함은 명백합니다 - 밥이 "I am Alice" 메시지를 보내는 사람이 실제로 앨리스인지 알 방법이 **없습니다**.
예를 들어, 트루디(침입자)도 그런 메시지를 보낼 수 있습니다.

---

### 인증 프로토콜 ap2.0

앨리스가 항상 통신하는 잘 알려진 네트워크 주소(예: IP 주소)를 가지고 있다면, 밥은 인증 메시지를 담은 IP 데이터그램의 출발지 주소가 앨리스의 잘 알려진 주소와 일치하는지 확인하여 앨리스를 인증하려 할 수 있습니다.

이 경우 앨리스는 인증될 것입니다.
이것은 네트워크에 매우 무지한 침입자가 앨리스를 사칭하는 것을 막을 수 있지만, 이 책을 공부하는 열정적인 학생이나 다른 많은 사람들을 막지는 **못합니다!**

### IP 스푸핑

<img width="516" height="282" alt="Image" src="https://github.com/user-attachments/assets/942e8483-6224-404c-8a1d-9aa2cd710441" />

네트워크 계층과 데이터 링크 계층에 대한 연구에서, 자신의 운영 체제 커널에 접근할 수 있다면(리눅스 및 여러 다른 자유롭게 사용 가능한 운영 체제의 경우처럼) IP 데이터그램을 생성하고, 원하는 IP 출발지 주소(예: 앨리스의 잘 알려진 IP 주소)를 넣고, 링크 계층 프로토콜을 통해 데이터그램을 첫 번째 홉 라우터에 보내는 것이 **어렵지 않다**는 것을 알고 있습니다.

그 이후로 잘못된 출발지 주소를 가진 데이터그램은 충실하게 밥에게 전달됩니다.

그림 8.16에 보여진 이 접근 방식은 **IP 스푸핑(IP spoofing)** 의 한 형태입니다.

IP 스푸핑은 트루디의 첫 번째 홉 라우터가 트루디의 IP 출발지 주소를 포함하는 데이터그램만 전달하도록 구성되어 있다면 피할 수 있습니다 [RFC 2827].
그러나 이 기능은 보편적으로 배포되거나 강제되지 않습니다.
따라서 밥은 트루디의 네트워크 관리자(트루디 자신일 수도 있음)가 트루디의 첫 번째 홉 라우터를 적절하게 주소가 지정된 데이터그램만 전달하도록 구성했다고 가정하는 것은 **어리석은 일**입니다.

---

### 인증 프로토콜 ap3.0

<img width="514" height="354" alt="Image" src="https://github.com/user-attachments/assets/03e0f9bb-4079-4abe-98f7-13adf1202fed" />

인증에 대한 고전적인 접근 방식 중 하나는 **비밀 비밀번호(secret password)** 를 사용하는 것입니다.
비밀번호는 인증자와 인증받는 사람 사이의 공유 비밀입니다.

Gmail, Facebook, Telnet, FTP 및 많은 다른 서비스가 비밀번호 인증을 사용합니다.

프로토콜 ap3.0에서 앨리스는 그림 8.17에 보여진 것처럼 자신의 비밀 비밀번호를 밥에게 보냅니다.

비밀번호가 매우 널리 사용되므로 프로토콜 *ap3.0*이 상당히 안전하다고 생각할 수 있습니다.
그렇다면 틀렸습니다!

### ap3.0의 보안 결함

여기서 보안 결함은 명확합니다.
트루디가 앨리스의 통신을 **도청(eavesdrop)** 하면 앨리스의 비밀번호를 알 수 있습니다.

이것이 불가능하다고 생각할 수 있지만, 다른 기계에 Telnet으로 접속하여 로그인할 때 로그인 비밀번호가 **암호화되지 않은 상태로** Telnet 서버에 전송된다는 사실을 고려해 보세요.
Telnet 클라이언트나 서버의 LAN에 연결된 누군가가 LAN에서 전송되는 모든 패킷을 스니핑(읽고 저장)하여 로그인 비밀번호를 훔칠 수 있습니다.

실제로 이것은 비밀번호를 훔치는 **잘 알려진 방법**입니다([Jimenez 1997] 참조).
이러한 위협은 분명히 매우 현실적이므로 *ap3.0*은 분명히 적합하지 않습니다.

---

### 인증 프로토콜 ap3.1

ap3.0을 수정하기 위한 다음 아이디어는 자연스럽게 **비밀번호를 암호화**하는 것입니다.
비밀번호를 암호화함으로써 트루디가 앨리스의 비밀번호를 알아내는 것을 막을 수 있습니다.

앨리스와 밥이 대칭 비밀키 **K_A-B**를 공유한다고 가정하면, 앨리스는 비밀번호를 암호화하고 "I am Alice"라는 식별 메시지와 암호화된 비밀번호를 밥에게 보낼 수 있습니다.

밥은 비밀번호를 복호화하고, 비밀번호가 올바르다고 가정하면 앨리스를 인증합니다.
밥은 앨리스가 비밀번호뿐만 아니라 비밀번호를 암호화하는 데 필요한 공유 비밀키 값도 알고 있기 때문에 앨리스를 인증하는 데 편안함을 느낍니다.

이 프로토콜을 *ap3.1*이라고 부릅시다.

### 재생 공격 (Playback Attack)

*ap3.1*이 트루디가 앨리스의 비밀번호를 알아내는 것을 막는 것은 사실이지만, 여기서 암호화 사용은 인증 문제를 **해결하지 못합니다**.

밥은 **재생 공격(playback attack)** 을 받게 됩니다:
트루디는 앨리스의 통신을 도청하고, 암호화된 버전의 비밀번호를 **기록**한 다음, 나중에 암호화된 버전의 비밀번호를 밥에게 **재생**하여 자신이 앨리스인 척할 수 있습니다.

*ap3.1*에서 암호화된 비밀번호의 사용은 그림 8.17의 프로토콜 *ap3.0*과 상황을 **본질적으로 다르게 만들지 않습니다**.

---

### 인증 프로토콜 ap4.0

그림 8.17의 실패 시나리오는 밥이 앨리스의 원래 인증과 이후 앨리스의 원래 인증 **재생**을 구별할 수 없다는 사실에서 비롯되었습니다.

즉, 밥은 앨리스가 라이브(즉, 현재 실제로 연결의 다른 끝에 있음)인지, 아니면 받는 메시지가 앨리스의 이전 인증의 기록된 재생인지 알 수 없었습니다.

매우 (*매우*) 관찰력이 좋은 독자는 3장 TCP 핸드셰이크 프로토콜이 **같은 문제를 해결**해야 했음을 기억할 것입니다.
TCP 연결의 서버 측은 수신된 SYN 세그먼트가 이전 연결의 SYN 세그먼트의 오래된 복사본(재전송)인 경우 연결을 수락하고 싶지 않았습니다.

TCP 서버 측은 클라이언트가 정말 라이브인지 어떻게 판단했을까요?
**매우 오랫동안 사용되지 않은 초기 시퀀스 번호**를 선택하고, 그 번호를 클라이언트에게 보낸 다음, 그 번호를 포함하는 ACK 세그먼트로 클라이언트가 응답하기를 기다렸습니다.

인증 목적으로 여기에서도 같은 아이디어를 채택할 수 있습니다.

### 넌스 (Nonce)

**넌스(nonce)** 는 프로토콜이 **일생에 한 번만** 사용하는 숫자입니다.
즉, 프로토콜이 한 번 넌스를 사용하면 다시는 그 숫자를 사용하지 않습니다.

*ap4.0* 프로토콜은 넌스를 다음과 같이 사용합니다:

1. 앨리스가 "I am Alice"라는 메시지를 밥에게 보냅니다.
2. 밥이 넌스 *R*을 선택하고 앨리스에게 보냅니다.
3. 앨리스가 앨리스와 밥의 대칭 비밀키 **K_A-B**를 사용하여 넌스를 암호화하고, 암호화된 넌스 **K_A-B(R)**을 밥에게 다시 보냅니다. *ap3.1* 프로토콜에서처럼, 앨리스가 **K_A-B**를 알고 그것을 사용하여 값을 암호화한다는 사실이 밥에게 그가 받는 메시지가 앨리스에 의해 생성되었음을 알려줍니다. 넌스는 앨리스가 **라이브**임을 보장하는 데 사용됩니다.
4. 밥이 받은 메시지를 복호화합니다. 복호화된 넌스가 자신이 보낸 넌스와 같으면 앨리스가 인증됩니다.

<img width="426" height="214" alt="Image" src="https://github.com/user-attachments/assets/4a4650fc-0898-4612-a875-b1857e76a0c5" />

프로토콜 *ap4.0*은 그림 8.18에 설명되어 있습니다.

### ap4.0의 보안 분석

일회용 값 *R*을 사용하고 반환된 값 **K_A-B(R)**을 확인함으로써, 밥은 앨리스가 자신이 말하는 사람임을(그녀가 *R*을 암호화하는 데 필요한 비밀키 값을 알고 있으므로) 그리고 라이브임을(그녀가 밥이 방금 생성한 넌스 *R*을 암호화했으므로) 확신할 수 있습니다.

### 공개키 암호화를 사용한 인증

넌스와 대칭키 암호화의 사용이 *ap4.0*의 기초를 형성합니다.
자연스러운 질문은 대칭키 암호화 대신 넌스와 **공개키 암호화**를 사용하여 인증 문제를 해결할 수 있는지입니다.

이 문제는 장 끝의 문제들에서 탐구됩니다.
