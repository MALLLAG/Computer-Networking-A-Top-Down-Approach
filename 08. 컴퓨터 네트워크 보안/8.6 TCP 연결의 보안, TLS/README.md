## 8.6 TCP 연결의 보안: TLS

이전 절에서는 암호화 기술이 기밀성, 데이터 무결성, 종단점 인증을 특정 애플리케이션인 **이메일**에 제공하는 방법을 살펴보았습니다.
이 절에서는 암호화가 TCP 보안 서비스(기밀성, 데이터 무결성, 종단점 인증)를 포함하여 어떻게 **TCP를 향상**시킬 수 있는지 살펴봅니다.

TCP의 이러한 향상된 버전은 일반적으로 **TLS(Transport Layer Security)** 라고 하며, HTTP에서 IEFT BPF 5246으로 표준화되었습니다.
TLS의 이전 버전인 **SSL 버전 3**이 있으며, 이 프로토콜에 대한 유사한 버전은 HTTP [RFC 8446]로 표준화되었습니다.

SSL 프로토콜은 원래 Netscape에서 설계되었지만, 그 뒤에 있는 기본 아이디어는 Netscape의 작업보다 앞선 것입니다(예: [Woo 1994] 참조).
TCP의 초기 보안 버전인 SSL 이후 TLS는 광범위한 배포를 누렸습니다.
TLS는 모든 인기 있는 웹 브라우저와 웹 서버에서 지원되며, Gmail 및 본질적으로 모든 인터넷 상거래 사이트(Amazon, eBay, Taobao 포함)에서 사용됩니다.

매년 수천억 달러가 TLS를 통해 인터넷에서 소비됩니다.
실제로, 신용카드로 인터넷을 통해 무언가를 구매한 적이 있다면, 브라우저와 서버 간의 통신은 거의 확실히 TLS를 통해 이루어졌습니다.
(URL이 **https:**로 시작하면 브라우저가 TLS를 사용하고 있음을 확인할 수 있습니다.)

### TLS의 필요성 이해하기

TLS의 필요성을 이해하기 위해 일반적인 인터넷 상거래 시나리오를 살펴봅시다.

밥이 웹을 서핑하며 Alice Incorporated 사이트에 도착했습니다. 이 사이트는 향수를 판매합니다.
Alice Incorporated 사이트에는 밥이 향수의 종류와 원하는 수량, 주소, 결제 카드 번호를 입력하는 양식이 표시됩니다.
밥은 이 정보를 입력하고 Sabmit을 클릭하여 구매를 예상합니다.

그러면 밥은 다음 달 결제 카드 명세서에서 구매 금액의 10배를 청구받습니다.
자신의 주문 기록을 확인해보니 예상한 것보다 10배 많은 향수 병을 주문한 것으로 나와 있습니다.

### 보안이 없을 때 발생할 수 있는 문제

- **기밀성(암호화)이 사용되지 않으면**, 침입자가 밥의 주문을 가로채 결제 카드 정보를 얻을 수 있습니다. 그러면 침입자는 밥의 돈과 신용카드 번호로 밥의 비용으로 구매할 수 있습니다.

- **데이터 무결성이 사용되지 않으면**, 침입자가 밥의 주문을 수정하여 원하는 것보다 10배 많은 향수 병을 구매하게 할 수 있습니다.

- **서버 인증이 사용되지 않으면**, 서버가 Alice Incorporated로 가장하는 트루디가 유지 관리하는 사이트를 표시할 수 있습니다. 밥의 주문을 받은 후 트루디는 밥의 돈을 가져가고 도주할 수 있습니다. 또는 트루디가 밥의 이름, 주소, 신용카드 번호를 수집하여 신원 도용을 할 수 있습니다.

TLS는 TCP에 기밀성, 데이터 무결성, 서버 인증 및 클라이언트 인증을 향상시켜 이러한 문제를 해결합니다.

### TLS의 위치

<img width="473" height="245" alt="Image" src="https://github.com/user-attachments/assets/dca43f33-ebfc-47b7-adba-5cf676064105" />

TLS는 HTTP를 통해 발생하는 트랜잭션에 보안을 제공하는 데 자주 사용됩니다.
그러나 TLS가 TCP 위에서 실행되기 때문에 TCP를 실행하는 **모든 애플리케이션**에서 사용할 수 있습니다.
TLS는 소켓과 유사하고 TCP의 API와 유사한 간단한 **API(Application Programming Interface)** 를 제공합니다.

애플리케이션이 TLS를 사용하려 할 때, 애플리케이션에는 SSL 클래스/라이브러리가 포함됩니다.
그림 8.24에서 보듯이, TLS는 기술적으로 애플리케이션 계층에 있지만, 개발자 관점에서는 보안 서비스로 향상된 TCP 서비스를 제공하는 **전송 프로토콜**입니다.

---

## 8.6.1 큰 그림

TLS의 **왜**와 **어떻게**에 대한 큰 그림 이해를 얻을 수 있는 TLS의 단순화된 버전을 설명하는 것으로 시작합니다.
이 단순화된 버전의 TLS를 **"almost-TLS"** 라고 부르겠습니다.
almost-TLS를 설명한 후, 다음 하위 절에서 세부 사항을 채우면서 실제 TLS를 설명합니다.

Almost-TLS(및 TLS)는 세 단계로 구성됩니다:
1. **핸드셰이크(handshake)**
2. **키 유도(key derivation)**
3. **데이터 전송(data transfer)**

이 세 단계를 클라이언트(밥)와 서버(앨리스) 간의 통신 세션에 대해 설명합니다.
앨리스는 자신의 공개키에 신원을 바인딩하는 개인/공개 키 쌍과 인증서를 가지고 있습니다.

### 핸드셰이크 (Handshake)

<img width="512" height="383" alt="Image" src="https://github.com/user-attachments/assets/2f526f3c-1bd7-40b1-83ad-74a3296e5dd7" />

핸드셰이크 단계에서 밥은:
- (a) 앨리스와 **TCP 연결을 설정**합니다
- (b) 앨리스가 **정말 앨리스인지 확인**합니다
- (c) TLS 세션에 필요한 모든 대칭키를 생성하는 데 앨리스와 밥이 사용할 **마스터 비밀키(master secret key)** 를 앨리스에게 보냅니다

이 세 단계는 그림 8.25에 나와 있습니다.

TCP 연결이 설정되면:
1. 밥이 앨리스에게 **hello 메시지**를 보냅니다
2. 앨리스가 자신의 공개키를 포함하는 **인증서**로 응답합니다
3. 8.3절에서 논의했듯이, 인증서가 CA에 의해 인증되었기 때문에 밥은 인증서의 공개키가 앨리스에게 속함을 확실히 알 수 있습니다
4. 밥은 **마스터 시크릿(MS, Master Secret)** 을 생성합니다(이 TLS 세션에만 사용됨)
5. MS를 앨리스의 공개키로 암호화하여 **암호화된 마스터 시크릿(EMS, Encrypted Master Secret)** 을 생성합니다
6. EMS를 앨리스에게 보냅니다
7. 앨리스가 자신의 개인키로 EMS를 복호화하여 MS를 얻습니다

이 단계 후에 밥과 앨리스(그리고 아무도 아닌)만이 이 TLS 세션의 마스터 시크릿을 알게 됩니다.

### 키 유도 (Key Derivation)

원칙적으로, 이제 밥과 앨리스가 공유하는 MS는 모든 후속 암호화 및 데이터 무결성 검사를 위한 대칭 세션 키로 사용될 수 있습니다.
그러나 일반적으로 앨리스와 밥이 각각 다른 암호화 키를 사용하고, 암호화와 무결성 검사에 다른 키를 사용하는 것이 **더 안전**하다고 간주됩니다.

따라서 앨리스와 밥은 MS를 사용하여 **네 개의 키**를 생성합니다:

- **E_B** = 밥에서 앨리스로 전송되는 데이터의 세션 암호화 키
- **M_B** = 밥에서 앨리스로 전송되는 데이터의 세션 HMAC 키 (HMAC [RFC 2104]는 8.3.2절에서 배운 표준화된 해시 메시지 인증 코드(MAC)입니다)
- **E_A** = 앨리스에서 밥으로 전송되는 데이터의 세션 암호화 키
- **M_A** = 앨리스에서 밥으로 전송되는 데이터의 세션 HMAC 키

앨리스와 밥은 각각 MS에서 네 개의 키를 생성합니다.
이것은 MS를 네 개의 키로 단순히 슬라이싱하여 수행할 수 있습니다.
(그러나 *실제* TLS에서는 조금 더 복잡합니다.)

키 유도 단계가 끝나면, 앨리스와 밥 모두 네 개의 키를 가집니다.
두 개의 암호화 키는 데이터를 암호화하는 데 사용되고, 두 개의 HMAC 키는 데이터의 무결성을 검증하는 데 사용됩니다.

### 데이터 전송 (Data Transfer)

이제 앨리스와 밥이 같은 네 개의 세션 키(E_B, M_B, E_A, M_A)를 공유하므로, TCP 연결을 통해 서로에게 보안 데이터를 전송할 수 있습니다.

TCP는 바이트 스트림 프로토콜이므로, TLS가 즉석에서 애플리케이션 데이터를 암호화하고 암호화된 데이터를 즉석에서 TCP에 전달하는 것이 자연스러운 접근 방식일 것입니다.

그러나 이렇게 하면 무결성 검사를 위한 HMAC을 어디에 넣을까요?
확실히 밥의 모든 데이터의 무결성을 검증하기 위해 전체 TCP 세션이 끝날 때까지 기다리고 싶지 않습니다!

이 문제를 해결하기 위해 TLS는:
1. 데이터 스트림을 **레코드(records)** 로 분할합니다
2. 각 레코드에 무결성 검사를 위한 **HMAC**을 추가합니다
3. **레코드+HMAC**을 암호화합니다

HMAC을 생성하기 위해 밥은 레코드 데이터와 키 M_B를 해시 함수에 입력합니다(8.3절에서 논의).
레코드+HMAC 패키지를 암호화하기 위해 밥은 자신의 세션 암호화 키 E_B를 사용합니다.
이 암호화된 패키지는 인터넷을 통해 전송하기 위해 TCP에 전달됩니다.

### 중간자 공격 문제

이 접근 방식이 많은 부분을 해결하지만, 전체 메시지 스트림에 대한 데이터 무결성을 제공할 때 **완벽하지 않습니다**.

특히 트루디가 중간자(woman-in-the-middle)로서 앨리스와 밥 사이에서 전송되는 TCP 세그먼트 스트림에서 세그먼트를 삽입, 삭제, 교체할 수 있다고 가정합시다.

예를 들어, 트루디가 밥이 보낸 두 세그먼트를 캡처하고, 세그먼트의 순서를 바꾸고, TCP 시퀀스 번호(암호화되지 않음)를 조정한 다음, 두 개의 역순 세그먼트를 앨리스에게 보낼 수 있습니다.

각 TCP 세그먼트가 정확히 하나의 레코드를 캡슐화한다고 가정하면, 앨리스가 이러한 세그먼트를 처리하는 방법을 살펴봅시다:

1. 앨리스의 TCP는 모든 것이 정상이라고 생각하고 두 레코드를 TLS 하위 계층에 전달합니다
2. 앨리스의 TLS는 두 레코드를 복호화합니다
3. 앨리스의 TLS는 각 레코드의 HMAC을 사용하여 두 레코드의 데이터 무결성을 검증합니다
4. TLS는 두 레코드의 복호화된 바이트 스트림을 애플리케이션 계층에 전달합니다

그러나 레코드의 역순으로 인해 앨리스가 받은 완전한 바이트 스트림은 **올바른 순서가 아닙니다!**

### 시퀀스 번호로 해결

이 문제에 대한 해결책은 **시퀀스 번호**를 사용하는 것입니다.

TLS는 다음과 같이 합니다:
1. 밥은 0에서 시작하여 보내는 각 TLS 레코드에 대해 증가하는 **시퀀스 번호 카운터**를 유지합니다
2. 밥은 실제로 레코드 자체에 시퀀스 번호를 포함하지 않지만, HMAC을 계산할 때 **시퀀스 번호를 HMAC 계산에 포함**합니다
3. 따라서 HMAC은 이제 데이터 + HMAC 키 M_B + **현재 시퀀스 번호**의 해시입니다
4. 앨리스는 밥의 시퀀스 번호를 추적하여, HMAC 계산에 적절한 시퀀스 번호를 포함함으로써 레코드의 데이터 무결성을 검증할 수 있습니다

TLS 시퀀스 번호의 이러한 사용은 트루디가 세그먼트 재정렬이나 재생과 같은 **중간자 공격**을 수행하는 것을 방지합니다.

### TLS 레코드 (TLS Record)

<img width="504" height="288" alt="Image" src="https://github.com/user-attachments/assets/0712753b-18c6-4759-9c8e-d60bf1118948" />

TLS 레코드(almost-TLS 레코드 포함)는 그림 8.26에 나와 있습니다.

레코드는 다음 필드로 구성됩니다:
- **Type 필드**: 레코드가 핸드셰이크 메시지인지 애플리케이션 데이터를 포함하는 메시지인지 나타냅니다. TLS 연결을 닫는 데에도 사용됩니다.
- **Version 필드**: 자체 설명적입니다
- **Length 필드**: 수신 측의 TLS가 들어오는 TCP 바이트 스트림에서 TLS 레코드를 추출하는 데 사용합니다
- **Data 필드**: 실제 데이터
- **HMAC 필드**: 무결성 검사

처음 세 필드는 **암호화되지 않습니다**.
Data와 HMAC 필드는 **E_B로 암호화**됩니다.

---

## 8.6.2 더 완전한 그림

이전 하위 절에서 almost-TLS 프로토콜을 다루었습니다. 이것은 TLS의 왜와 어떻게에 대한 기본적인 이해를 제공했습니다.
이제 기본적인 이해가 있으므로 실제 TLS 프로토콜의 핵심을 조금 더 깊이 파고들어 살펴볼 수 있습니다.

### TLS 핸드셰이크 (TLS Handshake)

SSL은 앨리스와 밥이 **특정 대칭키 알고리즘이나 특정 공개키 알고리즘**을 사용하도록 강제하지 않습니다.
대신 TLS는 앨리스와 밥이 핸드셰이크 단계 동안 TLS 세션 시작 시 **암호화 알고리즘에 동의**할 수 있게 합니다.

또한 핸드셰이크 단계 동안 앨리스와 밥은 세션 키(E_B, M_B, E_A, M_A) 생성에 사용되는 **넌스(nonces)** 를 서로에게 보냅니다.

실제 TLS 핸드셰이크의 단계는 다음과 같습니다:

1. **클라이언트가 지원하는 암호화 알고리즘 목록과 클라이언트 넌스를 보냅니다.**

2. **서버가 목록에서 대칭 알고리즘(예: AES), 공개키 알고리즘(예: 특정 키 길이의 RSA), HMAC 키와 함께 HMAC 알고리즘(MD5 또는 SHA-1)을 선택합니다.** 서버는 클라이언트에게 선택 사항, 인증서, 서버 넌스를 다시 보냅니다.

3. **클라이언트가 인증서를 검증하고, 서버의 공개키를 추출하고, Pre-Master Secret(PMS)을 생성하고, PMS를 서버의 공개키로 암호화하여 서버에 보냅니다.**

4. **동일한 키 유도 함수(TLS 표준에 지정됨)를 사용하여, 클라이언트와 서버가 PMS와 넌스로부터 독립적으로 Master Secret(MS)을 계산합니다.** 그런 다음 MS를 슬라이싱하여 두 개의 암호화 키와 두 개의 HMAC 키를 생성합니다. 또한 선택한 대칭 암호가 CBC를 사용하는 경우(예: 3DES 또는 AES), 연결의 양쪽에 대해 하나씩 두 개의 **초기화 벡터(IV)** 도 MS에서 얻습니다. 이후로 클라이언트와 서버 간에 전송되는 모든 메시지는 암호화되고(HMAC으로) 인증됩니다.

5. **클라이언트가 모든 핸드셰이크 메시지의 HMAC을 보냅니다.**

6. **서버가 모든 핸드셰이크 메시지의 HMAC을 보냅니다.**

### 핸드셰이크 보호

마지막 두 단계는 핸드셰이크를 **변조로부터 보호**합니다.

이를 확인하기 위해, 1단계에서 클라이언트가 일반적으로 알고리즘 목록(일부는 강하고 일부는 약함)을 제공한다는 것을 관찰하세요.
이 알고리즘 목록은 암호화 알고리즘과 키가 아직 합의되지 않았기 때문에 **평문으로 전송**됩니다.

중간자로서 트루디가 목록에서 더 강한 알고리즘을 삭제하여 클라이언트가 약한 알고리즘을 선택하도록 강제할 수 있습니다.
이러한 변조 공격을 방지하기 위해, 5단계에서 클라이언트는 보내고 받은 모든 핸드셰이크 메시지의 연결에 대한 HMAC을 보냅니다.

서버는 이 HMAC을 받고 보낸 핸드셰이크 메시지의 HMAC과 비교할 수 있습니다.
불일치가 있으면 서버는 연결을 종료할 수 있습니다.
마찬가지로 서버는 자신이 본 핸드셰이크 메시지의 HMAC을 보내어 클라이언트가 불일치를 확인할 수 있게 합니다.

### 넌스의 필요성

1단계와 2단계에 왜 넌스가 있는지 궁금할 수 있습니다.
시퀀스 번호만으로는 세그먼트 재생 공격을 방지하기에 충분하지 않을까요?

답은 그렇습니다. 하지만 시퀀스 번호만으로는 **"연결 재생 공격(connection replay attack)"** 을 방지하지 못합니다.

다음 연결 재생 공격을 고려해 봅시다:
트루디가 앨리스와 밥 사이의 모든 메시지를 스니핑한다고 가정합니다.
다음 날, 트루디가 밥으로 가장하여 앨리스에게 전날 밥이 앨리스에게 보낸 것과 **똑같은 메시지 시퀀스**를 보냅니다.

앨리스가 넌스를 사용하지 않으면, 전날 보낸 것과 똑같은 메시지 시퀀스로 응답합니다.
앨리스는 수상한 것을 의심하지 않습니다. 각 메시지가 무결성 검사를 통과하기 때문입니다.

앨리스가 전자상거래 서버라면, 밥이 두 번째 주문을 한다고(정확히 같은 것에 대해) 생각할 것입니다.

반면, 프로토콜에 넌스를 포함하면, 앨리스는 각 TCP 세션에 대해 **다른 넌스를 보내어**, 두 날 동안 암호화 키가 다르게 됩니다.
따라서 앨리스가 트루디로부터 재생된 TLS 레코드를 받으면, 레코드가 무결성 검사에 **실패**하고 가짜 전자상거래 거래가 성공하지 못합니다.

요약하면, TLS에서 **넌스는 "연결 재생 공격"을 방어**하는 데 사용되고, **시퀀스 번호는 진행 중인 세션 동안 개별 패킷의 재생을 방어**하는 데 사용됩니다.

### 연결 종료 (Connection Closure)

어느 시점에서 밥이나 앨리스가 TLS 세션을 종료하고 싶어할 것입니다.
한 가지 접근 방식은 밥이 단순히 기본 TCP 연결을 종료하여 TLS 세션을 종료하는 것입니다.
즉, 밥이 앨리스에게 **TCP FIN 세그먼트**를 보내는 것입니다.

그러나 이러한 단순한 설계는 **절단 공격(truncation attack)** 의 여지를 만듭니다.
트루디가 다시 중간자로 나타나 진행 중인 TLS 세션 중간에서 TCP FIN으로 세션을 일찍 종료합니다.

트루디가 이렇게 하면, 앨리스는 밥의 데이터 전부를 받았다고 생각하지만 실제로는 일부만 받은 것입니다.

이 문제에 대한 해결책은 type 필드에 레코드가 TLS 세션을 종료하는 역할을 하는지 **표시**하는 것입니다.
(TLS type은 평문으로 전송되지만, 레코드의 HMAC을 사용하여 수신자에서 인증됩니다.)

이러한 필드를 포함함으로써, 앨리스가 종료 TLS 레코드를 받기 전에 TCP FIN을 받으면, 뭔가 수상한 일이 일어나고 있음을 알 수 있습니다.

이것으로 TLS에 대한 소개를 마칩니다.
TLS가 8.2절과 8.3절에서 논의한 많은 암호화 원리를 사용함을 보았습니다.
TLS를 더 깊이 탐구하고 싶은 독자는 SSL/TLS에 대한 Rescorla의 매우 읽기 쉬운 책 [Rescorla 2001]을 읽을 수 있습니다.
