# 8.9 운영 보안: 방화벽과 침입 탐지 시스템

인터넷은 안전한 장소가 아니며, 온갖 종류의 악의적인 공격자들이 존재한다. 네트워크 관리자의 관점에서 보면, 세상은 크게 두 가지 진영으로 나뉜다:
- **좋은 사람들(good guys)**: 조직의 네트워크에 속하며, 네트워크 내부의 자원에 접근해야 하는 사람들
- **나쁜 사람들(bad guys)**: 그 외의 모든 사람들로, 네트워크 자원에 대한 접근을 제한해야 하는 대상

이러한 환경에서 네트워크 보안은 **운영 장치(operational devices)**를 통해 구현된다:
- **방화벽(Firewalls)**: 침입 탐지 시스템
- **침입 탐지 시스템(IDS, Intrusion Detection Systems)**
- **침입 방지 시스템(IPS, Intrusion Prevention Systems)**

---

## 8.9.1 방화벽 (Firewalls)

**방화벽(Firewall)**은 조직의 내부 네트워크를 외부 인터넷으로부터 격리시키는 하드웨어와 소프트웨어의 조합이다. 방화벽은 네트워크 관리자가 내부 네트워크와 외부 세계 사이의 트래픽 흐름을 관리함으로써 외부 세계에 대한 접근을 제어할 수 있게 해준다.

### 방화벽의 세 가지 목표

1. **모든 트래픽이 방화벽을 통과**: 외부에서 내부로, 그리고 그 반대 방향의 모든 트래픽이 방화벽을 통과해야 한다
2. **승인된 트래픽만 통과 허용**: 로컬 보안 정책에 의해 정의된 대로, 승인된 트래픽만 통과가 허용된다
3. **방화벽 자체의 침투 불가**: 방화벽 자체가 침투에 면역이어야 한다. 제대로 설계되거나 설치되지 않으면 침해당할 수 있으며, 이는 보안에 대한 거짓된 안전감만 제공할 뿐이다

방화벽은 세 가지 범주로 분류할 수 있다: **전통적 패킷 필터(Traditional Packet Filters)**, **상태 유지 필터(Stateful Filters)**, **애플리케이션 게이트웨이(Application Gateways)**.

---

### 전통적 패킷 필터 (Traditional Packet Filters)

조직은 일반적으로 내부 네트워크를 ISP에 연결하는 게이트웨이 라우터를 가지고 있다. 내부 네트워크를 떠나거나 들어오는 모든 트래픽은 이 라우터를 통과하며, 이 라우터에서 **패킷 필터링(Packet Filtering)**이 발생한다.

패킷 필터는 각 데이터그램을 개별적으로 검사하여, 관리자가 지정한 규칙에 따라 데이터그램의 통과 여부를 결정한다.

#### 필터링 결정 기준

- **IP 출발지 또는 목적지 주소**
- **IP 데이터그램 필드의 프로토콜 유형**: TCP, UDP, ICMP, OSPF 등
- **TCP 또는 UDP 출발지 및 목적지 포트**
- **TCP 플래그 비트**: SYN, ACK 등
- **ICMP 메시지 유형**
- 네트워크를 떠나는 데이터그램과 들어오는 데이터그램에 대한 **서로 다른 규칙**
- 서로 다른 라우터 인터페이스에 대한 **서로 다른 규칙**

#### 정책과 필터링 규칙 예시 (Table 8.5)

| 정책 | 방화벽 설정 |
|------|-------------|
| 외부 웹 접근 금지 | 모든 IP 주소의 포트 80으로 가는 송신 패킷 차단 |
| 조직의 공개 웹 서버 외 수신 TCP 연결 금지 | 130.207.244.203, 포트 80을 제외한 모든 IP로의 수신 TCP SYN 패킷 차단 |
| 웹 라디오의 대역폭 독점 방지 | DNS 패킷을 제외한 모든 수신 UDP 패킷 차단 |
| 네트워크가 smurf DoS 공격에 사용되는 것 방지 | "브로드캐스트" 주소(예: 130.207.255.255)로 가는 모든 ICMP ping 패킷 차단 |
| 네트워크가 traceroute되는 것 방지 | 모든 송신 ICMP TTL 만료 트래픽 차단 |

#### TCP ACK 비트를 이용한 필터링

조직이 내부 클라이언트가 외부 서버에 연결하는 것은 허용하면서, 외부 클라이언트가 내부 서버에 연결하는 것은 차단하고 싶을 때 유용한 기법이다.

- TCP 연결의 첫 번째 세그먼트는 ACK 비트가 0으로 설정됨
- 연결의 다른 모든 세그먼트는 ACK 비트가 1로 설정됨
- 따라서 ACK 비트가 0인 모든 수신 세그먼트를 필터링하면 외부에서 시작되는 모든 TCP 연결을 차단할 수 있음

#### 접근 제어 목록 예시 (Table 8.6)

| action | source address | dest address | protocol | source port | dest port | flag bit |
|--------|---------------|--------------|----------|-------------|-----------|----------|
| allow | 222.22/16 | outside of 222.22/16 | TCP | > 1023 | 80 | any |
| allow | outside of 222.22/16 | 222.22/16 | TCP | 80 | > 1023 | ACK |
| allow | 222.22/16 | outside of 222.22/16 | UDP | > 1023 | 53 | — |
| allow | outside of 222.22/16 | 222.22/16 | UDP | 53 | > 1023 | — |
| deny | all | all | all | all | all | all |

이 접근 제어 목록은 내부 사용자가 웹을 서핑할 수 있도록 허용한다:
- 첫 번째 규칙: 목적지 포트 80으로 가는 모든 TCP 패킷이 조직의 네트워크를 떠나도록 허용
- 두 번째 규칙: 출발지 포트 80이고 ACK 비트가 설정된 TCP 패킷이 조직의 네트워크로 들어오도록 허용

---

### 상태 유지 패킷 필터 (Stateful Packet Filters)

전통적 패킷 필터에서는 각 패킷에 대해 필터링 결정이 독립적으로 이루어진다. **상태 유지 필터(Stateful Filter)**는 실제로 TCP 연결을 추적하고, 이 정보를 사용하여 필터링 결정을 내린다.

#### 상태 유지 필터의 동작 방식

상태 유지 필터는 모든 진행 중인 TCP 연결을 **연결 테이블(Connection Table)**에서 추적한다:
- 3-way 핸드셰이크(SYN, SYNACK, ACK)를 관찰하여 새 연결의 시작을 감지
- FIN 패킷을 보면 연결의 종료를 감지
- 일정 시간(예: 60초) 동안 활동이 없으면 연결이 종료된 것으로 (보수적으로) 가정

#### 연결 테이블 예시 (Table 8.7)

| source address | dest address | source port | dest port |
|---------------|--------------|-------------|-----------|
| 222.22.1.7 | 37.96.87.123 | 12699 | 80 |
| 222.22.93.2 | 199.1.205.23 | 37654 | 80 |
| 222.22.65.143 | 203.77.240.43 | 48712 | 80 |

#### 상태 유지 필터의 접근 제어 목록 (Table 8.8)

| action | source address | dest address | protocol | source port | dest port | flag bit | check conxion |
|--------|---------------|--------------|----------|-------------|-----------|----------|---------------|
| allow | 222.22/16 | outside of 222.22/16 | TCP | > 1023 | 80 | any | |
| allow | outside of 222.22/16 | 222.22/16 | TCP | 80 | > 1023 | ACK | X |
| allow | 222.22/16 | outside of 222.22/16 | UDP | > 1023 | 53 | — | |
| allow | outside of 222.22/16 | 222.22/16 | UDP | 53 | > 1023 | — | X |
| deny | all | all | all | all | all | all | |

**"check conxion"** 열은 연결 테이블을 확인해야 하는지를 나타낸다.

#### 상태 유지 필터의 장점

공격자가 조직의 네트워크에 악의적인 패킷을 보내려고 시도하는 경우:
1. 공격자가 TCP 출발지 포트 80과 ACK 플래그가 설정된 데이터그램을 보냄
2. 방화벽이 접근 제어 목록을 확인 → 연결 테이블도 확인해야 함을 발견
3. 연결 테이블을 확인 → 이 패킷이 진행 중인 TCP 연결의 일부가 아님을 발견
4. 패킷 거부

---

### 애플리케이션 게이트웨이 (Application Gateway)

패킷 수준 필터링은 IP/TCP/UDP 헤더의 내용을 기반으로 조잡한 필터링만 수행할 수 있다. 사용자 인증이나 애플리케이션 데이터 기반 정책 결정과 같은 작업은 전통적이고 상태 유지 필터의 능력을 벗어난다.

**애플리케이션 게이트웨이(Application Gateway)**는 IP/TCP/UDP 헤더를 넘어서 애플리케이션 데이터를 기반으로 정책 결정을 내리는 애플리케이션별 서버이다. 모든 애플리케이션 데이터(인바운드 및 아웃바운드)가 이 서버를 통과해야 한다.

#### 애플리케이션 게이트웨이의 동작 예시 (Telnet)

1. 내부 사용자가 외부로 Telnet하려면 먼저 애플리케이션 게이트웨이와 Telnet 세션을 설정해야 함
2. 게이트웨이에서 실행되는 애플리케이션이 사용자 ID와 비밀번호를 요청
3. 애플리케이션 게이트웨이가 사용자에게 외부로 Telnet할 권한이 있는지 확인
4. 권한이 없으면 게이트웨이가 연결을 종료
5. 권한이 있으면:
   - 게이트웨이가 사용자에게 연결할 외부 호스트 이름을 요청
   - 게이트웨이와 외부 호스트 간의 Telnet 세션을 설정
   - 사용자로부터 오는 모든 데이터를 외부 호스트로 중계하고, 그 반대도 마찬가지

#### 애플리케이션 게이트웨이의 단점

1. 각 애플리케이션마다 별도의 애플리케이션 게이트웨이가 필요
2. 모든 데이터가 게이트웨이를 통해 중계되므로 **성능 저하** 발생
3. 클라이언트 소프트웨어가 게이트웨이에 연결하는 방법과 어떤 외부 서버에 연결할지를 알아야 함

내부 네트워크는 종종 Telnet, HTTP, FTP, 이메일 등을 위한 여러 애플리케이션 게이트웨이를 가진다.

---

### CASE HISTORY: 익명성과 프라이버시 (Anonymity and Privacy)

논란이 있는 웹사이트(예: 정치 활동가 사이트)를 방문하고 싶은데 다음을 원하지 않는다고 가정하자:
1. 웹사이트에 자신의 IP 주소가 노출되는 것
2. 로컬 ISP가 어떤 사이트를 방문하는지 아는 것
3. 로컬 ISP가 사이트와 교환하는 데이터를 보는 것

전통적인 방식으로 직접 연결하면, 암호화 없이는 세 가지 모두에서 실패한다. SSL을 사용하더라도 처음 두 가지에서 실패한다.

#### 프라이버시와 익명성을 위한 해결책: 프록시 서버

**익명화 프록시(Anonymizing Proxy)**와 SSL을 조합하여 사용할 수 있다:
1. 신뢰할 수 있는 프록시에 SSL 연결을 만듦
2. 이 SSL 연결을 통해 원하는 페이지에 대한 HTTP 요청을 보냄
3. 프록시가 SSL로 암호화된 HTTP 요청을 복호화하고 평문 HTTP 요청을 웹사이트로 전달
4. 웹사이트가 프록시에 응답하고, 프록시가 SSL을 통해 응답을 전달

**프록시 방식의 한계**: 프록시가 모든 것을 알고 있음 - IP 주소, 방문하는 사이트의 IP 주소, 평문으로 교환되는 모든 트래픽. 프록시의 신뢰성에 전적으로 의존하게 됨.

#### TOR (The Onion Router)

더 강력한 접근 방식으로, **TOR 익명화 및 프라이버시 서비스**가 있다:
- TOR은 독립적인 개인들이 프록시 풀에 프록시를 기여할 수 있게 함
- 사용자가 TOR을 사용하여 서버에 연결하면, TOR이 프록시 풀에서 무작위로 **세 개의 프록시 체인**을 선택
- 클라이언트와 서버 간의 모든 트래픽을 이 체인을 통해 라우팅
- 프록시들이 공모하지 않는다고 가정하면, 누구도 IP 주소와 대상 웹사이트 간의 통신이 일어났는지 알 수 없음
- 평문이 마지막 프록시와 서버 사이에서 전송되지만, 마지막 프록시는 평문을 보내고 받는 IP 주소가 무엇인지 알지 못함

---

## 8.9.2 침입 탐지 시스템 (Intrusion Detection Systems)

패킷 필터(전통적 및 상태 유지)는 방화벽을 통과시킬 패킷을 결정할 때 IP, TCP, UDP, ICMP 헤더 필드를 검사한다. 그러나 많은 유형의 공격을 탐지하려면 **심층 패킷 검사(Deep Packet Inspection)**가 필요하다 - 헤더 필드를 넘어서 패킷이 운반하는 실제 애플리케이션 데이터까지 살펴보아야 한다.

### IDS vs IPS

- **침입 탐지 시스템(IDS, Intrusion Detection System)**: 잠재적으로 악의적인 트래픽을 관찰할 때 경고를 생성하는 장치
- **침입 방지 시스템(IPS, Intrusion Prevention System)**: 의심스러운 트래픽을 필터링(차단)하는 장치

두 시스템 모두:
- 모든 패킷의 헤더를 검사할 뿐만 아니라 (패킷 필터처럼)
- 심층 패킷 검사도 수행 (패킷 필터와 달리)

### IDS가 탐지할 수 있는 공격 유형

- **네트워크 매핑** (예: nmap에서 발생)
- **포트 스캔**
- **TCP 스택 스캔**
- **DoS 대역폭 범람 공격**
- **웜과 바이러스**
- **OS 취약점 공격**
- **애플리케이션 취약점 공격**

---

### 비무장 지대 (DMZ, Demilitarized Zone)

조직은 네트워크에 하나 이상의 IDS 센서를 배치할 수 있다. 여러 센서가 배치되면 일반적으로 협력하여 작동하며, 의심스러운 트래픽 활동에 대한 정보를 중앙 IDS 프로세서로 보내고, 이 프로세서가 정보를 수집 및 통합하여 적절한 경우 네트워크 관리자에게 알람을 보낸다.

조직은 네트워크를 두 영역으로 분할할 수 있다:
- **고보안 영역**: 패킷 필터와 애플리케이션 게이트웨이로 보호되고 IDS 센서로 모니터링
- **저보안 영역 (DMZ)**: 패킷 필터로만 보호되지만 IDS 센서로 모니터링

**DMZ**에는 외부 세계와 통신해야 하는 조직의 서버가 포함된다:
- 공개 웹 서버
- 권한 있는 DNS 서버

#### 왜 여러 IDS 센서를 사용하는가?

IDS는 심층 패킷 검사를 수행할 뿐만 아니라, 수만 개의 "시그니처"와 각 패킷을 비교해야 한다. 조직이 인터넷에서 기가비트/초의 트래픽을 수신하는 경우, 이는 상당한 양의 처리가 필요하다. IDS 센서를 더 하류에 배치하면 각 센서가 조직 트래픽의 일부만 보게 되어 더 쉽게 처리할 수 있다.

---

### IDS 시스템의 분류

IDS 시스템은 크게 **시그니처 기반 시스템(Signature-based Systems)**과 **이상 기반 시스템(Anomaly-based Systems)**으로 분류된다.

#### 시그니처 기반 IDS (Signature-based IDS)

**시그니처 기반 IDS**는 공격 시그니처의 광범위한 데이터베이스를 유지한다. 각 시그니처는 침입 활동과 관련된 규칙 집합이다.

**시그니처의 예**:
- 단일 패킷에 대한 특성 목록 (출발지/목적지 포트 번호, 프로토콜 유형, 패킷 페이로드의 특정 비트 문자열)
- 일련의 패킷과 관련된 규칙

**동작 방식**:
1. 시그니처 기반 IDS가 통과하는 모든 패킷을 스니핑
2. 각 스니핑된 패킷을 데이터베이스의 시그니처와 비교
3. 패킷(또는 일련의 패킷)이 데이터베이스의 시그니처와 일치하면 IDS가 경고 생성
4. 경고는 네트워크 관리자에게 이메일로 전송되거나, 네트워크 관리 시스템으로 전송되거나, 향후 검사를 위해 단순히 로깅될 수 있음

**시그니처 기반 IDS의 한계**:
1. 정확한 시그니처를 생성하려면 공격에 대한 사전 지식이 필요
2. 아직 기록되지 않은 새로운 공격에 대해 완전히 무력
3. 시그니처가 일치하더라도 공격의 결과가 아닐 수 있어 **오탐(false alarm)** 발생 가능
4. 모든 패킷을 광범위한 시그니처 컬렉션과 비교해야 하므로, IDS가 처리에 압도되어 많은 악성 패킷을 탐지하지 못할 수 있음

#### 이상 기반 IDS (Anomaly-based IDS)

**이상 기반 IDS**는 정상 운영 시 트래픽을 관찰하면서 **트래픽 프로파일**을 생성한다. 그런 다음 통계적으로 비정상적인 패킷 스트림을 찾는다.

**비정상적 패턴의 예**:
- ICMP 패킷의 비정상적인 비율
- 포트 스캔과 ping 스윕의 갑작스러운 지수적 증가

**이상 기반 IDS의 장점**:
- 기존 공격에 대한 사전 지식에 의존하지 않음
- 새로운, 문서화되지 않은 공격을 잠재적으로 탐지할 수 있음

**이상 기반 IDS의 단점**:
- 정상 트래픽과 통계적으로 비정상적인 트래픽을 구별하는 것이 매우 어려운 문제
- 현재까지 대부분의 IDS 배포는 시그니처 기반이지만, 일부는 이상 기반 기능을 포함

---

### Snort

**Snort**는 수십만 개의 기존 배포를 가진 공개 도메인, 오픈 소스 IDS이다.

**Snort의 특징**:
- Linux, UNIX, Windows 플랫폼에서 실행 가능
- Wireshark와 다른 많은 패킷 스니퍼가 사용하는 일반 스니핑 인터페이스 libpcap 사용
- 100 Mbps의 트래픽을 쉽게 처리 가능
- 기가비트/초 트래픽 속도의 설치에는 여러 Snort 센서가 필요할 수 있음

#### Snort 시그니처 예시

```
alert icmp $EXTERNAL_NET any -> $HOME_NET any
(msg:"ICMP PING NMAP"; dsize: 0; itype: 8;)
```

이 시그니처는 다음 조건을 만족하는 ICMP 패킷과 일치한다:
- 외부(`$EXTERNAL_NET`)에서 조직의 네트워크(`$HOME_NET`)로 들어오는 패킷
- ICMP 유형 8 (ICMP ping)
- 빈 페이로드 (dsize = 0)

nmap(섹션 1.6 참조)이 이러한 특정 특성을 가진 ping 패킷을 생성하므로, 이 시그니처는 nmap ping 스윕을 탐지하도록 설계되었다. 패킷이 이 시그니처와 일치하면 Snort가 "ICMP PING NMAP" 메시지를 포함하는 경고를 생성한다.

#### Snort 커뮤니티의 강점

Snort에서 가장 인상적인 점은 시그니처 데이터베이스를 유지하는 방대한 사용자 및 보안 전문가 커뮤니티이다:
- 새로운 공격이 발생하면 일반적으로 몇 시간 내에 Snort 커뮤니티가 공격 시그니처를 작성하고 릴리스
- 전 세계 수십만 개의 Snort 배포에서 다운로드
- 네트워크 관리자는 Snort 시그니처 구문을 사용하여 기존 시그니처를 수정하거나 완전히 새로운 것을 만들어 조직의 필요에 맞게 시그니처를 조정할 수 있음
