# 3.5 연결 지향형 전송: TCP

지금까지 신뢰할 수 있는 데이터 전송의 기본 원리를 살펴보았으니, 이제 TCP(Transmission Control Protocol) — 즉, 인터넷의 전송 계층에서 사용되는 연결 지향형 신뢰성 전송 프로토콜로 넘어가겠습니다. <br>
이 절에서는 TCP가 신뢰성 있는 데이터 전송을 제공하기 위해 어떻게 동작하는지를 알아봅니다. <br>
TCP는 오류 검출, 재전송, 누적 확인 응답(ACK), 타이머, 그리고 순서 번호 및 확인 번호용 헤더 필드 등 이전 절에서 다룬 여러 원리를 활용합니다. <br>

## 3.5.1 TCP 연결 (The TCP Connection)

TCP는 **연결 지향형(connection-oriented)** 프로토콜이라 불립니다. <br>
왜냐하면 하나의 애플리케이션 프로세스가 다른 프로세스로 데이터를 전송하기 전에, 두 프로세스는 먼저 “핸드셰이크(handshake)”를 수행해야 하기 때문입니다. <br>
즉, 두 프로세스는 데이터 전송의 파라미터를 설정하기 위해 몇몇 초기 세그먼트를 교환합니다.  <br>
TCP 연결이 설정되는 과정에서, 양쪽 호스트는 연결 상태를 관리하기 위한 여러 TCP 상태 변수들을 초기화합니다.

TCP의 “연결(connection)”은 회선 교환망의 회로(TDM 또는 FDM)와 같은 물리적 연결이 아니라, **논리적 연결(logical connection)** 입니다. <br>
이 연결 상태는 통신 중인 두 종단 시스템(end system)의 TCP에만 존재하며, 네트워크 내의 라우터나 링크 계층 스위치와 같은 중간 네트워크 장비에는 존재하지 않습니다. <br>
TCP는 오직 종단 시스템에서만 동작하며, 중간 장비는 TCP 연결 상태를 전혀 유지하지 않습니다. <br>
따라서 라우터들은 TCP 연결에 대해 완전히 무지하며, 단지 **데이터그램(datagram)** 을 처리할 뿐입니다.

TCP 연결은 **전이중(full-duplex)** 서비스를 제공합니다.  <br>
즉, 호스트 A의 프로세스가 호스트 B의 프로세스와 연결되어 있다면, A→B 방향과 B→A 방향으로 동시에 애플리케이션 계층 데이터가 흐를 수 있습니다. <br>
TCP 연결은 항상 **점대점(point-to-point)** 연결이며, 한 송신자와 한 수신자 간의 통신만을 지원합니다.  <br>
즉, TCP는 “멀티캐스팅(multicasting)” — 하나의 송신자가 여러 수신자에게 동시에 데이터를 보내는 기능을 지원하지 않습니다. <br>
TCP는 오직 두 호스트 간의 1:1 통신만을 처리합니다.

이제 TCP 연결이 어떻게 설정되는지 살펴보겠습니다. <br>
한 호스트의 프로세스가 다른 호스트의 프로세스와 연결을 맺고자 할 때, 연결을 시작하는 쪽을 **클라이언트 프로세스(client process)**, 연결 요청을 수락하는 쪽을 **서버 프로세스(server process)** 라고 부릅니다. <br>
클라이언트 애플리케이션은 클라이언트 전송 계층에 연결 요청을 알리고, 서버의 특정 프로세스와 연결을 맺기 위해 다음 명령을 호출합니다.

여기서 `serverName`은 서버의 이름을, `serverPort`는 서버 내 프로세스를 식별합니다. <br>
클라이언트의 TCP는 서버의 TCP와 연결을 설정하기 위해 일련의 세그먼트를 교환합니다.

즉,
1. 클라이언트가 첫 번째 TCP 세그먼트를 전송하고,
2. 서버가 두 번째 세그먼트로 응답하며,
3. 클라이언트가 세 번째 세그먼트로 다시 응답합니다.

이 세 단계의 과정이 바로 **3-way handshake(3방향 핸드셰이크)** 입니다.  <br>
앞의 두 세그먼트는 페이로드(응용 계층 데이터)를 포함하지 않으며, 세 번째 세그먼트만이 페이로드를 포함할 수 있습니다.

### TCP 데이터 전송 과정

TCP 연결이 설정되면, 두 애플리케이션 프로세스는 서로 데이터를 전송할 수 있습니다.   <br>
클라이언트 프로세스는 소켓을 통해 데이터를 TCP로 전달하며, TCP는 이를 **송신 버퍼(send buffer)** 에 저장합니다. <br>
이 버퍼는 3-way handshake 중에 설정된 버퍼 중 하나입니다.  <br>
TCP는 주기적으로 송신 버퍼의 데이터를 세그먼트로 분할하여 네트워크 계층으로 전달합니다.

TCP 명세서(RFC 793)는 송신 시점에 대해 엄격한 규정을 두지 않으며, TCP가 “편의에 따라(convenience)” 데이터를 전송할 수 있음을 명시합니다. <br>
세그먼트에 담길 수 있는 최대 데이터 크기는 **MSS(Maximum Segment Size)** 에 의해 제한됩니다.  <br>
MSS는 로컬 호스트의 **MTU(Maximum Transmission Unit)** — 즉, 링크 계층에서 전송 가능한 최대 프레임 크기를 기반으로 결정됩니다. <br>
MTU는 일반적으로 1500바이트이며, TCP/IP 헤더(약 40바이트)를 제외한 1460바이트가 MSS로 설정되는 것이 일반적입니다.

TCP는 클라이언트 애플리케이션의 데이터를 TCP 헤더와 함께 결합하여 **TCP 세그먼트(TCP segment)** 를 만듭니다. <br>
이 세그먼트는 네트워크 계층으로 전달되어 IP 데이터그램에 캡슐화되고, 목적지 호스트로 전송됩니다.  <br>
수신 측에서는 세그먼트가 TCP 수신 버퍼(receive buffer)에 저장되며, 애플리케이션이 이 버퍼에서 데이터를 읽어갑니다.

각 호스트는 독립적인 **송신 버퍼(send buffer)** 와 **수신 버퍼(receive buffer)** 를 가지고 있으며, 라우터나 스위치, 리피터 등 중간 네트워크 장비에는 이러한 버퍼나 TCP 연결 상태가 전혀 존재하지 않습니다. <br>
즉, TCP의 연결 상태는 오직 통신 중인 두 종단 시스템 내부에만 존재합니다.

## 3.5.2 TCP 세그먼트 구조 (TCP Segment Structure)

<img width="512" height="435" alt="Image" src="https://github.com/user-attachments/assets/b64cfc40-807c-4a5c-a0cc-172b23a38d69" />

이제 TCP 연결에 대해 살펴보았으니, 이번에는 TCP 세그먼트의 구조를 알아보겠습니다. <br>
TCP 세그먼트는 **헤더 필드(header fields)** 와 **데이터 필드(data field)** 로 구성됩니다. <br>
데이터 필드에는 응용 계층의 데이터가 포함됩니다. <br>
앞서 언급했듯이, **MSS(Maximum Segment Size)** 는 세그먼트의 데이터 필드에 들어갈 수 있는 최대 크기를 제한합니다.

예를 들어 TCP가 큰 파일(예: 웹페이지의 이미지 파일)을 전송할 때, 파일은 MSS 크기 단위로 분할되어 전송됩니다. <br>
단, 마지막 세그먼트는 MSS보다 작을 수 있습니다.  <br>
한편, 텔넷(Telnet)이나 SSH와 같은 대화형 애플리케이션에서는 데이터 필드가 매우 작을 수 있으며, 심지어 한 세그먼트에 단 1바이트만 포함될 수도 있습니다. <br>
TCP 헤더는 일반적으로 20바이트이며, UDP보다 12바이트 더 깁니다.  <br>
따라서 텔넷이나 SSH로 전송되는 세그먼트는 전체 길이가 21바이트 정도밖에 되지 않을 수 있습니다.

TCP 헤더는 UDP 헤더처럼 **송신지(source)와 목적지(destination) 포트 번호**를 포함하며, 상위 계층 애플리케이션 간의 **다중화 및 역다중화(demultiplexing)** 를 위해 사용됩니다. <br>
또한, **체크섬 필드(checksum field)** 도 포함됩니다.  <br>
이외에도 TCP 세그먼트 헤더에는 다음과 같은 필드들이 존재합니다.

- **시퀀스 번호 필드(sequence number field)** (32비트)와 **확인 응답 번호 필드(acknowledgment number field)** (32비트): 송신자와 수신자가 신뢰성 있는 데이터 전송 서비스를 구현하기 위해 사용합니다.
- **수신 윈도우 필드(receive window field)** (16비트): 흐름 제어(flow control)에 사용됩니다.  
  이 값은 수신자가 현재 수용 가능한 바이트 수를 의미합니다.

- **헤더 길이 필드(header length field)** (4비트):  
  TCP 헤더의 길이를 32비트 워드 단위로 표시합니다.  
  TCP는 옵션 필드의 존재 여부에 따라 가변적인 헤더 길이를 가질 수 있습니다.  
  일반적인 TCP 헤더 길이는 20바이트입니다.

- **옵션 필드(options field)** (가변 길이):  
  송신자와 수신자가 MSS를 협상하거나, 고속 네트워크에서 윈도우 스케일링(window scaling)을 사용하는 데 이용됩니다.  
  타임스탬프(timestamp) 옵션도 정의되어 있습니다.

- **플래그 필드(flag field)** (6비트):
    - **ACK 비트**: 확인 응답 번호가 유효함을 나타냅니다. 즉, 해당 세그먼트가 이전 세그먼트의 성공적인 수신을 확인합니다.
    - **RST, SYN, FIN 비트**: 연결 설정과 해제에 사용됩니다.
    - **CWR, ECE 비트**: 혼잡 제어(Explicit Congestion Notification)에 사용됩니다.
    - **PSH 비트**: 수신자가 데이터를 즉시 상위 계층으로 전달해야 함을 의미합니다.
    - **URG 비트**: 긴급 데이터가 포함되어 있음을 나타내며, 긴급 데이터의 마지막 바이트 위치는 **16비트 긴급 데이터 포인터(urgent data pointer field)** 로 표시됩니다.

### 시퀀스 번호와 확인 응답 번호 (Sequence Numbers and Acknowledgment Numbers)

<img width="607" height="174" alt="Image" src="https://github.com/user-attachments/assets/2e1f7b2e-d6ee-4933-8477-28860393a9c5" />

TCP 세그먼트 헤더에서 가장 중요한 두 필드는 시퀀스 번호와 확인 응답 번호입니다.  <br>
이 필드들은 TCP의 **신뢰성 있는 데이터 전송(reliable data transfer)** 을 구현하는 핵심 요소입니다.

TCP는 데이터를 **비구조적이지만 순서가 있는 바이트 스트림(byte stream)** 으로 취급합니다.  <br>
따라서 시퀀스 번호는 “세그먼트” 단위가 아니라 **전송된 바이트 스트림 전체**에 대한 번호입니다.  
즉, 세그먼트의 시퀀스 번호는 **세그먼트 내 첫 번째 바이트의 바이트 스트림 번호** 입니다.

예를 들어, 호스트 A의 프로세스가 호스트 B로 500,000바이트 크기의 데이터를 보낸다고 가정합니다.  
MSS가 1,000바이트라면, TCP는 데이터를 500개의 세그먼트로 나눕니다.  
첫 번째 세그먼트의 시퀀스 번호는 0, 두 번째는 1,000, 세 번째는 2,000 … 이런 식으로 부여됩니다.

TCP가 전이중(full-duplex) 연결이므로, A는 데이터를 보내면서 동시에 B로부터 데이터를 받을 수도 있습니다.  
이때, B→A 방향의 데이터에도 각각의 시퀀스 번호가 있습니다.

**확인 응답 번호(acknowledgment number)** 는 “수신자가 다음에 기대하는 바이트의 시퀀스 번호”입니다.  
예를 들어, A가 B로부터 0~535 바이트를 수신하고 다음 바이트(536)를 기다린다면, A는 536을 확인 응답 번호 필드에 넣어 B로 전송합니다.  
이러한 형태의 응답을 **누적 확인(cumulative acknowledgment)** 이라고 합니다.

### 순서가 어긋난 세그먼트 처리 (Out-of-Order Segments)

만약 A가 3번째 세그먼트(900~1000 바이트)를 2번째 세그먼트(536~899 바이트)보다 먼저 받았다면, 세그먼트가 순서 없이 도착한 것입니다.  
TCP RFC는 이런 상황에서 어떻게 처리해야 하는지에 대한 구체적인 규칙을 정하지 않았습니다.  
즉, 구현자에게 다음 두 가지 선택지를 남깁니다.

1. 순서가 맞지 않는(out-of-order) 세그먼트를 즉시 버린다.
2. 순서가 맞지 않는 바이트를 보관하고, 누락된 바이트가 도착할 때까지 기다린다.

두 번째 방식이 대역폭 효율 측면에서 일반적으로 더 낫기 때문에, 대부분의 TCP 구현은 이 방식을 채택합니다.

또한 실제로는 각 TCP 연결에서 **초기 시퀀스 번호(initial sequence number)** 는 항상 0이 아닙니다.  
양쪽 호스트는 무작위로 초기 시퀀스 번호를 선택하여, 이전 연결의 세그먼트가 새 연결로 잘못 인식되는 것을 방지합니다.

### 텔넷(Telnet): 시퀀스 번호와 확인 응답 번호의 사례 연구

**Telnet**(RFC 854)은 원격 로그인(Remote Login)에 사용되는 애플리케이션 계층 프로토콜입니다.  
Telnet은 TCP 위에서 동작하며, 사용자가 입력한 문자를 원격 호스트로 전송하고, 원격 호스트는 그 문자를 다시 에코(반환)하여 사용자 화면에 표시합니다.  
이 과정을 통해 입력된 문자가 실제로 전송 및 수신되었는지 확인할 수 있습니다.

예를 들어, 호스트 A가 클라이언트이고 호스트 B가 서버라고 합시다.  
사용자가 문자 ‘C’를 입력하면, A는 그 문자를 담은 TCP 세그먼트를 B로 보냅니다.  
이때 클라이언트의 시퀀스 번호는 42, 서버의 시퀀스 번호는 79라고 가정합니다.

1. **첫 번째 세그먼트 (클라이언트 → 서버)**
    - 데이터 필드: 문자 ‘C’ (1바이트 ASCII 코드)
    - 시퀀스 번호: 42
    - 확인 응답 번호: 79 (아직 서버로부터 받은 데이터가 없으므로 서버의 다음 예상 바이트 번호)

2. **두 번째 세그먼트 (서버 → 클라이언트)**
    - 두 가지 역할 수행:
        - (1) 43을 확인 응답 번호로 포함하여, 서버가 42까지의 데이터를 성공적으로 받았음을 알림
        - (2) 문자 ‘C’를 다시 클라이언트로 에코
    - 시퀀스 번호: 79
    - 데이터 필드: ‘C’ (1바이트 ASCII 코드)
    - 이처럼 서버의 데이터와 확인 응답이 함께 포함될 때, 이를 **피기백(piggybacked) ACK** 이라고 합니다.

3. **세 번째 세그먼트 (클라이언트 → 서버)**
    - 서버로부터 받은 데이터를 확인하기 위한 ACK만 포함 (데이터 필드는 비어 있음)
    - 확인 응답 번호: 80 (클라이언트가 79까지의 데이터를 받았음을 의미)
    - TCP 세그먼트는 항상 시퀀스 번호를 포함해야 하므로, 데이터가 없어도 시퀀스 번호가 존재합니다.

## 3.5.3 왕복 시간 추정과 타임아웃 (Round-Trip Time Estimation and Timeout)

TCP는 3.4절에서 살펴본 `rdt` 프로토콜처럼 손실된 세그먼트를 복구하기 위해 **타임아웃/재전송(timeout/retransmit)** 메커니즘을 사용합니다.  
개념적으로는 단순하지만, 실제 TCP와 같은 프로토콜에 적용하면 여러 미묘한 문제가 발생합니다.  
가장 명확한 질문은 바로 “타임아웃 간격을 얼마나 길게 설정해야 하는가?” 입니다.  
타임아웃은 연결의 **왕복 시간(Round-Trip Time, RTT)** 보다 길어야 합니다.  
즉, 세그먼트가 전송되어 확인 응답이 돌아오기까지 걸리는 시간보다 타임아웃이 짧으면 불필요한 재전송이 발생하기 때문입니다.

하지만 얼마나 더 길어야 할까요?  
RTT는 어떻게 추정해야 할까요?  
모든 미확인 세그먼트마다 타이머를 따로 둬야 할까요?  
이 절에서는 Jacobson(1988)의 연구와 IETF의 최신 TCP 타이머 관리 권고안 [RFC 6298]을 바탕으로 설명합니다.---

### 왕복 시간(RTT) 추정 (Estimating the Round-Trip Time)

TCP는 송신자와 수신자 사이의 **왕복 시간(RTT)** 을 측정하기 위해 다음과 같은 방식을 사용합니다.  
어떤 세그먼트가 전송된 시점부터(`IP` 계층으로 전달됨) 해당 세그먼트의 확인 응답(ACK)을 수신할 때까지의 시간을 **표본 RTT(SampleRTT)** 라고 합니다.

TCP는 매 세그먼트마다 SampleRTT를 측정하지 않고, 한 번에 하나의 SampleRTT만 측정합니다.  
즉, 특정 시점에서는 하나의 세그먼트에 대해서만 RTT를 측정하고, 그 결과로 약 1회 RTT마다 새로운 SampleRTT 값을 얻습니다.  
또한 TCP는 재전송된 세그먼트의 SampleRTT는 계산하지 않습니다.  
이는 “Karn의 알고리즘(Karn, 1987)” 때문이며, 재전송된 세그먼트의 RTT 측정은 모호하기 때문입니다.

SampleRTT 값은 세그먼트마다 달라질 수 있습니다.  
이는 라우터의 혼잡 정도나 종단 시스템의 부하 변화 등으로 인해 RTT가 일정하지 않기 때문입니다.  
따라서 TCP는 여러 SampleRTT 값을 평균 내어 **평균 RTT(EstimatedRTT)** 를 계산합니다.

### 실제 적용 원리 (Principles in Practice)

TCP는 양의 확인 응답(positive acknowledgment)과 타이머를 사용해 신뢰성 있는 데이터 전송을 제공합니다.  
데이터가 올바르게 수신되면 TCP는 ACK를 전송하고, ACK가 손실되거나 손상되었다고 판단되면 세그먼트를 재전송합니다.  
일부 TCP 구현에서는 **빠른 재전송(fast retransmit)** 메커니즘을 사용합니다.  
동일한 세그먼트에 대해 **중복된 ACK 세 개**가 수신되면, 이는 해당 세그먼트의 손실을 의미하는 암묵적 NAK로 간주하고 즉시 재전송을 수행합니다.

TCP는 또한 **파이프라이닝(pipelining)** 을 사용합니다.  
즉, 여러 개의 세그먼트를 동시에 전송하고, 각 세그먼트의 ACK를 기다리지 않고 다음 세그먼트를 전송할 수 있습니다.  
이 방식은 세그먼트 크기에 비해 RTT가 큰 경우 전송 효율을 높이는 데 도움이 됩니다.  
파이프라이닝 가능한 세그먼트 수는 TCP의 흐름 제어와 혼잡 제어 메커니즘에 의해 제한됩니다.

## 3.5.4 신뢰할 수 있는 데이터 전송 (Reliable Data Transfer)

인터넷의 네트워크 계층 서비스(IP 서비스)는 **신뢰성이 없는 서비스**임을 기억하시기 바랍니다.  
IP는 데이터그램의 **전달 보장**, **순서 보장**, **데이터 무결성 보장**을 제공하지 않습니다.  
라우터 버퍼가 초과되어 데이터그램이 폐기될 수도 있고, 데이터그램이 순서가 뒤바뀌어 도착하거나, 데이터의 일부 비트가 손상(0→1 혹은 1→0)될 수도 있습니다.  
전송 계층 세그먼트 또한 IP 데이터그램을 통해 전달되기 때문에 이러한 문제로부터 자유롭지 않습니다.

TCP는 이러한 **비신뢰적인 IP 서비스 위에 신뢰할 수 있는 데이터 전송 서비스(reliable data transfer service)** 를 제공합니다.  
TCP의 신뢰성 전송 서비스는 수신 측의 TCP 버퍼에 저장된 데이터가
- 손상되지 않고 (uncorrupted),
- 누락되지 않고 (without gaps),
- 중복되지 않으며 (without duplication),
- 순서가 올바르게 유지되도록 (in sequence)  
  보장합니다.  
  즉, 수신 측에서 읽는 바이트 스트림은 송신 측에서 보낸 바이트 스트림과 정확히 동일합니다.

TCP가 이러한 신뢰성 있는 데이터 전송을 제공하는 방법은 3.4절에서 다룬 여러 원리와 동일한 개념을 기반으로 합니다.

### 단일 타이머 기반 전송 관리 (Single Timer Management)

이전 절에서 신뢰성 전송 기술을 설계할 때, 각 세그먼트마다 타이머를 개별적으로 설정하는 것이 이론적으로는 가장 간단했습니다.  
하지만 실제로는 이러한 방식이 **과도한 오버헤드(overhead)** 를 발생시킵니다.  
따라서 RFC 6298은 TCP가 **하나의 재전송 타이머(single retransmission timer)** 만을 사용하는 것을 권장합니다.  
이 타이머는 가장 오래된 미확인 세그먼트와 연관되어 있습니다.

### TCP의 신뢰성 전송 과정 (Reliable Data Transfer Mechanism)

TCP의 신뢰성 전송 과정은 두 단계로 설명할 수 있습니다.

1. **단순화된 모델:** 타임아웃 기반으로 손실 세그먼트를 복구하는 단순한 TCP 송신자 모델
2. **완전한 모델:** 중복 ACK(duplicate ACK)를 이용한 빠른 재전송(fast retransmit)을 포함하는 모델

이 절에서는 A가 B로 데이터를 전송하는 단방향 통신(예: 큰 파일 전송)을 가정합니다.

### TCP 송신자 동작 요약

TCP 송신자(TCP sender)는 다음 세 가지 주요 이벤트를 처리합니다.

1. **애플리케이션으로부터 데이터 수신**  
   TCP는 상위 계층으로부터 데이터를 수신하면 세그먼트로 캡슐화하고 IP로 전달합니다.  
   세그먼트에는 첫 번째 데이터 바이트의 시퀀스 번호가 포함됩니다.  
   타이머가 동작 중이지 않다면, TCP는 타이머를 시작합니다.  
   이 타이머의 만료 시간(TimeoutInterval)은 `EstimatedRTT`와 `DevRTT`로 계산됩니다.

2. **타임아웃 발생**  
   타이머가 만료되면, TCP는 해당 세그먼트를 재전송하고 타이머를 다시 시작합니다.

3. **ACK 수신**  
   수신 측에서 ACK 세그먼트를 받으면, TCP는 ACK의 번호를 확인하여 **SendBase** 변수와 비교합니다.
    - `SendBase`: 아직 확인되지 않은 가장 오래된 바이트의 시퀀스 번호  
      ACK 번호가 `SendBase`보다 크면, 이는 여러 세그먼트가 누적 확인(cumulative acknowledgment)되었음을 의미합니다.  
      따라서 TCP는 `SendBase`를 갱신하고, 미확인 세그먼트가 남아 있다면 타이머를 재시작합니다.

### 예시 시나리오 (A Few Interesting Scenarios)

1. **시나리오 1: 단일 세그먼트 손실**
    - A → B로 전송된 세그먼트(시퀀스 번호 92, 데이터 8바이트)가 있고, B는 ACK(100)를 보냅니다.
    - 그러나 이 ACK가 손실되어 A는 타임아웃을 감지하고 같은 세그먼트를 재전송합니다.
    - B는 이미 해당 데이터를 받았기 때문에, 중복 데이터를 폐기합니다.

2. **시나리오 2: 두 세그먼트 전송**
    - A가 시퀀스 92(8바이트)와 100(20바이트) 두 세그먼트를 연속 전송.
    - B는 각각 ACK 100과 ACK 120을 보냄.
    - ACK가 모두 손실된 경우, A는 첫 번째 세그먼트를 재전송하지만,  
      두 번째 세그먼트의 ACK가 나중에 도착하면 재전송이 중단됩니다.

3. **시나리오 3: 누적 확인 예시**
    - ACK 100은 손실되었지만, ACK 120이 도착하면  
      A는 B가 119바이트까지 모두 받았음을 알고, 두 세그먼트 모두 재전송하지 않습니다.

### 타임아웃 간격 두 배로 증가 (Doubling the Timeout Interval)

대부분의 TCP 구현에서는 타임아웃이 발생할 때마다 **TimeoutInterval을 두 배로 증가시킵니다**.  
예를 들어 처음 타이머 만료가 0.75초일 때, 다음 만료는 1.5초, 이후에는 3.0초가 됩니다.  
이는 네트워크 혼잡 시 과도한 재전송을 피하기 위한 조치입니다.  
단, 새로운 데이터나 ACK가 수신되면 다시 `EstimatedRTT`와 `DevRTT`로부터 타임아웃이 재계산됩니다.

이 방식은 일종의 **혼잡 제어(congestion control)** 역할을 수행합니다.  
타이머 만료는 종종 네트워크 혼잡의 결과(라우터 큐가 가득 참 등)일 수 있기 때문에,  
TCP는 재전송 간격을 점점 늘려 네트워크 부하를 완화합니다.

### 빠른 재전송 (Fast Retransmit)

타임아웃 기반 재전송의 문제는 **대기 시간이 너무 길다는 점**입니다.  
세그먼트 손실 시, 송신자는 타임아웃이 끝날 때까지 기다려야 재전송을 수행하므로 지연이 커집니다.

이를 개선하기 위해 TCP는 **중복 ACK(duplicate ACK)** 를 이용합니다.  
중복 ACK란 이미 수신된 세그먼트에 대해 **같은 ACK를 다시 보내는 것**을 의미합니다.  
수신 측이 기대한 세그먼트보다 더 큰 시퀀스 번호의 세그먼트를 받으면,  
데이터 스트림 중간에 손실된 세그먼트(갭)를 감지하고, 마지막으로 받은 올바른 세그먼트에 대한 ACK를 반복 전송합니다.

#### RFC 5681의 TCP ACK 생성 규칙 (Table 3.2 요약)
| 이벤트 | TCP 수신자 동작 |
|--------|----------------|
| 순서대로 세그먼트 수신 | 500ms 대기 후 ACK 전송 (Delayed ACK) |
| 순서대로 세그먼트 연속 수신 | 즉시 누적 ACK 전송 |
| 순서가 어긋난 세그먼트 수신 | 다음 예상 바이트 번호로 중복 ACK 전송 |
| 누락된 세그먼트가 도착 | 즉시 ACK 전송 |

이러한 규칙 덕분에 송신자는 **3개의 중복 ACK** 를 받으면 해당 세그먼트가 손실되었다고 판단하고,  
타임아웃을 기다리지 않고 즉시 **빠른 재전송(Fast Retransmit)** 을 수행합니다.

### Go-Back-N vs Selective Repeat

마지막으로 TCP의 오류 복구 방식이 **Go-Back-N(GBN)** 인지, **Selective Repeat(SR)** 인지 살펴봅니다.

TCP의 ACK는 누적적(cumulative)이므로, 수신자는 순서가 어긋난 세그먼트를 개별적으로 확인하지 않습니다.  
이 점에서 TCP는 GBN과 유사합니다. 하지만 다음과 같은 차이가 있습니다.

- **GBN:** 하나의 ACK가 손실되면, 그 뒤의 모든 세그먼트를 재전송
- **TCP:** 손실된 세그먼트 하나만 재전송

또한 많은 TCP 구현에서는 **순서가 어긋난 세그먼트도 버퍼에 저장**해두고, 누락된 세그먼트가 오면 바로 조립합니다.

RFC 2018은 **선택적 확인(Selective Acknowledgment, SACK)** 기능을 도입하여  
수신자가 순서가 어긋난 세그먼트를 선택적으로 확인할 수 있게 했습니다.  
SACK과 선택적 재전송(Selective Retransmission)을 결합하면, TCP는 **GBN과 SR의 하이브리드 모델**처럼 동작합니다.


## 3.5.5 흐름 제어 (Flow Control)

TCP 연결의 양쪽 호스트는 각각 연결을 위해 **수신 버퍼(receive buffer)** 를 확보합니다.  
TCP 연결이 올바른 순서로 데이터를 수신하면, 해당 데이터를 수신 버퍼에 저장합니다.  
이 버퍼의 데이터는 응용 프로그램이 읽어가지만, 데이터가 도착하는 즉시 읽는 것은 아닙니다.  
응용 프로그램이 다른 작업으로 바쁠 수도 있고, 데이터를 나중에 읽을 수도 있습니다.  
만약 응용 프로그램이 데이터를 읽는 속도가 느리다면, 송신 측이 너무 빠르게 데이터를 전송함으로써 수신 측 버퍼가 **넘쳐버릴(overflow)** 수 있습니다.

이 문제를 방지하기 위해 TCP는 **흐름 제어 서비스(flow-control service)** 를 제공합니다.  
흐름 제어의 목적은 송신자가 수신자의 버퍼 용량을 초과하지 않도록 하는 것입니다.  
즉, 송신 속도와 수신 속도를 일치시키는 일종의 **속도 조절 메커니즘(speed-matching service)** 입니다.

한편, 송신자는 IP 네트워크의 혼잡(congestion)으로 인해 속도가 제한될 수도 있는데, 이것은 **혼잡 제어(congestion control)** 라고 하며 3.6절과 3.7절에서 다룹니다.  
두 메커니즘 모두 송신 속도를 줄이는 결과를 가져오지만, 흐름 제어는 **수신자의 처리 속도에 맞추기 위한 것**, 혼잡 제어는 **네트워크 상태에 맞추기 위한 것**입니다.

### 수신 윈도우(Receive Window)의 개념

TCP는 송신 측에서 **수신 윈도우(receive window)** 라는 변수를 유지함으로써 흐름 제어를 수행합니다.  
수신 윈도우는 수신 측 버퍼에서 **남은 여유 공간의 크기**를 송신자에게 알려주는 역할을 합니다.

TCP는 양방향(full-duplex) 통신을 지원하므로, 각 방향에 대해 별도의 수신 윈도우가 존재합니다.

### 변수 정의

Host A가 Host B로 큰 파일을 전송한다고 가정합시다.  
Host B는 연결을 위해 크기가 `RcvBuffer`인 수신 버퍼를 할당합니다.  
Host B의 응용 프로그램은 이 버퍼에서 데이터를 읽어가며, 다음과 같은 변수를 정의합니다:

- **LastByteRead:** 응용 프로그램이 버퍼에서 마지막으로 읽은 바이트의 번호
- **LastByteRcvd:** 네트워크를 통해 도착해 수신 버퍼에 저장된 마지막 바이트의 번호

TCP는 버퍼 오버플로를 허용하지 않으므로, 다음 관계가 항상 성립해야 합니다: LastByteRcvd - LastByteRead ≤ RcvBuffer  
따라서 **수신 윈도우(rwnd)** 는 다음과 같이 계산됩니다: rwnd = RcvBuffer - (LastByteRcvd - LastByteRead)

즉, `rwnd`는 버퍼 내의 남은 공간을 나타냅니다.  
응용 프로그램이 데이터를 읽어가면 `rwnd` 값은 증가하고, 데이터가 수신되면 감소합니다.  
따라서 `rwnd`는 **시간에 따라 동적으로 변화하는 값**입니다.


### 수신 윈도우의 전달과 활용

Host B는 현재의 `rwnd` 값을 **각 세그먼트의 헤더에 포함시켜** Host A로 보냅니다.  
이 값은 “당신이 더 보낼 수 있는 데이터의 양은 이것입니다”라는 의미를 갖습니다.

처음에는 Host B가 버퍼를 모두 비워 두었으므로 `rwnd = RcvBuffer` 입니다.  
Host A는 자신이 보낸 데이터 중 아직 확인(ACK)되지 않은 바이트의 개수를 추적합니다.

- **LastByteSent:** 지금까지 전송한 마지막 바이트 번호
- **LastByteAcked:** 수신 측에서 확인된 마지막 바이트 번호

이 두 값의 차이 `(LastByteSent - LastByteAcked)` 는 아직 확인되지 않은 데이터의 양을 의미합니다.

TCP는 송신 측에서 항상 다음 관계를 유지합니다: LastByteSent - LastByteAcked ≤ rwnd
즉, 송신자는 수신 측 버퍼의 여유 공간보다 더 많은 데이터를 보내지 않습니다.

### rwnd = 0인 경우의 문제와 해결

하나의 기술적 문제가 존재합니다.  
만약 Host B의 버퍼가 가득 차 `rwnd = 0`이 되었고, B가 A로 보낼 데이터(또는 ACK)가 없다면, Host A는 **더 이상 데이터를 전송할 수 없게 됩니다.**  
왜냐하면 A는 수신 측의 여유 공간이 생겼다는 사실을 알 수 없기 때문입니다.

이 문제를 해결하기 위해 TCP는 다음 규칙을 명시합니다:

> **송신자는 rwnd = 0일 때에도 주기적으로 1바이트짜리 세그먼트를 전송해야 한다.**

이러한 “프로빙(probing)” 세그먼트는 수신 측이 버퍼를 비우면 ACK를 보내도록 하며, ACK에 포함된 `rwnd`가 0이 아니게 되면 송신이 재개됩니다.

### UDP와의 비교

TCP와 달리 **UDP는 흐름 제어를 제공하지 않습니다.**  
따라서 수신 측 응용 프로그램이 데이터를 충분히 빠르게 읽지 못하면 버퍼가 가득 차게 되고, 추가로 들어오는 세그먼트는 **버퍼 오버플로로 인해 폐기(drop)** 됩니다.

예를 들어, Host A가 Host B로 여러 개의 UDP 세그먼트를 보낼 경우, 수신 측 B는 제한된 크기의 버퍼(소켓 큐)에 세그먼트를 저장합니다.    
응용 프로그램이 이 버퍼를 제때 비우지 않으면, 새로 도착한 세그먼트는 손실됩니다.




## 3.5.6 TCP 연결 관리 (TCP Connection Management)

이번 절에서는 **TCP 연결의 설정과 해제 과정**을 자세히 살펴봅니다.  
이 주제는 단순히 연결을 여닫는 것처럼 보이지만, 웹 브라우징과 같은 실제 상황에서 **지연(delay)** 에 큰 영향을 미치며,  
또한 **SYN Flood Attack** 같은 네트워크 공격이 주로 악용하는 부분이기도 합니다.

### TCP 연결 설정: 3단계 핸드셰이크 (Three-Way Handshake)

TCP 연결은 클라이언트와 서버 간에 **세 단계(three steps)** 를 거쳐 설정됩니다.  
이를 **3-way handshake** 라고 합니다.

#### ▪ Step 1: 클라이언트 → 서버 (SYN)

클라이언트는 서버에 연결을 요청하기 위해 **SYN 세그먼트**를 전송합니다.  
이 세그먼트는 **데이터를 포함하지 않으며**, TCP 헤더의 **SYN 비트(Synchronize bit)** 가 1로 설정되어 있습니다.  
또한 클라이언트는 무작위로 **초기 순서 번호(client_isn)** 를 선택하여 세그먼트의 시퀀스 필드에 넣습니다.  
이 번호는 보안상 이유로 난수로 설정되며, **재전송 공격(replay attack)** 을 방지하기 위해 무작위화됩니다.

#### ▪ Step 2: 서버 → 클라이언트 (SYNACK)

서버가 이 SYN 세그먼트를 수신하면, TCP 버퍼와 변수를 할당하고 **연결 허용 세그먼트**를 보냅니다.  
이 세그먼트는 다음 세 가지 정보를 포함합니다:

1. SYN 비트 = 1 (서버도 동기화 요청)
2. ACK 필드 = client_isn + 1 (클라이언트의 요청을 수락했다는 의미)
3. 서버의 초기 순서 번호(server_isn)

이 세그먼트는 **SYNACK 세그먼트**라고 부릅니다.

#### ▪ Step 3: 클라이언트 → 서버 (ACK)

클라이언트는 서버로부터 SYNACK을 받으면, 서버의 초기 순서 번호(server_isn)를 인식하고  
이에 대한 **ACK 세그먼트**를 보냅니다. 이때:

- ACK 필드 = server_isn + 1
- SYN 비트 = 0 (연결 완료)

이 세 번째 단계가 완료되면, 클라이언트와 서버 간 연결이 **성립(established)** 되며  
이제부터는 데이터를 송수신할 수 있습니다.

### TCP 연결 종료 (Connection Termination)

모든 연결은 결국 종료됩니다.  
TCP에서는 연결을 종료하기 위해 **FIN 세그먼트**를 사용합니다.

#### 종료 과정 예시:

1. 클라이언트가 연결 종료 명령을 내리면,  
   **FIN 비트가 1인 세그먼트**를 서버로 보냅니다.
2. 서버는 이를 확인하고 **ACK 세그먼트**로 응답합니다.
3. 이후 서버도 자신의 종료를 알리기 위해 **FIN 세그먼트**를 보냅니다.
4. 마지막으로 클라이언트는 서버의 FIN을 ACK으로 응답합니다.  
   이 시점에서 양측의 연결이 완전히 종료되고,  
   TCP 버퍼와 자원(포트 등)이 해제됩니다.

### TCP 상태 변화 (TCP States)

TCP 연결은 여러 상태(state)를 거치며 동작합니다.  
예를 들어 클라이언트 측에서 다음과 같은 상태 전이가 발생합니다:

1. **CLOSED** – 연결 없음
2. **SYN_SENT** – SYN 세그먼트 전송 후 응답 대기 중
3. **ESTABLISHED** – 연결 완료, 데이터 송수신 가능
4. **FIN_WAIT_1** – FIN 전송 후 ACK 대기 중
5. **FIN_WAIT_2** – 서버의 FIN 대기 중
6. **TIME_WAIT** – 마지막 ACK을 재전송할 여지를 남기기 위한 대기 상태 (30초~2분 정도 유지)

TIME_WAIT 상태는 네트워크 지연으로 ACK이 손실될 경우를 대비하여,  
TCP가 마지막 ACK을 재전송할 수 있도록 합니다.  
이 시간이 지나면 연결이 완전히 종료되고, 모든 자원이 해제됩니다.

### 비정상 연결 종료 (RST)

어떤 경우에는 연결이 정상적으로 설정되지 않거나,  
서버가 요청한 포트에서 연결을 수락하지 않을 수 있습니다.

이때 TCP는 **RST (Reset)** 세그먼트를 보냅니다.  
RST 비트가 1인 세그먼트를 수신한 호스트는 “해당 포트에 연결이 존재하지 않음”을 의미하며,  
송신자에게 “세그먼트를 다시 보내지 말라”고 알립니다.

UDP에서는 이와 비슷한 상황에서 **ICMP 메시지**를 사용하여 응답합니다.

### Nmap 포트 스캔 예시

포트 스캐닝 도구인 **nmap**은 TCP의 연결 관리 방식을 활용하여 특정 포트가 열려 있는지를 탐지합니다.    
예를 들어, 공격자가 포트 6789로 SYN 패킷을 보냈을 때의 가능한 결과는 다음과 같습니다.

1. **SYNACK 수신:** 포트가 열려 있으며 연결 가능 (“open”).
2. **RST 수신:** 포트는 닫혀 있으나, 방화벽은 통과함.
3. **응답 없음:** 방화벽에 의해 SYN 패킷이 차단됨.



