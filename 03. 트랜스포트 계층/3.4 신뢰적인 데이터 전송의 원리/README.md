# 3.4 신뢰적인 데이터 전송의 원리

이 절에서는 일반적인 관점에서 신뢰할 수 있는 데이터 전송(reliable data transfer)의 문제를 다룹니다. <br>
이 주제를 다루는 것이 적절한 이유는, 신뢰할 수 있는 데이터 전송의 구현 문제가 단지 전송 계층(transport layer)에서만 발생하는 것이 아니라, 링크 계층(link layer)과 응용 계층(application layer)에서도 발생하기 때문입니다. <br>
따라서 이 문제는 네트워킹에서 중심적인 중요성을 가지는 문제입니다. <br>
사실, 네트워킹의 근본적으로 중요한 문제 “Top 10”을 꼽는다면, 신뢰할 수 있는 데이터 전송 문제는 그 목록의 맨 앞에 있을 것입니다. <br>
다음 절에서는 TCP를 살펴보며, TCP가 여기서 설명할 여러 원리들을 실제로 어떻게 활용하는지를 보겠습니다.

<img width="713" height="532" alt="Image" src="https://github.com/user-attachments/assets/5c14362e-935c-4667-80e6-18209cd6e0f4" />

위 그림은 신뢰할 수 있는 데이터 전송 연구의 기본 틀을 보여줍니다. <br>
상위 계층 엔티티(upper-layer entities)에 제공되는 서비스 추상화는 신뢰할 수 있는 채널(reliable channel)을 통해 데이터를 전송할 수 있게 하는 것입니다. <br>
이 신뢰할 수 있는 채널에서는 전송된 데이터 비트가 손상되거나(0→1, 1→0으로 바뀌는 등) 손실되지 않으며, 전송된 순서대로 정확히 도착합니다. <br>
이것이 바로 TCP가 인터넷 응용 프로그램에 제공하는 서비스 모델입니다.

이러한 서비스 추상화를 실제로 구현하는 것은 신뢰할 수 있는 데이터 전송 프로토콜(reliable data transfer protocol) 의 책임입니다. <br>
하지만 이 작업은 어려운 이유가 있습니다. 바로 하위 계층(lower layer) 의 전송이 신뢰할 수 없을 수 있기 때문입니다. <br>
예를 들어 TCP는 신뢰할 수 있는 데이터 전송 프로토콜이지만, 신뢰할 수 없는 IP 네트워크 계층 위에서 동작합니다. <br>
일반적으로 두 종단(end point) 간 통신 아래의 계층은 하나의 물리적 링크(링크 계층 프로토콜)일 수도 있고, 여러 네트워크로 이루어진 전 세계적인 인터넷워크(전송 계층 프로토콜)일 수도 있습니다. <br>
이 절에서는 단순화를 위해, 하위 계층을 신뢰할 수 없는 점대점(point-to-point) 채널 로 간주하겠습니다.

이 절에서는 송신자(sender)와 수신자(receiver) 측의 신뢰할 수 있는 데이터 전송 프로토콜을 점진적으로 개발하면서, 점점 더 복잡한 채널 모델을 고려할 것입니다. <br>
예를 들어, 비트 손상(bit corruption)이나 패킷 손실(packet loss) 같은 문제가 발생할 수 있는 채널에서 어떤 프로토콜 메커니즘이 필요한지를 다룹니다.

송신 측에서는 rdt_send()가 호출되면 데이터가 수신 측에 전달될 준비가 된 것입니다. <br>
(rdt는 reliable data transfer의 약자이며, _send는 송신 측을 의미합니다.) <br>
수신 측에서는 패킷이 도착하면 rdt_rcv()가 호출되어 상위 계층으로 전달됩니다. <br>
프로토콜이 상위 계층에 데이터를 넘길 때는 deliver_data()를 호출합니다.

이 절에서는 단방향 데이터 전송(unidirectional data transfer) 만을 고려합니다. <br>
즉, 송신 측에서 수신 측으로만 데이터를 전송하는 경우입니다. <br>
양방향 데이터 전송(bidirectional data transfer), 즉 전이중(full-duplex) 전송의 경우 개념적으로는 크게 다르지 않지만 설명이 훨씬 복잡해집니다. 

단방향 전송만 다루더라도, 송신 측과 수신 측 모두 실제로는 양방향으로 제어 패킷(control packets) 을 교환해야 한다는 점은 중요합니다. <br>
즉, 데이터가 한쪽 방향으로만 전송되더라도, 확인 응답(ACK)이나 제어 정보 등은 반대 방향으로 전송되어야 합니다.

두 측 모두 rdt 프로토콜을 이용해 패킷을 주고받으며, 이러한 전송은 udt_send() 호출을 통해 이루어집니다. <br>
(udt는 unreliable data transfer의 약자입니다.)

## 3.4.1 신뢰할 수 있는 데이터 전송 프로토콜 구축 (Building a Reliable Data Transfer Protocol)

이 절에서는 완벽한 신뢰성을 가진 데이터 전송 프로토콜을 설계하기 위해 점차 복잡해지는 일련의 프로토콜을 단계적으로 살펴봅니다.

### 완벽하게 신뢰할 수 있는 채널에서의 데이터 전송: rdt1.0

가장 단순한 경우를 먼저 고려합니다. 즉, 하위 채널이 완벽하게 신뢰할 수 있는 경우입니다. <br>
이 프로토콜(rdt1.0)은 매우 간단하며, 송신자와 수신자 각각에 대해 유한 상태 기계(Finite-State Machine, FSM) 로 정의됩니다.

송신자 FSM은 rdt_send(data) 이벤트가 발생하면 데이터를 받아 패킷을 생성(make_pkt(data))하고 채널에 전송합니다. <br>
수신자 FSM은 rdt_rcv(packet) 이벤트가 발생하면 패킷에서 데이터를 추출(extract(packet, data))하고 상위 계층으로 전달(deliver_data(data))합니다.

이 단순한 환경에서는 데이터 단위와 패킷의 구분이 없으며, 모든 전송이 송신자에서 수신자로만 흐릅니다. <br>
채널이 완벽히 신뢰할 수 있으므로, 송신자는 수신자로부터 어떠한 피드백도 받을 필요가 없습니다. <br>
또한, 수신자는 송신자가 데이터를 보낼 때마다 이를 즉시 처리할 수 있다고 가정합니다.

### 비트 오류가 있는 채널에서의 신뢰할 수 있는 전송: rdt2.0

이제 더 현실적인 상황을 고려합니다. 하위 채널에서 패킷 내 비트가 손상될 수 있는 경우입니다. <br>
이러한 오류는 물리적인 전송 과정에서 흔히 발생합니다.

이 상황에서는 세 가지 주요 기능이 필요합니다:

**오류 검출 (Error detection)** <br>
수신자가 비트 오류 발생 여부를 판단할 수 있어야 합니다. <br>
이를 위해 체크섬(checksum) 같은 추가 비트를 패킷에 포함시킵니다. <br>
이 정보는 수신 측이 오류를 탐지하고 잘못된 패킷을 식별할 수 있도록 합니다.

**수신자 피드백 (Receiver feedback)** <br>
송신자는 수신자의 상태를 직접 알 수 없기 때문에, 수신자는 명시적 피드백(explicit feedback) 을 보내야 합니다.

ACK (Acknowledgment): 패킷이 올바르게 수신됨 <br>
NAK (Negative Acknowledgment): 패킷이 손상되어 재전송 필요

**재전송 (Retransmission)** <br>
수신자가 오류를 감지하거나 ACK을 받지 못하면, 송신자는 해당 패킷을 재전송합니다.

이 프로토콜은 Stop-and-Wait 프로토콜로 알려져 있습니다. <br>
즉, 송신자는 이전 패킷의 수신이 확인될 때까지 다음 패킷을 전송하지 않습니다.

### 손상된 ACK/NAK 문제와 개선된 프로토콜: rdt2.1 및 rdt2.2

rdt2.0은 이론적으로 작동하지만, ACK/NAK 자체가 손상될 가능성을 고려하지 않았습니다. <br>
ACK 또는 NAK 패킷이 손상되면, 송신자는 수신자가 마지막 데이터를 제대로 받았는지 알 수 없습니다.

이 문제를 해결하기 위해 rdt2.1 프로토콜에서는 다음을 추가합니다:

**순서 번호(Sequence Number)** <br>
각 데이터 패킷에 1비트 순서 번호를 부여하여, 수신자가 패킷이 새 데이터인지 재전송된 것인지 구분할 수 있게 합니다. <br>
예: 0과 1을 번갈아 사용.

이후 rdt2.2 프로토콜에서는 NAK 없이 중복 ACK(Duplicate ACK) 만으로도 동일한 효과를 얻을 수 있도록 개선됩니다. <br>
수신자가 같은 패킷에 대해 두 번 ACK을 보내면, 송신자는 해당 패킷이 손상되었음을 인식하고 재전송합니다.

### 손실과 비트 오류가 모두 존재하는 채널: rdt3.0

이제 하위 채널이 비트 오류뿐만 아니라 패킷 손실(loss) 도 발생시킬 수 있다고 가정합니다. <br>
이 문제는 현대의 인터넷 환경에서도 자주 발생합니다.

이 경우 프로토콜은 두 가지 추가 문제를 해결해야 합니다:

**패킷 손실 감지 (Packet loss detection)** <br>
송신자는 일정 시간(타이머 기반) 동안 ACK을 받지 못하면 패킷이 손실되었다고 판단합니다.

**손실 복구 (Recovery mechanism)** <br>
손실된 패킷을 재전송합니다.

rdt3.0은 송신자가 타임아웃을 기반으로 손실된 패킷을 감지하고 재전송하는 구조를 가집니다. <br>
즉, 송신자는 일정 시간 동안 응답이 없으면 “무언가 잘못되었다”고 판단하고 동일한 패킷을 다시 보냅니다.

이 접근법은 실제 TCP의 핵심 아이디어와 동일하며, 비트 오류 검출, ACK 기반 피드백, 타임아웃 기반 재전송의 세 가지 메커니즘을 결합하여 완전한 신뢰성을 보장합니다. <br>
실제 네트워크 환경에서는 패킷이 손실되거나 지연될 수 있기 때문에, 프로토콜은 이러한 상황에 대응하기 위해 재전송 메커니즘(retransmission mechanism) 을 갖추어야 합니다.

실무적으로는 송신자가 적절한 시간 간격(time interval) 을 설정해 두고, 그 시간 내에 ACK(수신 확인 응답)를 받지 못하면 해당 패킷이 손실되었다고 가정하고 재전송을 수행합니다. <br>
이 시간을 너무 짧게 설정하면 불필요한 중복 전송이 발생할 수 있고, 너무 길게 설정하면 오류 복구가 지연되기 때문에 신중한 선택이 필요합니다.

패킷이 지연되어 늦게 도착할 경우, 송신자는 ACK을 받지 못했다고 판단하고 같은 패킷을 재전송할 수 있습니다. <br>
이로 인해 수신자는 동일한 패킷을 여러 번 받는 중복 데이터 패킷 문제가 발생할 수 있습니다. <br>
다행히, 이전에 살펴본 rdt2.2 프로토콜은 이미 순서 번호(sequence number) 를 이용해 이러한 중복 패킷을 구별할 수 있는 기능을 가지고 있습니다.

송신자의 관점에서 보면, 재전송은 가장 단순하고 강력한 해결책입니다. <br>
송신자는 패킷이 손실되었는지, ACK이 손실되었는지, 아니면 단순히 지연되었는지를 구분할 수 없습니다. <br>
따라서 타임아웃이 발생하면 일단 다시 보내는 것이 가장 확실한 방법입니다.

이를 위해 프로토콜은 카운트다운 타이머(countdown timer) 를 사용합니다. <br>
송신자는 다음 세 가지 기능을 수행해야 합니다.

- 패킷을 처음 보내거나 재전송할 때 타이머를 시작(start) 합니다. 
- 타이머 인터럽트(timer interrupt) 가 발생하면, 적절한 동작(즉, 재전송)을 수행합니다. 
- 정상적으로 ACK을 받으면 타이머를 중지(stop) 합니다.

> rdt3.0의 송신자 FSM(Finite State Machine)은 패킷 손실과 지연이 모두 발생할 수 있는 채널에서도 신뢰할 수 있는 데이터 전송을 구현합니다. <br>
> 이때 수신자 FSM은 별도로 정의되며, 과제로서 독자가 직접 작성하도록 제시되기도 합니다.

> 패킷의 순서 번호(sequence number)가 0과 1을 번갈아 사용하기 때문에, rdt3.0은 종종 교대 비트 프로토콜(Alternating-Bit Protocol) 이라고 불립니다. <br>
> 즉, 하나의 패킷이 성공적으로 전송되고 ACK을 받은 후, 다음 패킷은 반대 번호(0 → 1, 1 → 0)를 부여받아 전송됩니다. 
> 이 간단한 메커니즘만으로도 송신자와 수신자는 중복 패킷을 구별하고 올바른 데이터 순서를 유지할 수 있습니다.

**이제 우리는 신뢰할 수 있는 데이터 전송 프로토콜의 핵심 요소들을 모두 갖추었습니다.**

- 체크섬(checksum) — 비트 오류 검출 
- 순서 번호(sequence numbers) — 중복 및 순서 오류 방지 
- 타이머(timers) — 손실 감지 및 재전송 트리거 
- 긍정/부정 응답(ACK/NAK) — 수신 상태 피드백

이 네 가지 요소가 함께 작동함으로써, rdt3.0은 손상되거나 손실된 패킷이 존재하는 불완전한 네트워크에서도 완전한 신뢰성(reliability) 을 보장합니다.

## 3.4.2 파이프라이닝된 신뢰적인 데이터 전송 프로토콜

프로토콜 rdt3.0 은 기능적으로 올바르게 동작하는 프로토콜이지만, 오늘날의 고속 네트워크 환경에서는 그 성능에 만족하기 어렵습니다. <br>
rdt3.0의 성능 문제의 핵심은 그것이 정지-대기(stop-and-wait) 방식의 프로토콜이라는 점에 있습니다.

### 파이프라이닝(Pipelining)의 필요성

이러한 문제를 해결하는 방법은 간단합니다. 송신자가 한 번에 여러 개의 패킷을 전송하도록 허용하는 것입니다. <br>
즉, ACK(수신 확인)를 기다리지 않고 연속적으로 데이터를 전송하는 방식입니다. 이 기법을 파이프라이닝(pipelining) 이라고 부릅니다.

그림 3.17(b)는 송신자가 한 번에 여러 패킷을 전송하는 상황을 보여주며, 그림 3.18(b)는 송신자가 세 개의 패킷을 한 번에 전송할 경우 송신자 활용도가 거의 세 배로 증가한다는 점을 나타냅니다. <br>
파이프라이닝은 마치 공장에서 컨베이어 벨트를 따라 여러 작업이 동시에 진행되는 것처럼, 여러 개의 패킷이 전송 중인 상태를 유지함으로써 채널을 지속적으로 활용합니다.

### 파이프라인된 전송이 미치는 영향

파이프라인 기법을 적용하면 신뢰할 수 있는 데이터 전송 프로토콜의 구조에 몇 가지 중요한 변화가 생깁니다.

1. 순서 번호(Sequence Number)의 범위 확대 
   - 동시에 여러 개의 패킷이 전송될 수 있으므로, 각 패킷은 고유한 순서 번호를 가져야 합니다. 
   - 단일 패킷만 다루던 rdt3.0과 달리, 이제는 여러 패킷이 동시에 ‘전송 중(in-transit)’ 상태가 될 수 있습니다.

2. 버퍼링(Buffering)의 필요성
   - 송신자(sender)는 아직 ACK을 받지 못한 패킷을 메모리에 저장해야 하며, 수신자(receiver) 역시 올바르게 수신된 패킷을 일시적으로 저장할 수 있어야 합니다. 
   - 이로 인해 송신자와 수신자 모두 더 많은 메모리 자원이 필요합니다.

3. 오류 처리(에러 복구) 방식의 다양화
   - 패킷 손실, 오류, 지연 등이 발생했을 때의 대응 방식에 따라 두 가지 주요 접근법이 존재합니다. 
     - Go-Back-N 프로토콜: 손실된 패킷 이후의 모든 패킷을 다시 전송 
     - Selective Repeat 프로토콜: 손실된 특정 패킷만 선택적으로 재전송

이 두 방식은 모두 파이프라인 기반 전송에서의 오류 복구를 위해 사용되며, 후속 절에서 자세히 다뤄집니다.

> 정지-대기 방식(rdt3.0)은 신뢰성 면에서는 완벽하지만, 고속 네트워크에서는 극도로 비효율적입니다. <br>
> 이를 개선하기 위해 파이프라인 기법(pipelining) 을 도입하면, 송신자는 ACK을 기다리지 않고 여러 패킷을 연속 전송하여 채널 사용률과 전체 전송 효율을 크게 높일 수 있습니다.

## 3.4.3 Go-Back-N (GBN)

Go-Back-N (GBN) 프로토콜에서는 송신자가 여러 개의 패킷을 ACK(수신 확인 응답)을 기다리지 않고 연속적으로 전송할 수 있습니다. <br>
다만, 파이프라인 내에서 아직 ACK을 받지 못한 미확인 패킷의 수가 최대 N개를 넘지 않도록 제한됩니다.

### GBN의 순서 번호와 윈도우 개념

<img width="697" height="213" alt="Image" src="https://github.com/user-attachments/assets/cb08efa6-6da4-4334-85a3-039258af037d" />

그림 3.19는 GBN 프로토콜에서 송신자가 바라보는 시퀀스 번호(sequence number) 의 범위를 보여줍니다.

- base : 아직 ACK을 받지 못한 가장 오래된 패킷의 시퀀스 번호 
- nextseqnum : 다음에 전송할 패킷의 시퀀스 번호

이를 기준으로 시퀀스 번호 공간을 다음 네 구간으로 나눌 수 있습니다.

1. [0, base−1] → 이미 전송되고 ACK을 받은 패킷
2. [base, nextseqnum−1] → 전송되었지만 ACK을 받지 못한 패킷
3. [nextseqnum, base+N−1] → 전송 가능한 새 패킷
4. [base+N, ...] → 윈도우 밖에 있으므로 전송 불가 (ACK 도착 전까지 대기)

이렇게 보면 송신자는 언제든지 base~base+N−1 범위 안에서만 전송할 수 있음을 알 수 있습니다. <br>
ACK이 도착하면 base가 앞으로 이동하며, 이로써 윈도우(window)가 슬라이딩(sliding) 하게 됩니다. <br>
따라서 GBN은 슬라이딩 윈도우 프로토콜(sliding-window protocol) 이라고 부릅니다.

### 윈도우 크기와 시퀀스 번호 범위

시퀀스 번호는 패킷 헤더의 고정된 비트 수(k)로 표현됩니다. <br>
따라서 시퀀스 번호의 가능한 범위는 다음과 같습니다.

0 ≤ seqnum ≤ 2^𝑘 − 1

즉, 2^k개의 시퀀스 번호가 존재하며, 가장 큰 번호(2^k - 1) 다음에는 다시 0으로 돌아가는 모듈로 연산(modulo arithmetic) 이 적용됩니다.

예를 들어 rdt3.0에서는 k=1이므로 시퀀스 번호의 범위가 [0,1] 두 개뿐이었습니다.
반면 GBN에서는 훨씬 큰 범위를 사용할 수 있으며, TCP의 경우 32비트 시퀀스 번호를 사용합니다.

### GBN 송신자의 세 가지 주요 이벤트

GBN 송신자는 세 가지 사건(event)에 반응해야 합니다. <br>

1. 상위 계층으로부터의 호출 (Invocation from above)
   - rdt_send()가 호출되면, 송신자는 현재 윈도우가 가득 찼는지 확인합니다. 
   - 윈도우가 가득 차지 않았다면 새 패킷을 생성하고 전송하며, 변수(nextseqnum, base 등)를 갱신합니다. 
   - 윈도우가 가득 차 있다면 데이터를 상위 계층으로 다시 반환하여 “잠시 후 다시 시도하라”는 신호를 보냅니다. 실제 구현에서는 이 데이터를 버퍼에 저장하거나, 동기화 플래그를 이용해 대기 상태로 둘 수 있습니다.

2. ACK 수신 (Receipt of an ACK)
   - GBN에서는 누적 ACK(cumulative acknowledgment)를 사용합니다. 즉, 시퀀스 번호 n에 대한 ACK은 “n 이하의 모든 패킷이 올바르게 수신되었다”는 의미입니다. 
   - 송신자는 ACK을 받으면 base를 그 다음 시퀀스로 갱신합니다.

3. 타임아웃 발생 (Timeout event)
   - GBN의 이름 “Go-Back-N”은 바로 이 타임아웃 동작에서 유래했습니다. 
   - 송신자는 가장 오래된 미확인 패킷에 대해 타이머를 유지합니다. 
   - 타임아웃이 발생하면, ACK을 받지 못한 모든 패킷을 다시 전송합니다. 
   - ACK이 도착하면 타이머를 재시작하거나, 미확인 패킷이 없으면 타이머를 중지합니다.

### GBN 수신자의 동작

수신자의 행동은 단순합니다.

만약 시퀀스 번호 n인 패킷이 순서대로 도착했다면(즉, 바로 이전 패킷 n−1이 이미 도착했다면), 수신자는 ACK(n)을 보내고 데이터를 상위 계층으로 전달합니다. <br>
그렇지 않다면(즉, 순서가 어긋났다면), 수신자는 패킷을 버리고, 가장 최근에 올바르게 수신된 패킷 번호에 대한 ACK을 재전송합니다.

이 방식은 수신 버퍼링을 단순화시킵니다. <br>
즉, 수신자는 순서가 맞지 않는 패킷을 버리기 때문에 “다음에 올 것으로 기대되는 시퀀스 번호(expectedseqnum)” 하나만 기억하면 됩니다.

하지만 이 방법에는 단점도 있습니다. <br>
정상적으로 수신된 패킷이라도 순서가 어긋나면 버려지므로, 송신자는 해당 패킷을 나중에 다시 재전송해야 합니다. <br>
따라서 불필요한 재전송이 발생할 수 있습니다.

<img width="553" height="648" alt="Image" src="https://github.com/user-attachments/assets/cdf838a7-6159-44ab-877a-39552d23b119" />

> GBN의 동작 예시
> 그림 3.22는 윈도우 크기 4인 경우의 GBN 프로토콜을 보여줍니다. <br>
> 송신자는 패킷 0~3을 전송한 후 ACK을 기다립니다. 
> 패킷 2가 손실되면, 수신자는 패킷 3·4·5를 받더라도 순서가 어긋났기 때문에 모두 버립니다. 
> 송신자는 타임아웃이 발생하면 패킷 2 이후의 모든 패킷을 재전송합니다. 
> ACK이 순차적으로 도착하면, 송신 윈도우가 앞으로 이동하며 다음 패킷 전송이 허용됩니다.

GBN 프로토콜의 실제 구현은 이벤트 기반(event-based) 프로그래밍으로 표현됩니다.
즉, 특정 사건이 발생할 때마다 해당 이벤트를 처리하는 절차가 호출됩니다.

- 상위 계층에서 rdt_send() 호출 
- 타이머 인터럽트 발생 
- 하위 계층에서 rdt_rcv() 호출

이러한 구조는 실제 TCP나 기타 전송 계층 프로토콜의 동작과 매우 유사합니다.

## 3.4.4 Selective Repeat (SR)

GBN 프로토콜은 송신자가 여러 패킷으로 “파이프라인을 채우는(fill the pipeline)” 것을 허용하여, 정지-대기(stop-and-wait) 프로토콜에서 발생했던 낮은 채널 활용도 문제를 해결합니다. <br>
그러나 GBN 자체도 성능 문제가 생길 수 있는 몇 가지 상황이 있습니다.  <br>
특히 **윈도우 크기(window size)** 와 **대역폭-지연 곱(bandwidth-delay product)** 이 모두 큰 경우, 파이프라인에 매우 많은 패킷이 존재하게 됩니다.

이때 **단 하나의 패킷 오류**만 발생하더라도, GBN은 많은 패킷들을 불필요하게 재전송해야 하는 상황이 생깁니다. <br>
채널 오류 확률이 높아질수록 파이프라인은 이러한 불필요한 재전송으로 가득 차게 됩니다.

예를 들어, 우리가 메시지를 받아 적는 상황(message dictation)을 상상해 봅시다.  <br>
만약 어떤 단어 하나를 잘못 들을 때마다 그 주변 1,000개의 단어(즉, 윈도우 크기가 1,000 단어라고 가정)가 전부 다시 반복된다면 기록 속도는 엄청나게 느려질 것입니다.

### 선택적 재전송(Selective Repeat)의 개념

이름에서 알 수 있듯이, **Selective Repeat(SR)** 프로토콜은 필요하지 않은 재전송을 피하기 위해 **수신 측에서 오류(손실 또는 손상)된 패킷만 선택적으로 재전송**하도록 합니다.

이 방식을 사용하려면 수신 측이 **개별적으로 각 패킷에 대한 ACK(수신 확인)** 을 보내야 합니다.  <br>
즉, 송신자는 어떤 패킷이 손실되었는지 정확히 알 수 있고, 그 패킷만 골라서 재전송할 수 있습니다.

윈도우 크기 N은 여전히 파이프라인 내의 미확인(unacknowledged) 패킷 수를 제한하는 역할을 합니다. <br>
그러나 GBN과 달리, 송신자는 윈도우 내 일부 패킷에 대해서는 이미 ACK을 받을 수 있습니다.

### SR 수신자의 동작

SR 수신자는 **수신한 패킷이 순서에 맞든 아니든**, 정상적으로 수신되었다면 ACK을 보냅니다.

만약 순서가 어긋난(out-of-order) 패킷이라면, 수신자는 그 패킷을 **버퍼(buffer)** 에 저장해 둡니다. <br>
그리고 누락된(더 낮은 시퀀스 번호의) 패킷이 도착하면 그때 한꺼번에 상위 계층으로 전달합니다.

### 재확인(재전송) ACK의 필요성

**2단계(Step 2)** 에서 수신자는 현재 윈도우 기준보다 낮은 시퀀스 번호를 가진 패킷에 대해서도 이미 수신된 패킷을 **다시 한 번 ACK으로 확인(reacknowledge)** 합니다.

이는 매우 중요합니다. <br>
예를 들어, 송신자가 `send_base` 패킷에 대한 ACK을 받지 못한 상태라고 가정합시다. <br>
수신자는 이미 해당 패킷을 받았더라도, ACK이 송신자에게 전달되지 않았다면 송신자는 결국 `send_base` 패킷을 **다시 재전송**하게 됩니다.

즉, 수신자가 이미 받은 패킷이라도 ACK을 반복적으로 보내야 송신자의 윈도우가 앞으로 이동할 수 있습니다. <br>
이것은 SR 프로토콜뿐만 아니라 많은 네트워크 프로토콜의 핵심 동작 원리 중 하나입니다.

따라서 송신자와 수신자는 항상 “어떤 패킷이 제대로 전달되었는지”에 대해 완벽히 동일한 관점을 가지지 않습니다. <br>
이 말은 곧, **SR 프로토콜에서는 송신자와 수신자의 윈도우가 완전히 일치하지 않을 수 있다**는 뜻입니다.


### 송신자·수신자 윈도우 불일치의 결과

송신자와 수신자 윈도우가 동기화되지 않는다는 점은 **시퀀스 번호의 범위가 유한(finite)** 할 때 중요한 결과를 초래합니다. <br>
예를 들어, 시퀀스 번호가 0, 1, 2, 3인 네 개의 패킷이 있고 윈도우 크기가 3이라고 합시다.

1. **첫 번째 시나리오**
    - 패킷 0~2가 정상적으로 수신 및 ACK됨.
    - 수신자의 윈도우는 3, 0, 1을 포함.
    - 송신자는 ACK을 받지 못하고, 패킷 0~2를 다시 전송.
    - 수신자는 시퀀스 번호 0 패킷(이미 받았던 것)을 다시 받게 됨 → 중복 패킷 발생.

2. **두 번째 시나리오**
    - 패킷 0~2가 정상적으로 ACK되고, 송신자 윈도우가 이동.
    - 송신자는 패킷 3, 0, 1을 전송.
    - 이번에는 시퀀스 번호 3의 패킷이 손실되고,  
      수신자는 새로운 데이터(시퀀스 번호 0)를 받게 됨.

수신자의 입장에서는 두 경우 모두 동일하게 보이므로, 패킷이 **재전송된 것인지, 새로운 데이터인지를 구분하기 어렵습니다.**

따라서 **SR 프로토콜의 윈도우 크기는 시퀀스 번호 공간의 절반 이하로 제한되어야 한다**는 결론에 이르게 됩니다. <br>
즉, `Window Size ≤ Sequence Number Space / 2`.

| **Mechanism** | **Use / Comments** |
|----------------|--------------------|
| **Checksum** | 전송된 패킷 내의 비트 오류를 검출하기 위해 사용됨. |
| **Timer** | 패킷(또는 ACK)이 손실되었을 때 재전송을 트리거함. 패킷이 지연되었을 때도 오작동할 수 있으므로 주의 필요. |
| **Sequence number** | 패킷의 순서를 추적하고, 누락 또는 중복 패킷을 감지하는 데 사용됨. |
| **Acknowledgment (ACK)** | 수신자가 송신자에게 특정 패킷이 올바르게 수신되었음을 알림. 개별 또는 누적 ACK 모두 가능. |
| **Negative acknowledgment (NAK)** | 수신자가 특정 패킷이 잘못 수신되었음을 송신자에게 알림. |
| **Window / Pipelining** | 여러 패킷을 동시에 전송 가능하게 하여 채널 활용도를 극대화함. 윈도우 크기는 수신자의 버퍼 용량 또는 네트워크 혼잡 수준에 따라 조정됨. |

### 패킷 재정렬(packet reordering)에 대한 고려

지금까지 우리는 **채널 내에서 패킷이 재정렬되지 않는다**는 가정을 해왔습니다.   <br>
하지만 실제 네트워크에서는, 송신자와 수신자가 하나의 물리적 링크가 아니라 **여러 경로를 가진 네트워크**로 연결되어 있을 수 있습니다.

이 경우, 동일한 시퀀스 번호를 가진 오래된 패킷이 뒤늦게 다시 네트워크를 통해 도착할 수도 있습니다. <br>
이를 방지하기 위해 실무에서는 **“패킷 수명(packet lifetime)”** 을 제한합니다. <br>
즉, 패킷은 네트워크 내에서 일정 시간 이상 “살아남지” 못하게 하는 것입니다.

TCP에서는 **최대 패킷 수명(Maximum Packet Lifetime)** 을 약 **3분**으로 설정하여 이 문제를 방지합니다.  
또한, 시퀀스 번호를 재사용하지 않도록 관리하여 중복 패킷이 잘못 인식되는 문제를 완전히 피할 수 있습니다.





