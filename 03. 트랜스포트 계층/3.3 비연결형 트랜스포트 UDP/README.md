# 3.3 비연결형 트랜스포트 UDP

이 절에서는 UDP가 무엇이며, 어떻게 동작하고, 어떤 역할을 하는지 자세히 살펴봅니다. 

UDP에 대한 논의를 시작하기 위해, 여러분이 단순하고 최소한의 기능만 가진 전송 프로토콜을 설계한다고 가정해봅시다. <br>  
어떻게 접근할 수 있을까요? 우선 아주 단순한 ‘빈 껍데기’ 수준의 전송 프로토콜을 생각해볼 수 있습니다.  <br>
보내는 쪽에서는 애플리케이션 프로세스에서 생성된 메시지를 받아 네트워크 계층에 바로 전달하고, 받는 쪽에서는 네트워크 계층에서 전달된 메시지를 그대로 애플리케이션 프로세스에 넘기는 식입니다.

하지만 앞 절에서 배웠듯이, 전송 계층은 단순히 메시지를 전달하는 것 이상의 역할을 해야 합니다. <br>  
최소한, 네트워크 계층과 애플리케이션 계층 사이에서 데이터를 올바른 프로세스에 전달하기 위해 다중화(multiplexing)와 역다중화(demultiplexing) 기능을 제공해야 합니다.

UDP는 [RFC 768]에서 정의되어 있으며, 전송 프로토콜 중에서도 가장 단순한 수준의 기능만 수행합니다.  <br>
다중화/역다중화 기능과 약간의 오류 검사를 제외하면, IP에 거의 아무것도 추가하지 않습니다.  <br>
즉, 애플리케이션이 TCP 대신 UDP를 선택한다면, 애플리케이션은 거의 직접 IP와 통신하는 것과 다름없습니다. <br>

UDP는 애플리케이션 프로세스의 메시지에 송신지 및 수신지 포트 번호를 추가해 다중화/역다중화 서비스를 제공하고, 몇 가지 작은 필드를 덧붙인 후 네트워크 계층으로 전달합니다. <br>  
네트워크 계층은 이 UDP 세그먼트를 IP 데이터그램에 캡슐화하고, 최선의 노력(best-effort) 방식으로 수신 호스트로 전달합니다. <br>

세그먼트가 수신 호스트에 도착하면, UDP는 포트 번호를 이용해 해당 애플리케이션 프로세스로 데이터를 전달합니다.  <br>
UDP는 송신자와 수신자 간의 핸드셰이킹(handshaking)을 수행하지 않기 때문에, UDP는 **비연결형(connectionless)** 프로토콜이라고 부릅니다.

## DNS와 UDP의 관계

DNS는 UDP를 사용하는 대표적인 애플리케이션 계층 프로토콜입니다. <br>  
DNS 애플리케이션이 질의(query)를 전송할 때, 질의 메시지를 UDP에 전달하면 UDP는 이를 UDP 세그먼트로 만들어 네트워크 계층으로 전달합니다. <br>  
이 과정에서 아무런 핸드셰이킹 없이 메시지가 전송됩니다.  <br>
수신 측에서는 UDP가 헤더 필드를 추가해 세그먼트를 IP 데이터그램으로 캡슐화하고, 이를 네트워크 계층을 통해 전송합니다.

DNS 클라이언트는 응답을 기다리다가 응답이 오지 않으면(예: 네트워크에서 패킷 손실 발생 시) 다시 질의를 전송하거나 다른 네임 서버에 요청을 시도합니다.

## UDP를 선택하는 이유

그렇다면 왜 개발자는 TCP가 아닌 UDP를 사용할까요?  <br>
TCP는 신뢰성 있는 데이터 전송을 보장하지만, UDP는 그렇지 않습니다. <br>  
그럼에도 불구하고, 다음과 같은 이유로 UDP가 더 적합한 경우가 있습니다.

### 애플리케이션 수준에서 데이터 전송 시점과 내용 제어 가능

UDP는 애플리케이션이 데이터를 전달하는 즉시 전송할 수 있습니다. <br>  
TCP는 혼잡 제어(congestion control)를 수행하기 때문에, 네트워크가 혼잡하면 전송 속도가 제한되고, 데이터 재전송으로 인해 지연이 발생할 수 있습니다. <br>  
실시간 애플리케이션(예: 화상회의, 음성 통화 등)은 일정한 전송 속도를 유지하고 일부 데이터 손실을 감수할 수 있으므로 UDP가 더 적합합니다. 

### 연결 설정이 필요 없음

TCP는 데이터 전송 전에 3-way 핸드셰이킹을 수행하지만, UDP는 이런 절차 없이 바로 데이터를 보냅니다. <br>  
따라서 연결 설정 지연이 없습니다.  <br>
이 점 때문에 DNS가 TCP보다 UDP를 사용하는 것이며, HTTP/3에서 사용되는 **QUIC**도 UDP 기반으로 구현되었습니다.

### 연결 상태 유지 불필요

TCP는 송수신 버퍼, 시퀀스 번호, 확인 응답 번호 등 상태 정보를 유지해야 하지만, UDP는 상태를 저장하지 않습니다. <br>  
따라서 UDP를 사용하는 서버는 TCP보다 훨씬 더 많은 클라이언트를 동시에 처리할 수 있습니다.

### 작은 헤더 오버헤드

TCP 헤더는 20바이트지만, UDP 헤더는 단 8바이트입니다.  
이로 인해 패킷당 오버헤드가 작아집니다.

## UDP와 TCP를 사용하는 대표적인 애플리케이션

| 애플리케이션 | 애플리케이션 계층 프로토콜 | 전송 계층 프로토콜 |
|---------------|-----------------------------|--------------------|
| 전자메일 | SMTP | TCP |
| 원격 터미널 접근 | Telnet | TCP |
| 보안 원격 터미널 접근 | SSH | TCP |
| 웹 | HTTP, HTTP/3 | TCP(HTTP), UDP(HTTP/3) |
| 파일 전송 | FTP | TCP |
| 원격 파일 서버 | NFS | 주로 UDP |
| 스트리밍 멀티미디어 | DASH | TCP |
| 인터넷 전화 | 주로 독자적 | UDP 또는 TCP |
| 네트워크 관리 | SNMP | 주로 UDP |
| 이름 변환 | DNS | 주로 UDP |

## UDP 사용 시 주의점

UDP에는 혼잡 제어 기능이 없습니다.  
모두가 UDP를 통해 대용량 스트리밍을 전송한다면, 네트워크는 곧 혼잡해지고 패킷 손실률이 급격히 높아질 것입니다. <br>  
UDP의 무제한 전송은 TCP의 성능까지 저하시킬 수 있습니다.  <br>
그래서 연구자들은 UDP를 포함한 모든 소스가 혼잡 제어를 수행하도록 하는 방안을 제안했습니다.

애플리케이션 수준에서 신뢰성을 구현하는 것도 가능합니다.  <br>
예를 들어 QUIC 프로토콜은 UDP 위에서 신뢰성 있는 전송을 구현하며, 이런 방식을 통해 개발자는 필요한 신뢰성과 속도를 직접 조정할 수 있습니다. <br>

이 절에서는 전송 계층의 다중화와 역다중화에 대해 알아봅니다.  <br>
즉, 네트워크 계층이 제공하는 호스트 대 호스트 전송 서비스를, 실제 호스트에서 실행 중인 애플리케이션들에게 **프로세스 대 프로세스 전송 서비스**로 확장하는 과정입니다. <br>
설명을 더 구체적으로 하기 위해 인터넷 환경을 기반으로 전송 계층의 기본 서비스를 살펴보지만, 다중화와 역다중화는 모든 컴퓨터 네트워크에 필수적인 서비스임을 다시 한 번 강조합니다.

목적지 호스트에서는 전송 계층이 바로 아래의 네트워크 계층에서 전달받은 세그먼트를 받게 됩니다.  <br>
전송 계층은 이 세그먼트에 담긴 데이터를, 해당 호스트에서 실행 중인 적절한 애플리케이션에 정확히 전달해야 할 의무가 있습니다. <br>  
예를 들어, 여러분이 컴퓨터 앞에 앉아 웹에서 파일을 다운로드하는 동시에 FTP 연결 하나와 텔넷 연결 두 개를 실행하고 있다고 가정해봅시다. <br>  
즉, 총 네 개의 애플리케이션이 실행 중입니다 — 두 개의 텔넷 프로세스, 하나의 FTP 프로세스, 하나의 HTTP 프로세스. <br> 
컴퓨터의 전송 계층이 네트워크 계층에서 올라온 데이터를 받으면, 이 데이터는 네 개의 애플리케이션 중 하나로 정확히 라우팅되어야 합니다.

## UDP 세그먼트 구조

애플리케이션 데이터는 UDP 세그먼트의 데이터 필드에 포함됩니다. <br>  
예를 들어, DNS의 경우 데이터 필드는 질의 메시지나 응답 메시지를 담습니다. <br>  
스트리밍 오디오 애플리케이션에서는 오디오 샘플이 데이터 필드를 채웁니다.

UDP 헤더는 네 개의 필드로 구성되어 있으며, 각 필드는 2바이트(16비트)입니다.  <br>
앞 절에서 논의한 것처럼, 포트 번호는 수신 호스트가 해당 데이터를 올바른 프로세스로 전달할 수 있도록 합니다(즉, 역다중화 기능을 수행합니다).

길이(length) 필드는 UDP 세그먼트 전체의 길이(헤더 + 데이터)를 바이트 단위로 명시합니다.  <br>
데이터 필드의 크기가 세그먼트마다 다를 수 있으므로, 이 값은 반드시 명시되어야 합니다.

체크섬(checksum)은 수신 호스트가 세그먼트에 오류가 발생했는지를 확인하기 위해 사용됩니다.  <br>
실제로 체크섬은 UDP 세그먼트뿐만 아니라 IP 헤더의 일부 필드를 포함해 계산되지만, 이 절에서는 단순화를 위해 UDP 내부 계산만 다룹니다. <br>  
체크섬 계산의 기본 원리는 오류 검출(error detection)이며, 그 원리는 6.2절에서 더 자세히 다루게 됩니다.

<img width="277" height="214" alt="Image" src="https://github.com/user-attachments/assets/887fa077-f300-4b92-994f-59d9834e549e" />

## UDP 체크섬

UDP 체크섬은 오류 검출(error detection)을 위한 기능을 제공합니다.  <br>
즉, UDP 세그먼트가 송신지에서 수신지로 이동하는 동안 (링크의 잡음이나 라우터의 저장 과정 등으로 인해) 비트가 손상되었는지를 확인하기 위해 사용됩니다.

송신 측의 UDP는 세그먼트 내 모든 16비트 단어들의 합을 계산하고, 그 결과에 대해 **1의 보수(1’s complement)** 연산을 수행합니다. <br>  
합산 중 발생하는 오버플로우는 다시 하위 비트로 순환(wrapped around)시킵니다. 그 결과값이 UDP 세그먼트의 체크섬 필드에 저장됩니다.


### UDP가 체크섬을 제공하는 이유

“이더넷(Ethernet)”과 같은 많은 링크 계층 프로토콜에서도 오류 검사를 수행하지만, UDP가 자체적으로 체크섬을 제공하는 이유는 **모든 링크가 오류 검사를 수행한다고 보장할 수 없기 때문**입니다. <br>  
일부 링크는 오류 검사를 하지 않을 수도 있으며, 또한 라우터 내부에서 세그먼트를 저장하거나 전달하는 과정에서 비트 손상이 발생할 수도 있습니다.

따라서 UDP는 **종단 간(end-to-end)** 오류 검출을 자체적으로 수행해야 합니다.  <br>
이것이 바로 시스템 설계의 유명한 **종단 간 원리(end-to-end principle)** 에 해당합니다. <br>  
즉, “하위 계층에서 제공되는 기능은 상위 계층에서 재검사되거나 보완되어야 한다”는 개념입니다.

### UDP의 오류 처리 방식

IP는 거의 모든 2계층 프로토콜 위에서 동작할 수 있기 때문에, 전송 계층이 안전장치로서 오류 검사를 수행하는 것이 유용합니다. <br>  
하지만 UDP는 오류 복구(recovery)는 수행하지 않습니다. <br>  
일부 구현에서는 오류가 감지되면 세그먼트를 단순히 폐기하고, 다른 구현에서는 애플리케이션에 손상된 세그먼트를 경고와 함께 전달합니다.

