# 3.2 다중화와 역다중화

이 절에서는 **전송 계층의 다중화와 역다중화**에 대해 알아봅니다. <br>
즉, 네트워크 계층이 제공하는 호스트 대 호스트 전송 서비스를, 실제 호스트에서 실행 중인 애플리케이션들에게 **프로세스 대 프로세스 전송 서비스**로 확장하는 과정입니다. <br>
설명을 더 구체적으로 하기 위해 인터넷 환경을 기반으로 전송 계층의 기본 서비스를 살펴보지만, **다중화와 역다중화는 모든 컴퓨터 네트워크에 필수적인 서비스**임을 다시 한 번 강조합니다.

목적지 호스트에서는 전송 계층이 바로 아래의 네트워크 계층에서 전달받은 **세그먼트**를 받게 됩니다. 전송 계층은 이 세그먼트에 담긴 데이터를, 해당 호스트에서 실행 중인 **적절한 애플리케이션**에 정확히 전달해야 할 의무가 있습니다. <br>
예를 들어, 여러분이 컴퓨터 앞에 앉아 웹에서 파일을 다운로드하는 동시에 FTP 연결 하나와 텔넷 연결 두 개를 실행하고 있다고 가정해봅시다. <br>
즉, 총 네 개의 애플리케이션이 실행 중입니다 — 두 개의 텔넷 프로세스, 하나의 FTP 프로세스, 하나의 HTTP 프로세스. 컴퓨터의 전송 계층이 네트워크 계층에서 올라온 데이터를 받으면, 이 데이터는 네 개의 애플리케이션 중 하나로 **정확히 라우팅**되어야 합니다.

<img width="744" height="364" alt="Image" src="https://github.com/user-attachments/assets/e3f5134c-0f5c-4ec6-99d1-dcc7b3a257c5" />

## **다중화와 역다중화의 동작 원리**

각 인터넷 애플리케이션 프로세스는 하나 이상의 **소켓(socket)** 을 가질 수 있습니다. 소켓은 해당 프로세스가 네트워크와 데이터를 주고받는 **출입구**입니다. <br>
전송 계층은 데이터를 직접 애플리케이션에 전달하는 것이 아니라, **중간에 위치한 소켓**에 전달합니다. 각 소켓은 고유한 식별 번호를 가지며, 이 번호의 형식은 UDP인지 TCP인지에 따라 다릅니다.<br>

수신 호스트가 전송 계층에서 받은 세그먼트를 올바른 소켓으로 전달하는 방법은, **각 세그먼트의 헤더에 포함된 여러 필드**를 확인하는 것입니다. <br>
전송 계층은 이 필드들을 검사해, 세그먼트가 어떤 소켓으로 가야 하는지 식별한 뒤, 해당 소켓에 데이터를 전달합니다. 이 과정이 바로 **역다중화(demultiplexing)** 입니다.<br>
반대로, 송신 호스트에서는 여러 소켓에서 나온 데이터 블록을 모아, 각 블록에 헤더 정보를 붙여 세그먼트로 만들고 네트워크 계층에 넘기는 과정을 **다중화(multiplexing)** 라고 합니다.<br>
**중요 개념:** 어떤 계층(전송 계층 또는 기타)이 하나의 프로토콜을 통해 상위 계층의 여러 프로토콜에서 동시에 사용된다면, 반드시 **다중화와 역다중화 작업**이 필요합니다.<br>

## **비유로 이해하는 다중화와 역다중화**

형제자매가 많은 집에서, 각 아이는 이름으로 식별됩니다. <br>
소밍이 우편배달부에게서 편지 뭉치를 받아오면, **편지의 수신인을 확인해 각 형제자매에게 직접 전달**합니다(역다중화). <br>
반대로, 소미는 형제자매들에게서 편지를 모아 우편배달부에게 한 번에 전달합니다(다중화).<br>

## **소켓과 포트 번호**

<img width="438" height="353" alt="Image" src="https://github.com/user-attachments/assets/ae267bd4-5a91-4af2-bee3-5d37627a7be1" />

각 소켓은 고유한 **포트 번호**로 식별됩니다. 세그먼트에는 **출발지 포트 번호(source port number)** 와 **목적지 포트 번호(destination port number)** 라는 필드가 포함되어 있습니다.<br>
포트 번호는 16비트 숫자(0~65535)이며, 0~1023번은 **잘 알려진 포트(well-known port)** 로 일반 개발자가 사용할 수 없습니다. 예를 들어, HTTP는 80번, FTP는 21번 포트를 사용합니다.<br>
새로운 애플리케이션을 개발할 때는, 반드시 사용할 포트 번호를 지정해야 합니다.<br>

전송 계층의 역다중화 구현은 다음과 같습니다: 각 소켓에 포트 번호를 할당하고, 세그먼트가 도착하면 목적지 포트 번호 필드를 확인해 **해당 소켓으로 전달**합니다. 이후 소켓을 통해 애플리케이션 프로세스에 데이터가 전달됩니다.<br>
UDP의 경우 이 방식이 그대로 적용되며, TCP는 더 정교한 다중화/역다중화 기능을 갖추고 있습니다.<br>


## **연결 없는 다중화와 역다중화 (UDP)**

UDP 소켓은 보통 다음과 같이 생성합니다:<br>
```
clientSocket = socket(AF_INET, SOCK_DGRAM)
```
이때 전송 계층은 1024~65535 범위에서 사용되지 않은 포트를 자동으로 할당합니다. 서버라면 `bind()`를 통해 특정 포트(예: 19157)를 직접 지정할 수도 있습니다.<br>
```
clientSocket.bind(('', 19157))
```
클라이언트는 보통 자동 할당, 서버는 직접 지정 방식을 사용합니다.<br>

예를 들어, A 호스트의 UDP 소켓(19157번)이 B 호스트의 UDP 소켓(46428번)으로 데이터를 보내면, 전송 계층은 **데이터, 출발지 포트(19157), 목적지 포트(46428)** 를 포함한 세그먼트를 만듭니다.<br>
네트워크 계층은 이를 IP 패킷으로 감싸서 B 호스트로 전달합니다. B 호스트의 전송 계층은 목적지 포트 번호(46428)를 확인해, 해당 소켓으로 데이터를 전달합니다.<br>
**중요:** UDP 소켓은 **목적지 IP 주소와 목적지 포트 번호**라는 2-튜플(two-tuple)로 완전히 결정됩니다. 출발지 정보와 상관없이 목적지 정보가 같으면 같은 소켓으로 전달됩니다.<br>


## **출발지 포트 번호의 역할**

출발지 포트 번호는 **"회신 주소"** 역할을 합니다. B가 A로 데이터를 다시 보낼 때, 목적지 포트 번호에 A→B 세그먼트의 출발지 포트 번호를 그대로 사용합니다.<br>
예를 들어, UDP 서버 프로그램에서는 `recvfrom()`으로 클라이언트의 포트 번호를 확인한 뒤, 회신 세그먼트의 목적지 포트로 사용합니다.<br>


## **연결 지향 다중화와 역다중화 (TCP)**

TCP 소켓은 **(출발지 IP, 출발지 포트, 목적지 IP, 목적지 포트)**라는 4-튜플(four-tuple)로 식별됩니다.<br>
따라서 TCP 세그먼트가 도착하면, 이 네 가지 정보를 모두 사용해 **정확한 소켓으로 전달**해야 합니다.<br>
UDP와 다르게, TCP는 **각 연결마다 고유한 4-튜플**을 가지므로, 출발지 정보가 다르면 같은 목적지 포트라도 다른 소켓으로 전달됩니다.<br>

예를 들어, TCP 서버는 12000번 포트에서 "웰커밍 소켓(welcoming socket)"으로 연결 요청을 기다립니다.<br>
클라이언트는 다음과 같이 연결을 요청합니다:<br>
```
clientSocket = socket(AF_INET, SOCK_STREAM)
clientSocket.connect((serverName, 12000))
```
서버는 연결 요청을 받으면 새로운 소켓을 생성합니다:<br>
```
connectionSocket, addr = serverSocket.accept()
```
이 소켓은 **(출발지 포트, 출발지 IP, 목적지 포트, 목적지 IP)** 네 가지 정보로 결정됩니다.<br>
서버는 동시에 여러 TCP 연결을 처리할 수 있으며, 각 연결은 고유한 4-튜플로 식별됩니다.<br>

<img width="752" height="494" alt="Image" src="https://github.com/user-attachments/assets/c13388c3-1277-4eeb-b79b-f01e40887257" />

## **포트 스캐닝**

서버 프로세스는 **특정 포트**에서 외부 연결 요청을 기다립니다.<br>
잘 알려진 서비스(Web, FTP, DNS, SMTP 등)는 고정 포트를 사용하며, 일부 유명 애플리케이션도 관례적으로 특정 포트를 사용합니다(예: Microsoft SQL Server는 UDP 1434).<br>
특정 포트가 열려 있다면, 해당 포트에서 어떤 애플리케이션이 실행 중인지 확인할 수 있습니다. 이는 시스템 관리자뿐 아니라 공격자에게도 중요한 정보입니다.<br>
예를 들어, 1434번 포트에서 실행 중인 SQL 서버에 취약점이 있다면, 원격 공격자가 악성 코드를 실행할 수 있습니다.<br>

포트 스캐너 프로그램(nmap 등)을 사용하면, **어떤 포트가 열려 있는지 쉽게 확인**할 수 있습니다. nmap은 TCP 포트에 대해 연결 요청을 순차적으로 시도하고, UDP 포트에 대해 응답 여부를 확인합니다. 결과로 열린 포트, 닫힌 포트, 접근 불가 포트 목록을 제공합니다.<br>

## **웹 서버와 TCP**

웹 서버(예: Apache)는 보통 **80번 포트**에서 실행됩니다. 클라이언트(브라우저)는 모든 요청의 목적지 포트 번호를 80번으로 설정합니다.<br>
서버는 **클라이언트의 출발지 IP와 출발지 포트**로 각 연결을 구분합니다.<br>
고성능 웹 서버는 하나의 프로세스에서 여러 소켓(쓰레드)로 동시 연결을 처리할 수 있습니다.<br>
**지속적 HTTP 연결**을 사용하면 같은 소켓으로 여러 요청/응답을 처리하고, **비지속적 연결**을 사용하면 요청/응답마다 새로운 TCP 연결(소켓)이 생성되고 종료됩니다. 비지속적 연결은 서버에 성능 부담을 줄 수 있습니다.<br>
